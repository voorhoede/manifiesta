{"version":3,"sources":["webpack:///static/js/0.2775868eef29d18b513f.js","webpack:///src/components/manifest-editor/manifest-editor.vue","webpack:///./node_modules/querystring-es3/index.js","webpack:///./node_modules/jsonschema/lib/validator.js","webpack:///(webpack)/buildin/module.js","webpack:///./node_modules/codemirror/lib/codemirror.css?0c70","webpack:///./src/components/manifest-editor/manifest-editor.vue","webpack:///./node_modules/codemirror/mode/javascript/javascript.js","webpack:///./node_modules/jsonschema/lib/index.js","webpack:///./node_modules/vue-codemirror-lite/codemirror.vue?d8f1","webpack:///./node_modules/codemirror/lib/codemirror.js","webpack:///./node_modules/codemirror/theme/eclipse.css","webpack:///./src/components/manifest-editor/manifest-editor.scss?b8bd","webpack:///./node_modules/codemirror/lib/codemirror.css","webpack:///./src/components/manifest-editor/manifest-editor.scss","webpack:///./node_modules/vue-codemirror-lite/codemirror.vue","webpack:///./node_modules/punycode/punycode.js","webpack:///./src/lib/language-tags.js","webpack:///./src/components/manifest-editor/manifest-editor.vue?7cf6","webpack:///./node_modules/vue-codemirror-lite/codemirror.vue?1ff1","webpack:///./src/lib/debounce.js","webpack:///./node_modules/url/url.js","webpack:///./node_modules/vue-codemirror-lite/codemirror.vue?d0e0","webpack:///./src/lib/codemirror-lint-manifest.js","webpack:///./node_modules/jsonschema/lib/attribute.js","webpack:///./node_modules/json-lint/jsonlint.js","webpack:///./node_modules/codemirror/addon/lint/lint.css","webpack:///./src/lib/manifest-schema.js","webpack:///node_modules/vue-codemirror-lite/codemirror.vue","webpack:///./node_modules/vue-codemirror-lite/index.js","webpack:///./node_modules/jsonschema/lib/helpers.js","webpack:///./node_modules/querystring-es3/decode.js","webpack:///./node_modules/babel-runtime/core-js/json/stringify.js","webpack:///./node_modules/url/util.js","webpack:///./node_modules/core-js/library/fn/json/stringify.js","webpack:///./node_modules/codemirror/addon/lint/lint.js","webpack:///./node_modules/querystring-es3/encode.js"],"names":["webpackJsonp","0CdP","module","__webpack_exports__","__webpack_require__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default","n","__WEBPACK_IMPORTED_MODULE_1_vue_types__","__WEBPACK_IMPORTED_MODULE_2__lib_debounce__","__WEBPACK_IMPORTED_MODULE_3_vue_codemirror_lite__","components","codemirror","props","manifest","object","isRequired","setManifest","func","data","options","mode","name","json","theme","lineNumbers","tabSize","lint","gutters","computed","code","get","this","set","Object","value","1nuA","exports","decode","parse","encode","stringify","1tE4","shouldResolve","schema","ref","$ref","urilib","attribute","helpers","ValidatorResult","SchemaError","SchemaContext","Validator","customFormats","create","prototype","schemas","unresolvedRefs","types","attributes","validators","addSchema","uri","ourUri","id","addSubSchema","baseuri","resolvedUri","resolve","undefined","push","ourBase","deepCompareStrict","Error","documentUri","replace","addSubSchemaArray","items","Array","extends","additionalItems","addSubSchemaObject","properties","additionalProperties","definitions","patternProperties","dependencies","disallow","allOf","anyOf","oneOf","not","i","length","p","setSchemas","getSchema","urn","validate","instance","ctx","propertyName","base","result","validateSchema","schemaobj","forEach","schemaTraverser","bind","deepMerge","superResolve","switchSchema","resolved","subctx","subschema","propertyPath","skipAttributes","key","ignoreProperties","indexOf","validatorErr","validator","call","allowUnknownAttributes","importErrors","rewrite","s","parsed","fragment","hash","document","substr","objectGetPath","testType","type","res","errors","string","number","isFinite","integer","boolean","array","isArray","date","Date","any","3IRH","webpackPolyfill","deprecate","paths","children","defineProperty","enumerable","l","4/hK","content","locals","41tG","injectStyle","ssrContext","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_manifest_editor_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_66e75edd_hasScoped_false_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_manifest_editor_vue__","normalizeComponent","__vue_styles__","Component","5IAE","mod","CodeMirror","defineMode","config","parserConfig","readRegexp","stream","next","escaped","inSet","ret","tp","style","cont","tokenBase","state","ch","tokenize","tokenString","match","test","eat","eatWhile","tokenComment","skipToEnd","expressionAllowed","current","tokenQuasi","isOperatorChar","lexical","wordRE","word","lastType","keywords","propertyIsEnumerable","kw","quote","jsonldMode","peek","isJsonldKeyword","maybeEnd","findFatArrow","fatArrowAt","arrow","start","isTS","m","exec","slice","index","depth","sawSomething","pos","charAt","bracket","brackets","JSLexical","indented","column","align","prev","info","inScope","varname","v","localVars","cx","context","vars","parseJS","cc","marked","hasOwnProperty","pop","jsonMode","expression","statement","lex","pass","arguments","apply","register","inList","list","globalVars","pushcontext","defaultVars","popcontext","pushlex","indent","outer","poplex","expect","wanted","exp","vardef","parenExpr","maybeexpression","block","maybeelse","functiondef","forspec","typeexpr","maybelabel","funarg","className","afterExport","afterImport","pattern","expressionInner","expressionNoComma","noComma","body","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","atomicTypes","classExpression","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","me","expr","property","backUp","continueQuasi","targetNoComma","target","maybeTypeArgs","_","getterSetter","afterprop","what","end","sep","proceed","maybetype","afterType","typeprop","typearg","maybeReturnType","maybeAssign","vardefCont","proppattern","_type","forspec1","forspec2","formaybeinof","forspec3","classNameAfter","classBody","classfield","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","isContinuedStatement","textAfter","indentUnit","statementIndent","jsonld","typescript","wordCharacters","A","B","C","D","operator","atom","jsKeywords","if","while","with","else","do","try","finally","return","break","continue","new","delete","void","throw","debugger","var","const","let","function","catch","for","switch","case","default","in","typeof","instanceof","true","false","null","NaN","Infinity","class","super","yield","export","import","await","tsKeywords","interface","implements","namespace","enum","public","private","protected","abstract","readonly","attr","variable","regexp","jsonld-keyword","startState","basecolumn","token","sol","indentation","eatSpace","Pass","top","firstChar","c","closing","doubleIndentSwitch","electricInput","blockCommentStart","blockCommentEnd","blockCommentContinue","lineComment","fold","closeBrackets","helperType","skipExpression","registerHelper","defineMIME","7HRn","ValidationError","7xRv","8U58","global","factory","classTest","cls","RegExp","removeChildren","e","count","childNodes","removeChild","firstChild","removeChildrenAndAdd","parent","appendChild","elt","tag","createElement","cssText","createTextNode","eltP","setAttribute","contains","child","nodeType","parentNode","host","activeElt","activeElement","shadowRoot","addClass","node","joinClasses","a","b","as","split","f","args","copyObj","obj","overwrite","prop","countColumn","startIndex","startValue","search","nextTab","findColumn","goal","col","skipped","Math","min","spaceStr","spaceStrs","lst","arr","map","out","insertSorted","score","priority","splice","nothing","createObj","inst","isWordCharBasic","toUpperCase","toLowerCase","nonASCIISingleCaseWordChar","isWordChar","helper","source","isEmpty","isExtendingChar","charCodeAt","extendingChars","skipExtendingChars","str","dir","findFirst","pred","from","to","midF","mid","ceil","floor","Display","place","doc","input","d","scrollbarFiller","gutterFiller","lineDiv","selectionDiv","cursorDiv","measure","lineMeasure","lineSpace","lines","mover","sizer","sizerWidth","heightForcer","scrollerGap","lineGutter","scroller","wrapper","ie","ie_version","zIndex","paddingRight","webkit","gecko","mobile","draggable","viewFrom","viewTo","first","reportedViewFrom","reportedViewTo","view","renderedView","externalMeasured","viewOffset","lastWrapHeight","lastWrapWidth","updateLineNumbers","nativeBarWidth","barHeight","barWidth","scrollbarsClipped","lineNumWidth","lineNumInnerWidth","lineNumChars","alignWidgets","cachedCharWidth","cachedTextHeight","cachedPaddingH","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","shift","selForContextMenu","activeTouch","init","getLine","size","chunk","sz","chunkSize","getBetween","line","iter","text","getLines","updateLineHeight","height","diff","lineNo","cur","no","lineAtHeight","h","i$1","lh","isLine","lineNumberFor","String","lineNumberFormatter","firstLineNumber","Pos","sticky","cmp","equalCursorPos","copyPos","x","maxPos","minPos","clipLine","max","clipPos","last","clipToLen","linelen","clipPosArray","seeReadOnlySpans","sawReadOnlySpans","seeCollapsedSpans","sawCollapsedSpans","MarkedSpan","marker","getMarkedSpanFor","spans","span","removeMarkedSpan","r","addMarkedSpan","markedSpans","concat","attachLine","markedSpansBefore","old","startCh","isInsert","nw","startsBefore","inclusiveLeft","insertLeft","endsAfter","inclusiveRight","markedSpansAfter","endCh","stretchSpansOverChange","change","full","oldFirst","oldLast","sameLine","offset","found","span$1","found$1","clearEmptySpans","newMarkers","gapMarkers","gap","i$2","i$3","clearWhenEmpty","removeReadOnlyRanges","markers","mark","readOnly","parts","mk","find","j","newParts","dfrom","dto","detachMarkedSpans","detachLine","attachMarkedSpans","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","sp","collapsed","collapsedSpanAtStart","collapsedSpanAtEnd","conflictingCollapsedRange","lineNo$$1","visualLine","merged","visualLineEnd","visualLineContinued","visualLineNo","lineN","vis","visualLineEndNo","lastLine","lineIsHidden","widgetNode","lineIsHiddenInner","heightAtLine","lineObj","lineLength","len","findMaxLine","cm","display","iterateBidiSections","order","part","level","getBidiPartAt","bidiOther","getOrder","direction","bidiOrdering","getHandlers","emitter","_handlers","noHandlers","off","removeEventListener","detachEvent","map$$1","signal","handlers","signalDOMEvent","override","preventDefault","defaultPrevented","e_defaultPrevented","codemirrorIgnore","signalCursorActivity","cursorActivity","curOp","cursorActivityHandlers","hasHandler","eventMixin","ctor","on","e_preventDefault","returnValue","e_stopPropagation","stopPropagation","cancelBubble","e_stop","e_target","srcElement","e_button","which","button","mac","ctrlKey","zeroWidthElement","zwspSupported","offsetHeight","offsetWidth","hasBadBidiRects","badBidiRects","txt","r0","range","getBoundingClientRect","r1","left","right","hasBadZoomedRects","badZoomedRects","normal","fromRange","abs","modes","mime","spec","mimeModes","resolveMode","getMode","mfactory","modeObj","modeExtensions","exts","modeProps","prop$1","extendMode","copyState","nstate","val","innerMode","a1","a2","highlightLine","forceToEnd","st","modeGen","lineClasses","runMode","o","overlays","baseTokens","overlay","at","i_end","opaque","baseTokenPos","styles","classes","bgClass","textClass","getLineStyles","updateFrontier","getContextBefore","resetState","maxHighlightLength","stateAfter","save","styleClasses","highlightFrontier","modeFrontier","precise","Context","findStartLine","saved","fromSaved","processLine","nextLine","startAt","StringStream","callBlankLine","eol","readToken","blankLine","inner","takeToken","asArray","tokens","Token","extractLineClasses","output","lineClass","flattenSpans","curStart","curStyle","addModeClass","mName","minindent","minline","lim","after","SavedContext","lookAhead","retreatFrontier","updateLine","estimateHeight","estHeight","cleanUpLine","interpretTokenStyle","cache","styleToClassCacheWithMode","styleToClassCache","buildLineContent","lineView","builder","pre","trailingSpace","splitSpaces","getOption","rest","addToken","buildToken","buildTokenBadBidi","insertLineContent","maps","caches","lastChild","querySelector","defaultSpecialCharPlaceholder","title","toString","startStyle","endStyle","css","displayText","special","specialChars","mustWrap","createDocumentFragment","lastIndex","txt$1","tabWidth","specialCharPlaceholder","fullStyle","trailingBefore","spaceBefore","buildCollapsedSpan","ignoreWidget","widget","needsContentAttribute","setUneditable","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","foundBookmarks","endStyles","j$1","j$2","upto","tokenText","LineView","hidden","buildViewArray","nextPos","pushOperation","op","operationGroup","ops","ownsGroup","delayedCallbacks","fireCallbacksForOps","group","callbacks","cursorActivityCalled","finishOperation","endCb","signalLater","orphanDelayedCallbacks","setTimeout","fireOrphanDelayed","delayed","updateLineForChanges","dims","changes","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","updateLineBackground","background","wrap","insertBefore","getLineContent","ext","built","wrapClass","gutter","gutterBackground","gutterClass","fixedGutter","fixedPos","gutterTotalWidth","gutterMarkers","wrap$1","gutterWrap","lineNumber","gutterLeft","k","gutterWidth","alignable","nextSibling","insertLineWidgets","buildLineElement","insertLineWidgetsFor","allowAbove","widgets","ws","handleMouseEvents","positionLineWidget","above","noHScroll","width","wrapperWidth","coverGutter","paddingLeft","position","marginLeft","widgetHeight","parentStyle","clientWidth","eventInWidget","getAttribute","paddingTop","offsetTop","paddingVert","paddingH","window","getComputedStyle","currentStyle","parseInt","isNaN","scrollGap","displayWidth","displayHeight","clientHeight","ensureLineHeights","rect","wrapping","lineWrapping","curWidth","heights","rects","getClientRects","bottom","mapFromLineView","before","updateExternalMeasurement","measureChar","bias","measureCharPrepared","prepareMeasureForLine","findViewForLine","findViewIndex","getDimensions","forceUpdate","hasHeights","prepared","varHeight","measureCharInner","bogus","rtop","rbottom","nodeAndOffsetInLineMap","collapse","mStart","mEnd","coverStart","coverEnd","getUsefulRect","nullRect","maybeUpdateRectForZooming","rSpan","charWidth","rbot","bot","singleCursorHeightPerLine","screen","logicalXDPI","deviceXDPI","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","clearCaches","pageScrollX","chrome","android","pageXOffset","documentElement","scrollLeft","pageScrollY","marginTop","pageYOffset","scrollTop","widgetTopHeight","intoCoordSystem","includeWidgets","yOff","lOff","xOff","fromCoordSystem","coords","localBox","lineSpaceBox","charCoords","cursorCoords","preparedMeasure","getBidi","partPos","invert","other","estimateCoords","PosWithInfo","outside","xRel","coordsChar","y","coordsCharInner","mergedPos","wrappedLineExtent","begin","wrappedLineExtentChar","boxIsAfter","box","widgetHeight$$1","ltr","coordsBidiPartWrapped","coordsBidiPart","baseX","chAround","boxAround","atLeft","atStart","_lineNo","closestDist","endX","dist","textHeight","measureText","anchor","clientLeft","offsetLeft","compensateForHScroll","th","perLine","widgetsHeight","estimateLineHeights","est","posFromMouse","liberal","forRect","space","clientX","clientY","colDiff","round","updateSelection","showSelection","prepareSelection","primary","curFragment","cursors","selFragment","selection","sel","ranges","primIndex","range$$1","empty","showCursorWhenSelecting","drawSelectionCursor","head","drawSelectionRange","cursor","cursorHeight","otherCursor","cmpCoords","add","rightSide","drawForLine","fromArg","toArg","wrapX","side","extent","lineLen","fromPos","toPos","openStart","openEnd","openLeft","docLTR","openRight","leftSide","topLeft","topRight","botLeft","botRight","padding","sFrom","sTo","fromLine","toLine","singleVLine","leftEnd","rightStart","restartBlink","focused","clearInterval","blinker","visibility","cursorBlinkRate","setInterval","ensureFocus","focus","onFocus","delayBlurEvent","delayingBlurEvent","onBlur","reset","receivedFocus","rmClass","updateHeightsInViewport","prevBottom","updateWidgetHeight","visibleLines","viewport","ensure","ensureFrom","ensureTo","alignHorizontally","comp","gutterW","maybeUpdateLineNumberWidth","innerW","updateGutterSpace","maybeScrollWindow","doScroll","innerHeight","phantom","scrollNode","scrollIntoView","scrollPosIntoView","margin","limit","changed","endCoords","scrollPos","calculateScrollPos","startTop","startLeft","updateScrollTop","setScrollLeft","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollTop","resolveScrollToPos","ensureCursorVisible","getCursor","scrollToPos","cursorScrollMargin","scrollToCoords","scrollToRange","scrollToCoordsRange","sPos","updateDisplaySimple","setScrollTop","startWorker","forceScroll","scrollHeight","scrollbars","isScroller","scrollWidth","measureForScrollbars","docH","viewHeight","viewWidth","barLeft","docHeight","updateScrollbars","startWidth","startHeight","updateScrollbarsInner","sizes","update","paddingBottom","borderBottom","coverGutterNextToScrollbar","initScrollbars","clear","scrollbarModel","scrollbarStyle","axis","startOperation","viewChanged","updateInput","typing","changeObjs","selectionChanged","updateMaxLine","nextOpId","endOperation","endOperations","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","i$4","endOperation_finish","maybeClipScrollbars","mustUpdate","DisplayUpdate","updatedDisplay","updateDisplayIfNeeded","barMeasure","adjustWidthTo","maxScrollLeft","preparedSelection","minWidth","takeFocus","setDocumentHeight","postUpdateDisplay","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","finish","runInOp","operation","methodOp","docMethodOp","regChange","lendiff","resetView","cut","viewCuttingPoint","cut$1","cutTop","cutBot","regLineChange","oldN","newN","adjustView","countDirtyView","dirty","time","highlight","highlightWorker","workTime","changedLines","oldStyles","highlighted","oldCls","newCls","ischange","workDelay","marginBottom","borderRightWidth","selectionSnapshot","hasFocus","active","getSelection","anchorNode","extend","anchorOffset","focusNode","focusOffset","restoreSelection","snapshot","createRange","setEnd","removeAllRanges","addRange","editorIsHidden","force","visible","viewportMargin","different","wrapperHeight","toUpdate","selSnapshot","patchDisplay","minHeight","oldDisplayWidth","updateNumbersFrom","rm","currentWheelTarget","container","updateNumber","updateGutters","specs","gElt","setGuttersForLineNumbers","wheelEventDelta","dx","wheelDeltaX","dy","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","delta","wheelPixelsPerUnit","onScrollWheel","scroll","canScrollX","canScrollY","presto","pixels","wheelSamples","movedX","movedY","sample","normalizeSelection","prim","sort","inv","Range","Selection","simpleSelection","changeEnd","adjustForChange","computeSelAfterChange","offsetPos","computeReplacedSel","hint","oldPrev","newPrev","loadMode","modeOption","resetModeState","isWholeLineUpdate","wholeLineUpdateBefore","updateDoc","estimateHeight$$1","spansFor","linesFor","Line","firstLine","lastText","lastSpans","nlines","insert","remove","added","added$1","added$2","linkedDocs","sharedHistOnly","propagate","skip","sharedHist","linked","rel","shared","attachDoc","setDirectionClass","directionChanged","History","startGen","done","undone","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","lastOrigin","lastSelOrigin","generation","maxGeneration","historyChangeFromChange","histChange","attachLocalSpans","clearSelectionEvents","lastChangeEvent","hist","addChangeToHistory","selAfter","opId","history","origin","historyEventDelay","pushSelectionToHistory","selectionEventCanBeMerged","somethingSelected","addSelectionToHistory","clearRedo","dest","equals","existing","removeClearedSpans","explicitlyCleared","getOldSpans","mergeOldSpans","stretched","oldCur","stretchCur","copyHistoryArray","events","newGroup","instantiateSel","copy","event","deepCopy","newChanges","Number","extendRange","posBefore","extendSelection","setSelection","extendSelections","heads","replaceOneSelection","setSimpleSelection","filterSelectionChange","this$1","setSelectionReplaceHistory","setSelectionNoUndo","setSelectionInner","skipAtomicInSelection","reCheckSelection","mayClear","newAnchor","skipAtomic","newHead","skipAtomicInner","oldPos","atomic","near","movePos","far","cantEdit","selectAll","sel_dontScroll","filterChange","canceled","cancel","makeChange","ignoreReadOnly","suppressEdits","makeChangeInner","makeChangeSingleDoc","rebased","rebaseHist","makeChangeFromHistory","allowSelectionOnly","antiChanges","filter","returned","shiftDoc","distance","removed","makeChangeSingleDocInEditor","recomputeMaxLength","checkWidthStart","changesHandler","changeHandler","replaceRange","assign","splitLines","rebaseHistSelSingle","rebaseHistArray","sub","ok","copied","changeLine","handle","changeType","LeafChunk","BranchChunk","adjustScrollWhenAboveVisible","addLineWidget","LineWidget","insertAt","aboveVisible","markText","markTextShared","TextMarker","replacedWith","addToHistory","curLine","clearOnEnter","clearHistory","nextMarkerId","cloneNode","isParent","SharedTextMarker","findSharedMarkers","findMarks","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker","onDrop","clearDragCursor","lastDrop","files","dataTransfer","isReadOnly","FileReader","File","read","file","allowDropFileTypes","reader","onload","join","lineSeparator","readAsText","draggingText","text$1","getData","selected","listSelections","replaceSelection","onDragStart","setData","effectAllowed","setDragImage","safari","img","src","_top","onDragOver","frag","dragCursor","forEachCodeMirror","getElementsByClassName","byClass","ensureGlobalHandlers","globalsRegistered","registerGlobalHandlers","resizeTimer","onResize","setSize","normalizeKeyName","alt","ctrl","cmd","normalizeKeyMap","keymap","keyname","keys","lookupKey","getKeyMap","fallthrough","isModifierKey","keyNames","keyCode","addModifierNames","noShift","altKey","flipCtrlCmd","metaKey","shiftKey","keyName","altGraphKey","keyMap","deleteNearSelection","compute","kill","toKill","replaced","moveCharLogically","moveLogically","endOfLine","visually","moveInStorageOrder","prep","targetTop","moveVisually","bidi","mv","getWrappedLineExtent","searchInVisualLine","getRes","nextCh","lineStart","visual","lineEnd","lineStartSmart","firstNonWS","inWS","doHandleBinding","bound","dropShift","commands","ensurePolled","prevShift","lookupKeyForEditor","keyMaps","extraKeys","dispatchKey","seq","keySeq","stopSeq","handleKeyBinding","motion","handleCharBinding","onKeyDown","handled","lastStoppedKey","hasCopyEvent","showCrossHair","up","onKeyUp","onKeyPress","charCode","fromCharCode","clickRepeat","now","lastDoubleClick","compare","lastClick","PastClick","onMouseDown","supportsTouch","clickInGutter","repeat","selectingText","handleMappedButton","leftButtonDown","captureRightClick","onContextMenu","configureMouse","option","unit","chromeOS","addNew","moveOnDrag","contained","behavior","dragDrop","dragAndDrop","leftButtonStartDrag","leftButtonSelect","moved","dragEnd","mouseMove","dragStart","e2","rangeForUnit","findWordAt","extendTo","lastPos","startCol","posCol","leftPos","startSel","ourIndex","oldRange","ourRange","ranges$1","bidiSimplify","sel_mouse","curCount","counter","editorSize","move","anchorLine","boundary","headIndex","usePart","gutterEvent","prevent","mX","mY","touches","lineBox","g","contextMenuInGutter","themeChanged","guttersChanged","dragDropChanged","Init","funcs","dragFunctions","toggle","enter","over","leave","drop","wrappingChanged","CodeMirror$1","defaults","Doc","inputStyles","inputStyle","pasteIncoming","cutIncoming","Delayed","autofocus","registerEventHandlers","opt","optionHandlers","finishInit","initHooks","textRendering","finishTouch","touchFinished","prevTouch","isMouseLikeTouchEvent","touch","radiusX","radiusY","farAway","clearTimeout","pageX","pageY","inp","getField","indentLine","how","aggressive","curSpace","curSpaceString","indentString","indentWithTabs","pos$1","setLastCopied","newLastCopied","lastCopied","applyTextInput","inserted","deleted","paste","textLines","splitLinesAuto","multiPaste","pasteLinesPerSelection","lineWise","changeEvent","triggerElectric","handlePaste","pasted","clipboardData","disableInput","electricChars","smartIndent","getModeAt","copyableRanges","lineRange","getRange","disableBrowserMagic","field","spellcheck","hiddenTextarea","te","div","ios","border","findPosH","findNextLine","moveOnce","boundToLine","origDir","sawType","getHelper","hitSide","findPosV","pageSize","moveAmount","posToDOM","isInGutter","scan","badPos","bad","domTextBetween","recognizeMarker","close","lineSep","addText","walk","cmText","textContent","markerID","isBlock","nodeName","nodeValue","domToPos","lineNode","locateNodeInLineView","textNode","topNode","curNode","previousSibling","dist$1","fromTextArea","textarea","getValue","tabindex","tabIndex","placeholder","realSubmit","form","leaveSubmitMethodAlone","submit","wrappedSubmit","getTextArea","toTextArea","getWrapperElement","userAgent","navigator","platform","ie_upto10","ie_11up","edge","documentMode","qtwebkit","vendor","mac_geMountainLion","windows","presto_version","endNode","setStart","createTextRange","moveToElementText","moveEnd","moveStart","selectInput","select","selectionStart","selectionEnd","_e","ms","sel_move","charType","lowTypes","arabicTypes","BidiSpan","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","outerType","type$1","prev$1","type$2","type$3","i$5","cur$1","type$4","i$6","end$1","replace$1","i$7","nstart","unshift","reverse","addEventListener","attachEvent","nl","rt","hasSelection","ownerDocument","parentElement","compareEndPoints","oncopy","lineOracle","lastColumnPos","lastColumnValue","skipTo","consume","caseInsensitive","cased","hideFirstChars","oracle","baseToken","maxLookAhead","NativeScrollbars","vert","horiz","checkedZeroWidth","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","w","pointerEvents","bar","delay","maybeDisable","elementFromPoint","NullScrollbars","native","here","there","removeInner","insertInner","iterN","oldHeight","remaining","leaf","maybeSpill","spilled","sibling","myIndex","used","oldH","withOp","dHeight","nextDocId","cleanGeneration","constructor","setValue","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","setCursor","extendSelectionsBy","setSelections","addSelection","getSelections","dup","replaceSelections","newSel","undo","redo","undoSelection","redoSelection","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","setGutterMarker","gutterID","clearGutter","lineInfo","addLineClass","where","removeLineClass","removeLineWidget","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","sepSize","indexFromPos","copyHistory","linkedDoc","unlinkDoc","link","splitIds","iterLinkedDocs","getEditor","setDirection","eachLine","3","8","9","13","16","17","18","19","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","93","106","107","109","110","111","127","173","186","187","188","189","190","191","192","219","220","221","222","63232","63233","63234","63235","63272","63273","63275","63276","63277","63302","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Alt-Backspace","Ctrl-K","Ctrl-T","Ctrl-O","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","delWrappedLineRight","rightPos","goDocStart","goDocEnd","goLineStart","goLineStartSmart","goLineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","moveV","goLineDown","goPageUp","goPageDown","goCharLeft","moveH","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","deleteH","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentSelection","indentMore","indentLess","insertTab","insertSoftTab","spaces","defaultTab","execCommand","transposeChars","newlineAndIndent","sels","openLine","toggleOverwrite","defineInitHook","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","polling","composing","gracePeriod","readDOMTimeout","onCopyCut","lineWiseCopyCut","clearData","kludge","hadFocus","showPrimarySelection","updateFromDOM","readFromDOMSoon","forceCompositionEnd","showMultipleSelections","curAnchor","curFocus","rng","rangeCount","getRangeAt","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","blur","poll","pollSelection","pollInterval","triggerOnKeyDown","pollContent","fromIndex","fromNode","toNode","toIndex","newText","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","contentEditable","readOnlyChanged","resetPosition","TextareaInput","prevInput","pollingFast","prepareCopyCut","fastPoll","moveInputWithCursor","headPos","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","slowPoll","missed","same","prepareSelectAllHack","extval","rehide","oldWrapperCSS","oldCSS","detectingSelectAll","resetSelectionOnContextMenu","wrapperBox","oldScrollY","scrollY","scrollTo","mouseup","disabled","deflt","notOnInit","defineOption","newBreaks","refresh","getInputField","detach","attach","setOption","getDoc","addKeyMap","removeKeyMap","addOverlay","modeSpec","removeOverlay","newRanges","getTokenAt","getLineTokens","getTokenTypeAt","getHelpers","help","_global","getStateAfter","defaultTextHeight","defaultCharWidth","getViewport","addWidget","vspace","hspace","triggerOnKeyPress","triggerOnKeyUp","triggerOnMouseDown","amount","rtlMoveVisually","goalColumn","goals","startChar","check","getScrollInfo","interpret","swapDoc","getScrollerElement","getGutterElement","registerGlobalHelper","predicate","dontDelegate","method","contenteditable","defineExtension","defineDocExtension","cmpPos","version","CjAo","sources","names","mappings","sourcesContent","sourceRoot","GypT","IXFo","IrVb","Lgoy","__WEBPACK_IMPORTED_MODULE_0__babel_loader_vue_loader_lib_selector_type_script_index_0_codemirror_vue__","__WEBPACK_IMPORTED_MODULE_1__vue_loader_lib_template_compiler_index_id_data_v_5c584404_hasScoped_false_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_vue_loader_lib_selector_type_template_index_0_codemirror_vue__","MsCo","__WEBPACK_AMD_DEFINE_RESULT__","root","error","RangeError","fn","mapDomain","regexSeparators","ucs2decode","extra","ucs2encode","stringFromCharCode","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","numPoints","firstTime","damp","baseMinusTMin","tMax","skew","oldi","t","baseMinusT","inputLength","initialN","initialBias","lastIndexOf","delimiter","maxInt","tMin","handledCPCount","basicLength","q","currentValue","handledCPCountPlusOne","qMinusT","toUnicode","regexPunycode","toASCII","regexNonASCII","freeGlobal","punycode","overflow","not-basic","invalid-input","ucs2","OlnX","af","af-ZA","ar","ar-AE","ar-BH","ar-DZ","ar-EG","ar-IQ","ar-JO","ar-KW","ar-LB","ar-LY","ar-MA","ar-OM","ar-QA","ar-SA","ar-SY","ar-TN","ar-YE","az","az-AZ","az-Cyrl-AZ","be","be-BY","bg","bg-BG","bs-BA","ca","ca-ES","cs","cs-CZ","cy","cy-GB","da","da-DK","de","de-AT","de-CH","de-DE","de-LI","de-LU","dv","dv-MV","el","el-GR","en","en-AU","en-BZ","en-CA","en-CB","en-GB","en-IE","en-JM","en-NZ","en-PH","en-TT","en-US","en-ZA","en-ZW","eo","es","es-AR","es-BO","es-CL","es-CO","es-CR","es-DO","es-EC","es-ES","es-GT","es-HN","es-MX","es-NI","es-PA","es-PE","es-PR","es-PY","es-SV","es-UY","es-VE","et","et-EE","eu","eu-ES","fa","fa-IR","fi","fi-FI","fo","fo-FO","fr","fr-BE","fr-CA","fr-CH","fr-FR","fr-LU","fr-MC","gl","gl-ES","gu","gu-IN","he","he-IL","hi","hi-IN","hr","hr-BA","hr-HR","hu","hu-HU","hy","hy-AM","id-ID","is","is-IS","it","it-CH","it-IT","ja","ja-JP","ka","ka-GE","kk","kk-KZ","kn","kn-IN","ko","ko-KR","kok","kok-IN","ky","ky-KG","lt","lt-LT","lv","lv-LV","mi","mi-NZ","mk-MK","mn","mn-MN","mr","mr-IN","ms-BN","ms-MY","mt","mt-MT","nb","nb-NO","nl-BE","nl-NL","nn-NO","ns","ns-ZA","pa","pa-IN","pl","pl-PL","ps","ps-AR","pt","pt-BR","pt-PT","qu","qu-BO","qu-EC","qu-PE","ro","ro-RO","ru","ru-RU","sa","sa-IN","se","se-FI","se-NO","se-SE","sk","sk-SK","sl","sl-SI","sq","sq-AL","sr-BA","sr-Cyrl-BA","sr-SP","sr-Cyrl-SP","sv","sv-FI","sv-SE","sw","sw-KE","syr","syr-SY","ta","ta-IN","te-IN","th-TH","tl","tl-PH","tn","tn-ZA","tr","tr-TR","tt","tt-RU","ts","uk","uk-UA","ur","ur-PK","uz","uz-UZ","uz-Cyrl-UZ","vi","vi-VN","xh","xh-ZA","zh","zh-CN","zh-HK","zh-MO","zh-SG","zh-TW","zu","zu-ZA","Qudd","render","_vm","_h","$createElement","_c","_self","staticClass","attrs","model","callback","$$v","staticRenderFns","esExports","R2wf","StWd","debounce","wait","immediate","timeout","_this","_len","_key","UZ5h","Url","protocol","slashes","auth","port","hostname","query","pathname","path","href","urlParse","url","parseQueryString","slashesDenoteHost","util","isObject","u","urlFormat","isString","format","urlResolve","relative","urlResolveObject","resolveObject","protocolPattern","portPattern","simplePathPattern","delims","unwise","autoEscape","nonHostChars","hostEndingChars","hostnamePartPattern","hostnamePartStart","unsafeProtocol","javascript","javascript:","hostlessProtocol","slashedProtocol","http","https","ftp","gopher","http:","https:","ftp:","gopher:","file:","querystring","TypeError","queryIndex","splitter","uSplit","slashRegex","trim","simplePath","proto","lowerProto","hostEnd","hec","atSign","decodeURIComponent","parseHost","ipv6Hostname","hostparts","newpart","validParts","notHost","bit","ae","esc","encodeURIComponent","escape","qm","tkeys","tk","tkey","rkeys","rk","rkey","relPath","isSourceAbs","isRelAbs","mustEndAbs","removeAllDots","srcPath","psychotic","isNullOrUndefined","authInHost","isNull","hasTrailingSlash","isAbsolute","V5hE","VDic","generateErrorMessage","__WEBPACK_IMPORTED_MODULE_0_vue_codemirror_lite__","message","removePrefix","stack","getLinePosition","char","lineIndex","findIndex","includes","matches","fromChar","prefix","__WEBPACK_IMPORTED_MODULE_1_jsonschema__","__WEBPACK_IMPORTED_MODULE_2__manifest_schema__","__WEBPACK_IMPORTED_MODULE_3_json_lint__","__WEBPACK_IMPORTED_MODULE_3_json_lint___default","character","_validator$validate","JSON","messages","YeLu","testSchema","valid","Function","testAdditionalProperty","addError","argument","makeChild","testArrays","description","exclusiveMinimum","exclusiveMaximum","$schema","some","nestedErrors","self","msg","minProperties","maxProperties","every","minimum","maximum","validateMultipleOfOrDivisbleBy","validationType","errorMessage","validationArgument","instanceDecimals","getDecimalPlaces","divisorDecimals","maxDecimals","multiplier","pow","multipleOf","divisibleBy","required","disableFormat","isFormat","minLength","maxLength","minItems","maxItems","uniqueItems","dep","childContext","notTypes","schemaId","ZbcI","glob","JSONLint","lower","comments","_evidence","revidence","endblock","commabreak","setEvidence","rnumber","rnewline","rwhitespace","rvalidsolidus","rE","contact","multicomment","comment","_endblock","_commabreak","ended","endval","numeric","negative","decimal","evidence","aSS6","d6Mc","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default","__WEBPACK_IMPORTED_MODULE_1__language_tags__","short_name","start_url","icons","lang","scope","orientation","serviceworker","theme_color","related_applications","prefer_related_applications","background_color","categories","screenshots","iarc_rating_id","gC+Y","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default","skipNextChangeEvent","ready","editor","$el","$emit","mounted","watch","newVal","oldVal","scrollInfo","newOptions","optionName","beforeDestroy","gZhU","CmComponent","console","log","install","Vue","component","k8+T","stringizer","deepMerger","dst","copyist","copyistWithDeepMerge","pathEncoder","throwError","err","validatorType","captureStackTrace","makeSuffix","FORMAT_REGEXPS","date-time","email","ip-address","ipv6","color","host-name","alpha","alphanumeric","utc-millisec","parseFloat","regex","phone","ipv4","aKeys","bKeys","encodePath","decimalPlaces","decimalParts","kMPS","qs","eq","maxKeys","kstr","vstr","idx","xs","mvHQ","__esModule","qOJP","arg","qkKv","core","$JSON","ryyk","showTooltip","opacity","hideTooltip","showTooltipFor","hide","tooltip","LintState","hasGutter","onMouseOver","waitingFor","parseOptions","_cm","getAnnotations","clearMarks","GUTTER_ID","makeMarker","labels","severity","multiple","tooltips","getMaxSeverity","groupByLine","annotations","ann","annotationTooltip","tip","messageHTML","innerHTML","lintAsync","passOptions","abort","arg2","updateLinting","startLinting","async","then","issues","annotationsNotSorted","anns","maxSeverity","tipLabel","formatAnnotation","__annotation","onUpdateLinting","onChange","popupTooltips","lintOnChange","hasLintGutter","xaZU","stringifyPrimitive","objectKeys","ks"],"mappings":"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","file":"static/js/0.2775868eef29d18b513f.js","sourcesContent":["webpackJsonp([0],{\n\n/***/ \"0CdP\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(\"mvHQ\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vue_types__ = __webpack_require__(\"E0CL\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_debounce__ = __webpack_require__(\"StWd\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vue_codemirror_lite__ = __webpack_require__(\"gZhU\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vue_codemirror_lite___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_vue_codemirror_lite__);\n\n//\n//\n//\n//\n//\n//\n\n\n\n\n__webpack_require__(\"VDic\");\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  components: {\n    codemirror: __WEBPACK_IMPORTED_MODULE_3_vue_codemirror_lite__[\"codemirror\"]\n  },\n  props: {\n    manifest: __WEBPACK_IMPORTED_MODULE_1_vue_types__[\"a\" /* default */].object.isRequired,\n    setManifest: __WEBPACK_IMPORTED_MODULE_1_vue_types__[\"a\" /* default */].func.isRequired\n  },\n  data: function data() {\n    return {\n      options: {\n        mode: {\n          name: 'javascript',\n          json: true\n        },\n        theme: 'eclipse',\n        lineNumbers: false,\n        tabSize: 2,\n        lint: true,\n        gutters: ['CodeMirror-lint-markers']\n      }\n    };\n  },\n\n  computed: {\n    code: {\n      get: function get() {\n        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(this.manifest, null, '\\t');\n      },\n\n      set: Object(__WEBPACK_IMPORTED_MODULE_2__lib_debounce__[\"a\" /* default */])(function (value) {\n        this.setManifest(value);\n      }, 250)\n    }\n  }\n});\n\n/***/ }),\n\n/***/ \"1nuA\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.decode = exports.parse = __webpack_require__(\"kMPS\");\nexports.encode = exports.stringify = __webpack_require__(\"xaZU\");\n\n\n/***/ }),\n\n/***/ \"1tE4\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar urilib = __webpack_require__(\"UZ5h\");\n\nvar attribute = __webpack_require__(\"YeLu\");\nvar helpers = __webpack_require__(\"k8+T\");\nvar ValidatorResult = helpers.ValidatorResult;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext;\n\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */\nvar Validator = function Validator () {\n  // Allow a validator instance to override global custom formats or to have their\n  // own custom formats.\n  this.customFormats = Object.create(Validator.prototype.customFormats);\n  this.schemas = {};\n  this.unresolvedRefs = [];\n\n  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n  this.types = Object.create(types);\n  this.attributes = Object.create(attribute.validators);\n};\n\n// Allow formats to be registered globally.\nValidator.prototype.customFormats = {};\n\n// Hint at the presence of a property\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */\nValidator.prototype.addSchema = function addSchema (schema, uri) {\n  if (!schema) {\n    return null;\n  }\n  var ourUri = uri || schema.id;\n  this.addSubSchema(ourUri, schema);\n  if (ourUri) {\n    this.schemas[ourUri] = schema;\n  }\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchema = function addSubSchema(baseuri, schema) {\n  if(!schema || typeof schema!='object') return;\n  // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined\n  if(schema.$ref){\n    var resolvedUri = urilib.resolve(baseuri, schema.$ref);\n    // Only mark unknown schemas as unresolved\n    if (this.schemas[resolvedUri] === undefined) {\n      this.schemas[resolvedUri] = null;\n      this.unresolvedRefs.push(resolvedUri);\n    }\n    return;\n  }\n  var ourUri = schema.id && urilib.resolve(baseuri, schema.id);\n  var ourBase = ourUri || baseuri;\n  if (ourUri) {\n    if(this.schemas[ourUri]){\n      if(!helpers.deepCompareStrict(this.schemas[ourUri], schema)){\n        throw new Error('Schema <'+schema+'> already exists with different definition');\n      }\n      return this.schemas[ourUri];\n    }\n    this.schemas[ourUri] = schema;\n    var documentUri = ourUri.replace(/^([^#]*)#$/, '$1');\n    this.schemas[documentUri] = schema;\n  }\n  this.addSubSchemaArray(ourBase, ((schema.items instanceof Array)?schema.items:[schema.items]));\n  this.addSubSchemaArray(ourBase, ((schema.extends instanceof Array)?schema.extends:[schema.extends]));\n  this.addSubSchema(ourBase, schema.additionalItems);\n  this.addSubSchemaObject(ourBase, schema.properties);\n  this.addSubSchema(ourBase, schema.additionalProperties);\n  this.addSubSchemaObject(ourBase, schema.definitions);\n  this.addSubSchemaObject(ourBase, schema.patternProperties);\n  this.addSubSchemaObject(ourBase, schema.dependencies);\n  this.addSubSchemaArray(ourBase, schema.disallow);\n  this.addSubSchemaArray(ourBase, schema.allOf);\n  this.addSubSchemaArray(ourBase, schema.anyOf);\n  this.addSubSchemaArray(ourBase, schema.oneOf);\n  this.addSubSchema(ourBase, schema.not);\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n  if(!(schemas instanceof Array)) return;\n  for(var i=0; i<schemas.length; i++){\n    this.addSubSchema(baseuri, schemas[i]);\n  }\n};\n\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n  if(!schemas || typeof schemas!='object') return;\n  for(var p in schemas){\n    this.addSubSchema(baseuri, schemas[p]);\n  }\n};\n\n\n\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */\nValidator.prototype.setSchemas = function setSchemas (schemas) {\n  this.schemas = schemas;\n};\n\n/**\n * Returns the schema of a certain urn\n * @param urn\n */\nValidator.prototype.getSchema = function getSchema (urn) {\n  return this.schemas[urn];\n};\n\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */\nValidator.prototype.validate = function validate (instance, schema, options, ctx) {\n  if (!options) {\n    options = {};\n  }\n  var propertyName = options.propertyName || 'instance';\n  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n  var base = urilib.resolve(options.base||'/', schema.id||'');\n  if(!ctx){\n    ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));\n    if (!ctx.schemas[base]) {\n      ctx.schemas[base] = schema;\n    }\n  }\n  if (schema) {\n    var result = this.validateSchema(instance, schema, options, ctx);\n    if (!result) {\n      throw new Error('Result undefined');\n    }\n    return result;\n  }\n  throw new SchemaError('no schema specified', schema);\n};\n\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/\nfunction shouldResolve(schema) {\n  var ref = (typeof schema === 'string') ? schema : schema.$ref;\n  if (typeof ref=='string') return ref;\n  return false;\n}\n\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */\nValidator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema) {\n    throw new Error(\"schema is undefined\");\n  }\n\n  if (schema['extends']) {\n    if (schema['extends'] instanceof Array) {\n      var schemaobj = {schema: schema, ctx: ctx};\n      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));\n      schema = schemaobj.schema;\n      schemaobj.schema = null;\n      schemaobj.ctx = null;\n      schemaobj = null;\n    } else {\n      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));\n    }\n  }\n\n  var switchSchema;\n  if (switchSchema = shouldResolve(schema)) {\n    var resolved = this.resolve(schema, switchSchema, ctx);\n    var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);\n    return this.validateSchema(instance, resolved.subschema, options, subctx);\n  }\n\n  var skipAttributes = options && options.skipAttributes || [];\n  // Validate each schema attribute against the instance\n  for (var key in schema) {\n    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n      var validatorErr = null;\n      var validator = this.attributes[key];\n      if (validator) {\n        validatorErr = validator.call(this, instance, schema, options, ctx);\n      } else if (options.allowUnknownAttributes === false) {\n        // This represents an error with the schema itself, not an invalid instance\n        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n      }\n      if (validatorErr) {\n        result.importErrors(validatorErr);\n      }\n    }\n  }\n\n  if (typeof options.rewrite == 'function') {\n    var value = options.rewrite.call(this, instance, schema, options, ctx);\n    result.instance = value;\n  }\n  return result;\n};\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.schemaTraverser = function schemaTraverser (schemaobj, s) {\n  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n}\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.superResolve = function superResolve (schema, ctx) {\n  var ref;\n  if(ref = shouldResolve(schema)) {\n    return this.resolve(schema, ref, ctx).subschema;\n  }\n  return schema;\n}\n\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/\nValidator.prototype.resolve = function resolve (schema, switchSchema, ctx) {\n  switchSchema = ctx.resolve(switchSchema);\n  // First see if the schema exists under the provided URI\n  if (ctx.schemas[switchSchema]) {\n    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};\n  }\n  // Else try walking the property pointer\n  var parsed = urilib.parse(switchSchema);\n  var fragment = parsed && parsed.hash;\n  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n  if (!document || !ctx.schemas[document]) {\n    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n  }\n  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n  if(subschema===undefined){\n    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n  }\n  return {subschema: subschema, switchSchema: switchSchema};\n};\n\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */\nValidator.prototype.testType = function validateType (instance, schema, options, ctx, type) {\n  if (typeof this.types[type] == 'function') {\n    return this.types[type].call(this, instance);\n  }\n  if (type && typeof type == 'object') {\n    var res = this.validateSchema(instance, type, options, ctx);\n    return res === undefined || !(res && res.errors.length);\n  }\n  // Undefined or properties not on the list are acceptable, same as not being defined\n  return true;\n};\n\nvar types = Validator.prototype.types = {};\ntypes.string = function testString (instance) {\n  return typeof instance == 'string';\n};\ntypes.number = function testNumber (instance) {\n  // isFinite returns false for NaN, Infinity, and -Infinity\n  return typeof instance == 'number' && isFinite(instance);\n};\ntypes.integer = function testInteger (instance) {\n  return (typeof instance == 'number') && instance % 1 === 0;\n};\ntypes.boolean = function testBoolean (instance) {\n  return typeof instance == 'boolean';\n};\ntypes.array = function testArray (instance) {\n  return Array.isArray(instance);\n};\ntypes['null'] = function testNull (instance) {\n  return instance === null;\n};\ntypes.date = function testDate (instance) {\n  return instance instanceof Date;\n};\ntypes.any = function testAny (instance) {\n  return true;\n};\ntypes.object = function testObject (instance) {\n  // TODO: fix this - see #15\n  return instance && (typeof instance) === 'object' && !(instance instanceof Array) && !(instance instanceof Date);\n};\n\nmodule.exports = Validator;\n\n\n/***/ }),\n\n/***/ \"3IRH\":\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\n\tif(!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif(!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n/***/ }),\n\n/***/ \"4/hK\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"IXFo\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"5e9a0932\", content, true);\n\n/***/ }),\n\n/***/ \"41tG\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_manifest_editor_vue__ = __webpack_require__(\"0CdP\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_66e75edd_hasScoped_false_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_manifest_editor_vue__ = __webpack_require__(\"Qudd\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"GypT\")\n}\nvar normalizeComponent = __webpack_require__(\"VU/8\")\n/* script */\n\n/* template */\n\n/* template functional */\n  var __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_manifest_editor_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_66e75edd_hasScoped_false_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_manifest_editor_vue__[\"a\" /* default */],\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"5IAE\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    var jsKeywords = {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: \"variable\", style: \"type\"};\n      var tsKeywords = {\n        // object-like things\n        \"interface\": kw(\"class\"),\n        \"implements\": C,\n        \"namespace\": C,\n        \"module\": kw(\"module\"),\n        \"enum\": kw(\"module\"),\n\n        // scope modifiers\n        \"public\": kw(\"modifier\"),\n        \"private\": kw(\"modifier\"),\n        \"protected\": kw(\"modifier\"),\n        \"abstract\": kw(\"modifier\"),\n        \"readonly\": kw(\"modifier\"),\n\n        // types\n        \"string\": type, \"number\": type, \"boolean\": type, \"any\": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"0\" && stream.eat(/o/i)) {\n      stream.eatWhile(/[0-7]/i);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"0\" && stream.eat(/b/i)) {\n      stream.eatWhile(/[01]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyu])(?![gimyu]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^\\s*[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/]/.test(ch)) {\n        return;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (state.context) {\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      if (parserConfig.globalVars)\n        state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value.length), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"variable\") {\n      if (isTS && value == \"type\") {\n        cx.marked = \"keyword\"\n        return cont(typeexpr, expect(\"operator\"), typeexpr, expect(\";\"));\n      } if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"class\") return cont(pushlex(\"form\"), className, poplex);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"module\") return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), expression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\") return cont(pushlex(\"form\"), classExpression, poplex);\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (type == \"modifier\") {\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function typeexpr(type, value) {\n    if (type == \"variable\" || value == \"void\") {\n      if (value == \"keyof\") {\n        cx.marked = \"keyword\"\n        return cont(typeexpr)\n      } else {\n        cx.marked = \"type\"\n        return cont(afterType)\n      }\n    }\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\", \",;\"), poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType)\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), typeprop)\n    }\n  }\n  function typearg(type) {\n    if (type == \"variable\") return cont(typearg)\n    else if (type == \":\") return cont(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\") return cont(typeexpr)\n    if (type == \"[\") return cont(expect(\"]\"), afterType)\n    if (value == \"extends\") return cont(typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function vardef() {\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (type == \"modifier\") return cont(pattern)\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(pattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type) {\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\n    if (type == \";\") return cont(forspec2);\n    if (type == \"variable\") return cont(formaybeinof);\n    return pass(expression, expect(\";\"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return pass(expression, expect(\";\"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, maybetype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, functiondef)\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\" || type == \"modifier\") return cont(funarg);\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\"))\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"modifier\" || type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\") &&\n         cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(isTS ? classfield : functiondef, classBody);\n    }\n    if (type == \"[\")\n      return cont(expression, expect(\"]\"), isTS ? classfield : functiondef, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \";\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    return pass(functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      var top = state.cc[state.cc.length - 1]\n      if (top == expression || top == expressionNoComma) state.cc.pop()\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n\n\n/***/ }),\n\n/***/ \"7HRn\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Validator = module.exports.Validator = __webpack_require__(\"1tE4\");\n\nmodule.exports.ValidatorResult = __webpack_require__(\"k8+T\").ValidatorResult;\nmodule.exports.ValidationError = __webpack_require__(\"k8+T\").ValidationError;\nmodule.exports.SchemaError = __webpack_require__(\"k8+T\").SchemaError;\n\nmodule.exports.validate = function (instance, schema, options) {\n  var v = new Validator();\n  return v.validate(instance, schema, options);\n};\n\n\n/***/ }),\n\n/***/ \"7xRv\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"V5hE\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"bc5e0228\", content, true);\n\n/***/ }),\n\n/***/ \"8U58\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n// Kludges for bugs and behavior differences that can't be feature\n// detected are enabled based on userAgent etc sniffing.\nvar userAgent = navigator.userAgent;\nvar platform = navigator.platform;\n\nvar gecko = /gecko\\/\\d/i.test(userAgent);\nvar ie_upto10 = /MSIE \\d/.test(userAgent);\nvar ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\nvar edge = /Edge\\/(\\d+)/.exec(userAgent);\nvar ie = ie_upto10 || ie_11up || edge;\nvar ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\nvar webkit = !edge && /WebKit\\//.test(userAgent);\nvar qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\nvar chrome = !edge && /Chrome\\//.test(userAgent);\nvar presto = /Opera\\//.test(userAgent);\nvar safari = /Apple Computer/.test(navigator.vendor);\nvar mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\nvar phantom = /PhantomJS/.test(userAgent);\n\nvar ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\nvar android = /Android/.test(userAgent);\n// This is woefully incomplete. Suggestions for alternative methods welcome.\nvar mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\nvar mac = ios || /Mac/.test(platform);\nvar chromeOS = /\\bCrOS\\b/.test(userAgent);\nvar windows = /win/i.test(platform);\n\nvar presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\nif (presto_version) { presto_version = Number(presto_version[1]); }\nif (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n// Some browsers use the wrong event properties to signal cmd/ctrl on OS X\nvar flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\nvar captureRightClick = gecko || (ie && ie_version >= 9);\n\nfunction classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\nvar rmClass = function(node, cls) {\n  var current = node.className;\n  var match = classTest(cls).exec(current);\n  if (match) {\n    var after = current.slice(match.index + match[0].length);\n    node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n  }\n};\n\nfunction removeChildren(e) {\n  for (var count = e.childNodes.length; count > 0; --count)\n    { e.removeChild(e.firstChild); }\n  return e\n}\n\nfunction removeChildrenAndAdd(parent, e) {\n  return removeChildren(parent).appendChild(e)\n}\n\nfunction elt(tag, content, className, style) {\n  var e = document.createElement(tag);\n  if (className) { e.className = className; }\n  if (style) { e.style.cssText = style; }\n  if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n  return e\n}\n// wrapper for elt, which removes the elt from the accessibility tree\nfunction eltP(tag, content, className, style) {\n  var e = elt(tag, content, className, style);\n  e.setAttribute(\"role\", \"presentation\");\n  return e\n}\n\nvar range;\nif (document.createRange) { range = function(node, start, end, endNode) {\n  var r = document.createRange();\n  r.setEnd(endNode || node, end);\n  r.setStart(node, start);\n  return r\n}; }\nelse { range = function(node, start, end) {\n  var r = document.body.createTextRange();\n  try { r.moveToElementText(node.parentNode); }\n  catch(e) { return r }\n  r.collapse(true);\n  r.moveEnd(\"character\", end);\n  r.moveStart(\"character\", start);\n  return r\n}; }\n\nfunction contains(parent, child) {\n  if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n    { child = child.parentNode; }\n  if (parent.contains)\n    { return parent.contains(child) }\n  do {\n    if (child.nodeType == 11) { child = child.host; }\n    if (child == parent) { return true }\n  } while (child = child.parentNode)\n}\n\nfunction activeElt() {\n  // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n  // IE < 10 will throw when accessed while the page is loading or in an iframe.\n  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n  var activeElement;\n  try {\n    activeElement = document.activeElement;\n  } catch(e) {\n    activeElement = document.body || null;\n  }\n  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n    { activeElement = activeElement.shadowRoot.activeElement; }\n  return activeElement\n}\n\nfunction addClass(node, cls) {\n  var current = node.className;\n  if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n}\nfunction joinClasses(a, b) {\n  var as = a.split(\" \");\n  for (var i = 0; i < as.length; i++)\n    { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n  return b\n}\n\nvar selectInput = function(node) { node.select(); };\nif (ios) // Mobile Safari apparently has a bug where select() is broken.\n  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\nelse if (ie) // Suppress mysterious IE10 errors\n  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\nfunction bind(f) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function(){return f.apply(null, args)}\n}\n\nfunction copyObj(obj, target, overwrite) {\n  if (!target) { target = {}; }\n  for (var prop in obj)\n    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n      { target[prop] = obj[prop]; } }\n  return target\n}\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countColumn(string, end, tabSize, startIndex, startValue) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) { end = string.length; }\n  }\n  for (var i = startIndex || 0, n = startValue || 0;;) {\n    var nextTab = string.indexOf(\"\\t\", i);\n    if (nextTab < 0 || nextTab >= end)\n      { return n + (end - i) }\n    n += nextTab - i;\n    n += tabSize - (n % tabSize);\n    i = nextTab + 1;\n  }\n}\n\nvar Delayed = function() {this.id = null;};\nDelayed.prototype.set = function (ms, f) {\n  clearTimeout(this.id);\n  this.id = setTimeout(f, ms);\n};\n\nfunction indexOf(array, elt) {\n  for (var i = 0; i < array.length; ++i)\n    { if (array[i] == elt) { return i } }\n  return -1\n}\n\n// Number of pixels added to scroller and sizer to hide scrollbar\nvar scrollerGap = 30;\n\n// Returned or thrown by various protocols to signal 'I'm not\n// handling this'.\nvar Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n// Reused option objects for setSelection & friends\nvar sel_dontScroll = {scroll: false};\nvar sel_mouse = {origin: \"*mouse\"};\nvar sel_move = {origin: \"+move\"};\n\n// The inverse of countColumn -- find the offset that corresponds to\n// a particular column.\nfunction findColumn(string, goal, tabSize) {\n  for (var pos = 0, col = 0;;) {\n    var nextTab = string.indexOf(\"\\t\", pos);\n    if (nextTab == -1) { nextTab = string.length; }\n    var skipped = nextTab - pos;\n    if (nextTab == string.length || col + skipped >= goal)\n      { return pos + Math.min(skipped, goal - col) }\n    col += nextTab - pos;\n    col += tabSize - (col % tabSize);\n    pos = nextTab + 1;\n    if (col >= goal) { return pos }\n  }\n}\n\nvar spaceStrs = [\"\"];\nfunction spaceStr(n) {\n  while (spaceStrs.length <= n)\n    { spaceStrs.push(lst(spaceStrs) + \" \"); }\n  return spaceStrs[n]\n}\n\nfunction lst(arr) { return arr[arr.length-1] }\n\nfunction map(array, f) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n  return out\n}\n\nfunction insertSorted(array, value, score) {\n  var pos = 0, priority = score(value);\n  while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n  array.splice(pos, 0, value);\n}\n\nfunction nothing() {}\n\nfunction createObj(base, props) {\n  var inst;\n  if (Object.create) {\n    inst = Object.create(base);\n  } else {\n    nothing.prototype = base;\n    inst = new nothing();\n  }\n  if (props) { copyObj(props, inst); }\n  return inst\n}\n\nvar nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nfunction isWordCharBasic(ch) {\n  return /\\w/.test(ch) || ch > \"\\x80\" &&\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n}\nfunction isWordChar(ch, helper) {\n  if (!helper) { return isWordCharBasic(ch) }\n  if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n  return helper.test(ch)\n}\n\nfunction isEmpty(obj) {\n  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n  return true\n}\n\n// Extending unicode characters. A series of a non-extending char +\n// any number of extending chars is treated as a single unit as far\n// as editing and measuring is concerned. This is not fully correct,\n// since some scripts/fonts/browsers also treat other configurations\n// of code points as a group.\nvar extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\nfunction isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\nfunction skipExtendingChars(str, pos, dir) {\n  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n  return pos\n}\n\n// Returns the value from the range [`from`; `to`] that satisfies\n// `pred` and is closest to `from`. Assumes that at least `to`\n// satisfies `pred`. Supports `from` being greater than `to`.\nfunction findFirst(pred, from, to) {\n  // At any point we are certain `to` satisfies `pred`, don't know\n  // whether `from` does.\n  var dir = from > to ? -1 : 1;\n  for (;;) {\n    if (from == to) { return from }\n    var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n    if (mid == from) { return pred(mid) ? from : to }\n    if (pred(mid)) { to = mid; }\n    else { from = mid + dir; }\n  }\n}\n\n// The display handles the DOM integration, both for input reading\n// and content drawing. It holds references to DOM nodes and\n// display-related state.\n\nfunction Display(place, doc, input) {\n  var d = this;\n  this.input = input;\n\n  // Covers bottom-right square when both scrollbars are present.\n  d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n  d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Covers bottom of gutter when coverGutterNextToScrollbar is on\n  // and h scrollbar is present.\n  d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n  d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Will contain the actual code, positioned to cover the viewport.\n  d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n  // Elements are added to these to represent selection and cursors.\n  d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n  d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n  // A visibility: hidden element used to find the size of things.\n  d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n  // When lines outside of the viewport are measured, they are drawn in this.\n  d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n  // Wraps everything that needs to exist inside the vertically-padded coordinate system\n  d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                    null, \"position: relative; outline: none\");\n  var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n  // Moved around its parent to cover visible view.\n  d.mover = elt(\"div\", [lines], null, \"position: relative\");\n  // Set to the height of the document, allowing scrolling.\n  d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n  d.sizerWidth = null;\n  // Behavior of elts with overflow: auto and padding is\n  // inconsistent across browsers. This is used to ensure the\n  // scrollable area is big enough.\n  d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n  // Will contain the gutters, if any.\n  d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n  d.lineGutter = null;\n  // Actual scrollable element.\n  d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n  d.scroller.setAttribute(\"tabIndex\", \"-1\");\n  // The element in which the editor lives.\n  d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n  if (place) {\n    if (place.appendChild) { place.appendChild(d.wrapper); }\n    else { place(d.wrapper); }\n  }\n\n  // Current rendered range (may be bigger than the view window).\n  d.viewFrom = d.viewTo = doc.first;\n  d.reportedViewFrom = d.reportedViewTo = doc.first;\n  // Information about the rendered lines.\n  d.view = [];\n  d.renderedView = null;\n  // Holds info about a single rendered line when it was rendered\n  // for measurement, while not in view.\n  d.externalMeasured = null;\n  // Empty space (in pixels) above the view\n  d.viewOffset = 0;\n  d.lastWrapHeight = d.lastWrapWidth = 0;\n  d.updateLineNumbers = null;\n\n  d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n  d.scrollbarsClipped = false;\n\n  // Used to only resize the line number gutter when necessary (when\n  // the amount of lines crosses a boundary that makes its width change)\n  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n  // Set to true when a non-horizontal-scrolling line widget is\n  // added. As an optimization, line widget aligning is skipped when\n  // this is false.\n  d.alignWidgets = false;\n\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n  // Tracks the maximum line length so that the horizontal scrollbar\n  // can be kept static when scrolling.\n  d.maxLine = null;\n  d.maxLineLength = 0;\n  d.maxLineChanged = false;\n\n  // Used for measuring wheel scrolling granularity\n  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n  // True when shift is held down.\n  d.shift = false;\n\n  // Used to track whether anything happened since the context menu\n  // was opened.\n  d.selForContextMenu = null;\n\n  d.activeTouch = null;\n\n  input.init(d);\n}\n\n// Find the line object corresponding to the given line number.\nfunction getLine(doc, n) {\n  n -= doc.first;\n  if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n  var chunk = doc;\n  while (!chunk.lines) {\n    for (var i = 0;; ++i) {\n      var child = chunk.children[i], sz = child.chunkSize();\n      if (n < sz) { chunk = child; break }\n      n -= sz;\n    }\n  }\n  return chunk.lines[n]\n}\n\n// Get the part of a document between two positions, as an array of\n// strings.\nfunction getBetween(doc, start, end) {\n  var out = [], n = start.line;\n  doc.iter(start.line, end.line + 1, function (line) {\n    var text = line.text;\n    if (n == end.line) { text = text.slice(0, end.ch); }\n    if (n == start.line) { text = text.slice(start.ch); }\n    out.push(text);\n    ++n;\n  });\n  return out\n}\n// Get the lines between from and to, as array of strings.\nfunction getLines(doc, from, to) {\n  var out = [];\n  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n  return out\n}\n\n// Update the height of a line, propagating the height change\n// upwards to parent nodes.\nfunction updateLineHeight(line, height) {\n  var diff = height - line.height;\n  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n}\n\n// Given a line object, find its line number by walking up through\n// its parent links.\nfunction lineNo(line) {\n  if (line.parent == null) { return null }\n  var cur = line.parent, no = indexOf(cur.lines, line);\n  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n    for (var i = 0;; ++i) {\n      if (chunk.children[i] == cur) { break }\n      no += chunk.children[i].chunkSize();\n    }\n  }\n  return no + cur.first\n}\n\n// Find the line at the given vertical position, using the height\n// information in the document tree.\nfunction lineAtHeight(chunk, h) {\n  var n = chunk.first;\n  outer: do {\n    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n      var child = chunk.children[i$1], ch = child.height;\n      if (h < ch) { chunk = child; continue outer }\n      h -= ch;\n      n += child.chunkSize();\n    }\n    return n\n  } while (!chunk.lines)\n  var i = 0;\n  for (; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i], lh = line.height;\n    if (h < lh) { break }\n    h -= lh;\n  }\n  return n + i\n}\n\nfunction isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\nfunction lineNumberFor(options, i) {\n  return String(options.lineNumberFormatter(i + options.firstLineNumber))\n}\n\n// A Pos instance represents a position within the text.\nfunction Pos(line, ch, sticky) {\n  if ( sticky === void 0 ) sticky = null;\n\n  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n  this.line = line;\n  this.ch = ch;\n  this.sticky = sticky;\n}\n\n// Compare two positions, return 0 if they are the same, a negative\n// number when a is less, and a positive number otherwise.\nfunction cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\nfunction equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\nfunction copyPos(x) {return Pos(x.line, x.ch)}\nfunction maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\nfunction minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n// Most of the external API clips given positions to make sure they\n// actually exist within the document.\nfunction clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\nfunction clipPos(doc, pos) {\n  if (pos.line < doc.first) { return Pos(doc.first, 0) }\n  var last = doc.first + doc.size - 1;\n  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n  return clipToLen(pos, getLine(doc, pos.line).text.length)\n}\nfunction clipToLen(pos, linelen) {\n  var ch = pos.ch;\n  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n  else if (ch < 0) { return Pos(pos.line, 0) }\n  else { return pos }\n}\nfunction clipPosArray(doc, array) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n  return out\n}\n\n// Optimize some code when these features are not used.\nvar sawReadOnlySpans = false;\nvar sawCollapsedSpans = false;\n\nfunction seeReadOnlySpans() {\n  sawReadOnlySpans = true;\n}\n\nfunction seeCollapsedSpans() {\n  sawCollapsedSpans = true;\n}\n\n// TEXTMARKER SPANS\n\nfunction MarkedSpan(marker, from, to) {\n  this.marker = marker;\n  this.from = from; this.to = to;\n}\n\n// Search an array of spans for a span matching the given marker.\nfunction getMarkedSpanFor(spans, marker) {\n  if (spans) { for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.marker == marker) { return span }\n  } }\n}\n// Remove a span from an array, returning undefined if no spans are\n// left (we don't store arrays for lines without spans).\nfunction removeMarkedSpan(spans, span) {\n  var r;\n  for (var i = 0; i < spans.length; ++i)\n    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n  return r\n}\n// Add a span to a line.\nfunction addMarkedSpan(line, span) {\n  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n  span.marker.attachLine(line);\n}\n\n// Used for the algorithm that adjusts markers for a change in the\n// document. These functions cut an array of spans at a given\n// character position, returning an array of remaining chunks (or\n// undefined if nothing remains).\nfunction markedSpansBefore(old, startCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n    if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n    }\n  } }\n  return nw\n}\nfunction markedSpansAfter(old, endCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n    if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                            span.to == null ? null : span.to - endCh));\n    }\n  } }\n  return nw\n}\n\n// Given a change object, compute the new set of marker spans that\n// cover the line in which the change took place. Removes spans\n// entirely within the change, reconnects spans belonging to the\n// same marker that appear on both sides of the change, and cuts off\n// spans partially within the change. Returns an array of span\n// arrays with one element for each line in (after) the change.\nfunction stretchSpansOverChange(doc, change) {\n  if (change.full) { return null }\n  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n  if (!oldFirst && !oldLast) { return null }\n\n  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n  // Get the spans that 'stick out' on both sides\n  var first = markedSpansBefore(oldFirst, startCh, isInsert);\n  var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n  // Next, merge those two ends\n  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n  if (first) {\n    // Fix up .to properties of first\n    for (var i = 0; i < first.length; ++i) {\n      var span = first[i];\n      if (span.to == null) {\n        var found = getMarkedSpanFor(last, span.marker);\n        if (!found) { span.to = startCh; }\n        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n      }\n    }\n  }\n  if (last) {\n    // Fix up .from in last (or move them into first in case of sameLine)\n    for (var i$1 = 0; i$1 < last.length; ++i$1) {\n      var span$1 = last[i$1];\n      if (span$1.to != null) { span$1.to += offset; }\n      if (span$1.from == null) {\n        var found$1 = getMarkedSpanFor(first, span$1.marker);\n        if (!found$1) {\n          span$1.from = offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      } else {\n        span$1.from += offset;\n        if (sameLine) { (first || (first = [])).push(span$1); }\n      }\n    }\n  }\n  // Make sure we didn't create any zero-length spans\n  if (first) { first = clearEmptySpans(first); }\n  if (last && last != first) { last = clearEmptySpans(last); }\n\n  var newMarkers = [first];\n  if (!sameLine) {\n    // Fill gap with whole-line-spans\n    var gap = change.text.length - 2, gapMarkers;\n    if (gap > 0 && first)\n      { for (var i$2 = 0; i$2 < first.length; ++i$2)\n        { if (first[i$2].to == null)\n          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n    for (var i$3 = 0; i$3 < gap; ++i$3)\n      { newMarkers.push(gapMarkers); }\n    newMarkers.push(last);\n  }\n  return newMarkers\n}\n\n// Remove spans that are empty and don't have a clearWhenEmpty\n// option of false.\nfunction clearEmptySpans(spans) {\n  for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n      { spans.splice(i--, 1); }\n  }\n  if (!spans.length) { return null }\n  return spans\n}\n\n// Used to 'clip' out readOnly ranges when making a change.\nfunction removeReadOnlyRanges(doc, from, to) {\n  var markers = null;\n  doc.iter(from.line, to.line + 1, function (line) {\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var mark = line.markedSpans[i].marker;\n      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n        { (markers || (markers = [])).push(mark); }\n    } }\n  });\n  if (!markers) { return null }\n  var parts = [{from: from, to: to}];\n  for (var i = 0; i < markers.length; ++i) {\n    var mk = markers[i], m = mk.find(0);\n    for (var j = 0; j < parts.length; ++j) {\n      var p = parts[j];\n      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n        { newParts.push({from: p.from, to: m.from}); }\n      if (dto > 0 || !mk.inclusiveRight && !dto)\n        { newParts.push({from: m.to, to: p.to}); }\n      parts.splice.apply(parts, newParts);\n      j += newParts.length - 3;\n    }\n  }\n  return parts\n}\n\n// Connect or disconnect spans from a line.\nfunction detachMarkedSpans(line) {\n  var spans = line.markedSpans;\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.detachLine(line); }\n  line.markedSpans = null;\n}\nfunction attachMarkedSpans(line, spans) {\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.attachLine(line); }\n  line.markedSpans = spans;\n}\n\n// Helpers used when computing which overlapping collapsed span\n// counts as the larger one.\nfunction extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\nfunction extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n// Returns a number indicating which of two overlapping collapsed\n// spans is larger (and thus includes the other). Falls back to\n// comparing ids when the spans cover exactly the same range.\nfunction compareCollapsedMarkers(a, b) {\n  var lenDiff = a.lines.length - b.lines.length;\n  if (lenDiff != 0) { return lenDiff }\n  var aPos = a.find(), bPos = b.find();\n  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n  if (fromCmp) { return -fromCmp }\n  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n  if (toCmp) { return toCmp }\n  return b.id - a.id\n}\n\n// Find out whether a line ends or starts in a collapsed span. If\n// so, return the marker for that span.\nfunction collapsedSpanAtSide(line, start) {\n  var sps = sawCollapsedSpans && line.markedSpans, found;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n        (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n      { found = sp.marker; }\n  } }\n  return found\n}\nfunction collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\nfunction collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n// Test whether there exists a collapsed span that partially\n// overlaps (covers the start or end, but not both) of a new span.\n// Such overlap is not allowed.\nfunction conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\n  var line = getLine(doc, lineNo$$1);\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var i = 0; i < sps.length; ++i) {\n    var sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    var found = sp.marker.find(0);\n    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n      { return true }\n  } }\n}\n\n// A visual line is a line as drawn on the screen. Folding, for\n// example, can cause multiple logical lines to appear on the same\n// visual line. This finds the start of the visual line that the\n// given line is part of (usually that is the line itself).\nfunction visualLine(line) {\n  var merged;\n  while (merged = collapsedSpanAtStart(line))\n    { line = merged.find(-1, true).line; }\n  return line\n}\n\nfunction visualLineEnd(line) {\n  var merged;\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return line\n}\n\n// Returns an array of logical lines that continue the visual line\n// started by the argument, or undefined if there are no such lines.\nfunction visualLineContinued(line) {\n  var merged, lines;\n  while (merged = collapsedSpanAtEnd(line)) {\n    line = merged.find(1, true).line\n    ;(lines || (lines = [])).push(line);\n  }\n  return lines\n}\n\n// Get the line number of the start of the visual line that the\n// given line number is part of.\nfunction visualLineNo(doc, lineN) {\n  var line = getLine(doc, lineN), vis = visualLine(line);\n  if (line == vis) { return lineN }\n  return lineNo(vis)\n}\n\n// Get the line number of the start of the next visual line after\n// the given line.\nfunction visualLineEndNo(doc, lineN) {\n  if (lineN > doc.lastLine()) { return lineN }\n  var line = getLine(doc, lineN), merged;\n  if (!lineIsHidden(doc, line)) { return lineN }\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return lineNo(line) + 1\n}\n\n// Compute whether a line is hidden. Lines count as hidden when they\n// are part of a visual line that starts with another line, or when\n// they are entirely covered by collapsed, non-widget span.\nfunction lineIsHidden(doc, line) {\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    if (sp.from == null) { return true }\n    if (sp.marker.widgetNode) { continue }\n    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n      { return true }\n  } }\n}\nfunction lineIsHiddenInner(doc, line, span) {\n  if (span.to == null) {\n    var end = span.marker.find(1, true);\n    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n  }\n  if (span.marker.inclusiveRight && span.to == line.text.length)\n    { return true }\n  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n    sp = line.markedSpans[i];\n    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n        (sp.to == null || sp.to != span.from) &&\n        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n        lineIsHiddenInner(doc, line, sp)) { return true }\n  }\n}\n\n// Find the height above the given line.\nfunction heightAtLine(lineObj) {\n  lineObj = visualLine(lineObj);\n\n  var h = 0, chunk = lineObj.parent;\n  for (var i = 0; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i];\n    if (line == lineObj) { break }\n    else { h += line.height; }\n  }\n  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n      var cur = p.children[i$1];\n      if (cur == chunk) { break }\n      else { h += cur.height; }\n    }\n  }\n  return h\n}\n\n// Compute the character length of a line, taking into account\n// collapsed ranges (see markText) that might hide parts, and join\n// other lines onto it.\nfunction lineLength(line) {\n  if (line.height == 0) { return 0 }\n  var len = line.text.length, merged, cur = line;\n  while (merged = collapsedSpanAtStart(cur)) {\n    var found = merged.find(0, true);\n    cur = found.from.line;\n    len += found.from.ch - found.to.ch;\n  }\n  cur = line;\n  while (merged = collapsedSpanAtEnd(cur)) {\n    var found$1 = merged.find(0, true);\n    len -= cur.text.length - found$1.from.ch;\n    cur = found$1.to.line;\n    len += cur.text.length - found$1.to.ch;\n  }\n  return len\n}\n\n// Find the longest line in the document.\nfunction findMaxLine(cm) {\n  var d = cm.display, doc = cm.doc;\n  d.maxLine = getLine(doc, doc.first);\n  d.maxLineLength = lineLength(d.maxLine);\n  d.maxLineChanged = true;\n  doc.iter(function (line) {\n    var len = lineLength(line);\n    if (len > d.maxLineLength) {\n      d.maxLineLength = len;\n      d.maxLine = line;\n    }\n  });\n}\n\n// BIDI HELPERS\n\nfunction iterateBidiSections(order, from, to, f) {\n  if (!order) { return f(from, to, \"ltr\", 0) }\n  var found = false;\n  for (var i = 0; i < order.length; ++i) {\n    var part = order[i];\n    if (part.from < to && part.to > from || from == to && part.to == from) {\n      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n      found = true;\n    }\n  }\n  if (!found) { f(from, to, \"ltr\"); }\n}\n\nvar bidiOther = null;\nfunction getBidiPartAt(order, ch, sticky) {\n  var found;\n  bidiOther = null;\n  for (var i = 0; i < order.length; ++i) {\n    var cur = order[i];\n    if (cur.from < ch && cur.to > ch) { return i }\n    if (cur.to == ch) {\n      if (cur.from != cur.to && sticky == \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n    if (cur.from == ch) {\n      if (cur.from != cur.to && sticky != \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n  }\n  return found != null ? found : bidiOther\n}\n\n// Bidirectional ordering algorithm\n// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n// that this (partially) implements.\n\n// One-char codes used for character types:\n// L (L):   Left-to-Right\n// R (R):   Right-to-Left\n// r (AL):  Right-to-Left Arabic\n// 1 (EN):  European Number\n// + (ES):  European Number Separator\n// % (ET):  European Number Terminator\n// n (AN):  Arabic Number\n// , (CS):  Common Number Separator\n// m (NSM): Non-Spacing Mark\n// b (BN):  Boundary Neutral\n// s (B):   Paragraph Separator\n// t (S):   Segment Separator\n// w (WS):  Whitespace\n// N (ON):  Other Neutrals\n\n// Returns null if characters are ordered as they appear\n// (left-to-right), or an array of sections ({from, to, level}\n// objects) in the order in which they occur visually.\nvar bidiOrdering = (function() {\n  // Character types for codepoints 0 to 0xff\n  var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n  // Character types for codepoints 0x600 to 0x6f9\n  var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n  function charType(code) {\n    if (code <= 0xf7) { return lowTypes.charAt(code) }\n    else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n    else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n    else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n    else if (code == 0x200c) { return \"b\" }\n    else { return \"L\" }\n  }\n\n  var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n  function BidiSpan(level, from, to) {\n    this.level = level;\n    this.from = from; this.to = to;\n  }\n\n  return function(str, direction) {\n    var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n    if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n    var len = str.length, types = [];\n    for (var i = 0; i < len; ++i)\n      { types.push(charType(str.charCodeAt(i))); }\n\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\n    // change the type of the NSM to the type of the previous\n    // character. If the NSM is at the start of the level run, it will\n    // get the type of sor.\n    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n      var type = types[i$1];\n      if (type == \"m\") { types[i$1] = prev; }\n      else { prev = type; }\n    }\n\n    // W2. Search backwards from each instance of a European number\n    // until the first strong type (R, L, AL, or sor) is found. If an\n    // AL is found, change the type of the European number to Arabic\n    // number.\n    // W3. Change all ALs to R.\n    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n      var type$1 = types[i$2];\n      if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n    }\n\n    // W4. A single European separator between two European numbers\n    // changes to a European number. A single common separator between\n    // two numbers of the same type changes to that type.\n    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n      var type$2 = types[i$3];\n      if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n      else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n               (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n      prev$1 = type$2;\n    }\n\n    // W5. A sequence of European terminators adjacent to European\n    // numbers changes to all European numbers.\n    // W6. Otherwise, separators and terminators change to Other\n    // Neutral.\n    for (var i$4 = 0; i$4 < len; ++i$4) {\n      var type$3 = types[i$4];\n      if (type$3 == \",\") { types[i$4] = \"N\"; }\n      else if (type$3 == \"%\") {\n        var end = (void 0);\n        for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n        var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n        for (var j = i$4; j < end; ++j) { types[j] = replace; }\n        i$4 = end - 1;\n      }\n    }\n\n    // W7. Search backwards from each instance of a European number\n    // until the first strong type (R, L, or sor) is found. If an L is\n    // found, then change the type of the European number to L.\n    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n      var type$4 = types[i$5];\n      if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n      else if (isStrong.test(type$4)) { cur$1 = type$4; }\n    }\n\n    // N1. A sequence of neutrals takes the direction of the\n    // surrounding strong text if the text on both sides has the same\n    // direction. European and Arabic numbers act as if they were R in\n    // terms of their influence on neutrals. Start-of-level-run (sor)\n    // and end-of-level-run (eor) are used at level run boundaries.\n    // N2. Any remaining neutrals take the embedding direction.\n    for (var i$6 = 0; i$6 < len; ++i$6) {\n      if (isNeutral.test(types[i$6])) {\n        var end$1 = (void 0);\n        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n        var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n        var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n        var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n        i$6 = end$1 - 1;\n      }\n    }\n\n    // Here we depart from the documented algorithm, in order to avoid\n    // building up an actual levels array. Since there are only three\n    // levels (0, 1, 2) in an implementation that doesn't take\n    // explicit embedding into account, we can build up the order on\n    // the fly, without following the level-based algorithm.\n    var order = [], m;\n    for (var i$7 = 0; i$7 < len;) {\n      if (countsAsLeft.test(types[i$7])) {\n        var start = i$7;\n        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n        order.push(new BidiSpan(0, start, i$7));\n      } else {\n        var pos = i$7, at = order.length;\n        for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n        for (var j$2 = pos; j$2 < i$7;) {\n          if (countsAsNum.test(types[j$2])) {\n            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\n            var nstart = j$2;\n            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n            order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n            pos = j$2;\n          } else { ++j$2; }\n        }\n        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n      }\n    }\n    if (direction == \"ltr\") {\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift(new BidiSpan(0, 0, m[0].length));\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push(new BidiSpan(0, len - m[0].length, len));\n      }\n    }\n\n    return direction == \"rtl\" ? order.reverse() : order\n  }\n})();\n\n// Get the bidi ordering for the given line (and cache it). Returns\n// false for lines that are fully left-to-right, and an array of\n// BidiSpan objects otherwise.\nfunction getOrder(line, direction) {\n  var order = line.order;\n  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n  return order\n}\n\n// EVENT HANDLING\n\n// Lightweight event framework. on/off also work on DOM nodes,\n// registering native DOM handlers.\n\nvar noHandlers = [];\n\nvar on = function(emitter, type, f) {\n  if (emitter.addEventListener) {\n    emitter.addEventListener(type, f, false);\n  } else if (emitter.attachEvent) {\n    emitter.attachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers || (emitter._handlers = {});\n    map$$1[type] = (map$$1[type] || noHandlers).concat(f);\n  }\n};\n\nfunction getHandlers(emitter, type) {\n  return emitter._handlers && emitter._handlers[type] || noHandlers\n}\n\nfunction off(emitter, type, f) {\n  if (emitter.removeEventListener) {\n    emitter.removeEventListener(type, f, false);\n  } else if (emitter.detachEvent) {\n    emitter.detachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\n    if (arr) {\n      var index = indexOf(arr, f);\n      if (index > -1)\n        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n    }\n  }\n}\n\nfunction signal(emitter, type /*, values...*/) {\n  var handlers = getHandlers(emitter, type);\n  if (!handlers.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2);\n  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n}\n\n// The DOM events that CodeMirror handles can be overridden by\n// registering a (non-DOM) handler on the editor for the event name,\n// and preventDefault-ing the event in that handler.\nfunction signalDOMEvent(cm, e, override) {\n  if (typeof e == \"string\")\n    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n  signal(cm, override || e.type, cm, e);\n  return e_defaultPrevented(e) || e.codemirrorIgnore\n}\n\nfunction signalCursorActivity(cm) {\n  var arr = cm._handlers && cm._handlers.cursorActivity;\n  if (!arr) { return }\n  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n    { set.push(arr[i]); } }\n}\n\nfunction hasHandler(emitter, type) {\n  return getHandlers(emitter, type).length > 0\n}\n\n// Add on and off methods to a constructor's prototype, to make\n// registering events on such objects more convenient.\nfunction eventMixin(ctor) {\n  ctor.prototype.on = function(type, f) {on(this, type, f);};\n  ctor.prototype.off = function(type, f) {off(this, type, f);};\n}\n\n// Due to the fact that we still support jurassic IE versions, some\n// compatibility wrappers are needed.\n\nfunction e_preventDefault(e) {\n  if (e.preventDefault) { e.preventDefault(); }\n  else { e.returnValue = false; }\n}\nfunction e_stopPropagation(e) {\n  if (e.stopPropagation) { e.stopPropagation(); }\n  else { e.cancelBubble = true; }\n}\nfunction e_defaultPrevented(e) {\n  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n}\nfunction e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\nfunction e_target(e) {return e.target || e.srcElement}\nfunction e_button(e) {\n  var b = e.which;\n  if (b == null) {\n    if (e.button & 1) { b = 1; }\n    else if (e.button & 2) { b = 3; }\n    else if (e.button & 4) { b = 2; }\n  }\n  if (mac && e.ctrlKey && b == 1) { b = 3; }\n  return b\n}\n\n// Detect drag-and-drop\nvar dragAndDrop = function() {\n  // There is *some* kind of drag-and-drop support in IE6-8, but I\n  // couldn't get it to work yet.\n  if (ie && ie_version < 9) { return false }\n  var div = elt('div');\n  return \"draggable\" in div || \"dragDrop\" in div\n}();\n\nvar zwspSupported;\nfunction zeroWidthElement(measure) {\n  if (zwspSupported == null) {\n    var test = elt(\"span\", \"\\u200b\");\n    removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n    if (measure.firstChild.offsetHeight != 0)\n      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n  }\n  var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n    elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n  node.setAttribute(\"cm-text\", \"\");\n  return node\n}\n\n// Feature-detect IE's crummy client rect reporting for bidi text\nvar badBidiRects;\nfunction hasBadBidiRects(measure) {\n  if (badBidiRects != null) { return badBidiRects }\n  var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n  var r0 = range(txt, 0, 1).getBoundingClientRect();\n  var r1 = range(txt, 1, 2).getBoundingClientRect();\n  removeChildren(measure);\n  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n  return badBidiRects = (r1.right - r0.right < 3)\n}\n\n// See if \"\".split is the broken IE version, if so, provide an\n// alternative way to split lines.\nvar splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n  var pos = 0, result = [], l = string.length;\n  while (pos <= l) {\n    var nl = string.indexOf(\"\\n\", pos);\n    if (nl == -1) { nl = string.length; }\n    var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n    var rt = line.indexOf(\"\\r\");\n    if (rt != -1) {\n      result.push(line.slice(0, rt));\n      pos += rt + 1;\n    } else {\n      result.push(line);\n      pos = nl + 1;\n    }\n  }\n  return result\n} : function (string) { return string.split(/\\r\\n?|\\n/); };\n\nvar hasSelection = window.getSelection ? function (te) {\n  try { return te.selectionStart != te.selectionEnd }\n  catch(e) { return false }\n} : function (te) {\n  var range$$1;\n  try {range$$1 = te.ownerDocument.selection.createRange();}\n  catch(e) {}\n  if (!range$$1 || range$$1.parentElement() != te) { return false }\n  return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\n};\n\nvar hasCopyEvent = (function () {\n  var e = elt(\"div\");\n  if (\"oncopy\" in e) { return true }\n  e.setAttribute(\"oncopy\", \"return;\");\n  return typeof e.oncopy == \"function\"\n})();\n\nvar badZoomedRects = null;\nfunction hasBadZoomedRects(measure) {\n  if (badZoomedRects != null) { return badZoomedRects }\n  var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n  var normal = node.getBoundingClientRect();\n  var fromRange = range(node, 0, 1).getBoundingClientRect();\n  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n}\n\n// Known modes, by name and by MIME\nvar modes = {};\nvar mimeModes = {};\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nfunction defineMode(name, mode) {\n  if (arguments.length > 2)\n    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n  modes[name] = mode;\n}\n\nfunction defineMIME(mime, spec) {\n  mimeModes[mime] = spec;\n}\n\n// Given a MIME type, a {name, ...options} config object, or a name\n// string, return a mode config object.\nfunction resolveMode(spec) {\n  if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n    spec = mimeModes[spec];\n  } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n    var found = mimeModes[spec.name];\n    if (typeof found == \"string\") { found = {name: found}; }\n    spec = createObj(found, spec);\n    spec.name = found.name;\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n    return resolveMode(\"application/xml\")\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n    return resolveMode(\"application/json\")\n  }\n  if (typeof spec == \"string\") { return {name: spec} }\n  else { return spec || {name: \"null\"} }\n}\n\n// Given a mode spec (anything that resolveMode accepts), find and\n// initialize an actual mode object.\nfunction getMode(options, spec) {\n  spec = resolveMode(spec);\n  var mfactory = modes[spec.name];\n  if (!mfactory) { return getMode(options, \"text/plain\") }\n  var modeObj = mfactory(options, spec);\n  if (modeExtensions.hasOwnProperty(spec.name)) {\n    var exts = modeExtensions[spec.name];\n    for (var prop in exts) {\n      if (!exts.hasOwnProperty(prop)) { continue }\n      if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n      modeObj[prop] = exts[prop];\n    }\n  }\n  modeObj.name = spec.name;\n  if (spec.helperType) { modeObj.helperType = spec.helperType; }\n  if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n    { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n  return modeObj\n}\n\n// This can be used to attach properties to mode objects from\n// outside the actual mode definition.\nvar modeExtensions = {};\nfunction extendMode(mode, properties) {\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n  copyObj(properties, exts);\n}\n\nfunction copyState(mode, state) {\n  if (state === true) { return state }\n  if (mode.copyState) { return mode.copyState(state) }\n  var nstate = {};\n  for (var n in state) {\n    var val = state[n];\n    if (val instanceof Array) { val = val.concat([]); }\n    nstate[n] = val;\n  }\n  return nstate\n}\n\n// Given a mode and a state (for that mode), find the inner mode and\n// state at the position that the state refers to.\nfunction innerMode(mode, state) {\n  var info;\n  while (mode.innerMode) {\n    info = mode.innerMode(state);\n    if (!info || info.mode == mode) { break }\n    state = info.state;\n    mode = info.mode;\n  }\n  return info || {mode: mode, state: state}\n}\n\nfunction startState(mode, a1, a2) {\n  return mode.startState ? mode.startState(a1, a2) : true\n}\n\n// STRING STREAM\n\n// Fed to the mode parsers, provides helper functions to make\n// parsers more succinct.\n\nvar StringStream = function(string, tabSize, lineOracle) {\n  this.pos = this.start = 0;\n  this.string = string;\n  this.tabSize = tabSize || 8;\n  this.lastColumnPos = this.lastColumnValue = 0;\n  this.lineStart = 0;\n  this.lineOracle = lineOracle;\n};\n\nStringStream.prototype.eol = function () {return this.pos >= this.string.length};\nStringStream.prototype.sol = function () {return this.pos == this.lineStart};\nStringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\nStringStream.prototype.next = function () {\n  if (this.pos < this.string.length)\n    { return this.string.charAt(this.pos++) }\n};\nStringStream.prototype.eat = function (match) {\n  var ch = this.string.charAt(this.pos);\n  var ok;\n  if (typeof match == \"string\") { ok = ch == match; }\n  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n  if (ok) {++this.pos; return ch}\n};\nStringStream.prototype.eatWhile = function (match) {\n  var start = this.pos;\n  while (this.eat(match)){}\n  return this.pos > start\n};\nStringStream.prototype.eatSpace = function () {\n    var this$1 = this;\n\n  var start = this.pos;\n  while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\n  return this.pos > start\n};\nStringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\nStringStream.prototype.skipTo = function (ch) {\n  var found = this.string.indexOf(ch, this.pos);\n  if (found > -1) {this.pos = found; return true}\n};\nStringStream.prototype.backUp = function (n) {this.pos -= n;};\nStringStream.prototype.column = function () {\n  if (this.lastColumnPos < this.start) {\n    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n    this.lastColumnPos = this.start;\n  }\n  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.indentation = function () {\n  return countColumn(this.string, null, this.tabSize) -\n    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n  if (typeof pattern == \"string\") {\n    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n    var substr = this.string.substr(this.pos, pattern.length);\n    if (cased(substr) == cased(pattern)) {\n      if (consume !== false) { this.pos += pattern.length; }\n      return true\n    }\n  } else {\n    var match = this.string.slice(this.pos).match(pattern);\n    if (match && match.index > 0) { return null }\n    if (match && consume !== false) { this.pos += match[0].length; }\n    return match\n  }\n};\nStringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\nStringStream.prototype.hideFirstChars = function (n, inner) {\n  this.lineStart += n;\n  try { return inner() }\n  finally { this.lineStart -= n; }\n};\nStringStream.prototype.lookAhead = function (n) {\n  var oracle = this.lineOracle;\n  return oracle && oracle.lookAhead(n)\n};\nStringStream.prototype.baseToken = function () {\n  var oracle = this.lineOracle;\n  return oracle && oracle.baseToken(this.pos)\n};\n\nvar SavedContext = function(state, lookAhead) {\n  this.state = state;\n  this.lookAhead = lookAhead;\n};\n\nvar Context = function(doc, state, line, lookAhead) {\n  this.state = state;\n  this.doc = doc;\n  this.line = line;\n  this.maxLookAhead = lookAhead || 0;\n  this.baseTokens = null;\n  this.baseTokenPos = 1;\n};\n\nContext.prototype.lookAhead = function (n) {\n  var line = this.doc.getLine(this.line + n);\n  if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n  return line\n};\n\nContext.prototype.baseToken = function (n) {\n    var this$1 = this;\n\n  if (!this.baseTokens) { return null }\n  while (this.baseTokens[this.baseTokenPos] <= n)\n    { this$1.baseTokenPos += 2; }\n  var type = this.baseTokens[this.baseTokenPos + 1];\n  return {type: type && type.replace(/( |^)overlay .*/, \"\"),\n          size: this.baseTokens[this.baseTokenPos] - n}\n};\n\nContext.prototype.nextLine = function () {\n  this.line++;\n  if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n};\n\nContext.fromSaved = function (doc, saved, line) {\n  if (saved instanceof SavedContext)\n    { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n  else\n    { return new Context(doc, copyState(doc.mode, saved), line) }\n};\n\nContext.prototype.save = function (copy) {\n  var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n  return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n};\n\n\n// Compute a style array (an array starting with a mode generation\n// -- for invalidation -- followed by pairs of end positions and\n// style strings), which is used to highlight the tokens on the\n// line.\nfunction highlightLine(cm, line, context, forceToEnd) {\n  // A styles array always starts with a number identifying the\n  // mode/overlays that it is based on (for easy invalidation).\n  var st = [cm.state.modeGen], lineClasses = {};\n  // Compute the base array of styles\n  runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n          lineClasses, forceToEnd);\n  var state = context.state;\n\n  // Run overlays, adjust style array.\n  var loop = function ( o ) {\n    context.baseTokens = st;\n    var overlay = cm.state.overlays[o], i = 1, at = 0;\n    context.state = true;\n    runMode(cm, line.text, overlay.mode, context, function (end, style) {\n      var start = i;\n      // Ensure there's a token end at the current position, and that i points at it\n      while (at < end) {\n        var i_end = st[i];\n        if (i_end > end)\n          { st.splice(i, 1, end, st[i+1], i_end); }\n        i += 2;\n        at = Math.min(end, i_end);\n      }\n      if (!style) { return }\n      if (overlay.opaque) {\n        st.splice(start, i - start, end, \"overlay \" + style);\n        i = start + 2;\n      } else {\n        for (; start < i; start += 2) {\n          var cur = st[start+1];\n          st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n        }\n      }\n    }, lineClasses);\n    context.state = state;\n    context.baseTokens = null;\n    context.baseTokenPos = 1;\n  };\n\n  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n}\n\nfunction getLineStyles(cm, line, updateFrontier) {\n  if (!line.styles || line.styles[0] != cm.state.modeGen) {\n    var context = getContextBefore(cm, lineNo(line));\n    var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n    var result = highlightLine(cm, line, context);\n    if (resetState) { context.state = resetState; }\n    line.stateAfter = context.save(!resetState);\n    line.styles = result.styles;\n    if (result.classes) { line.styleClasses = result.classes; }\n    else if (line.styleClasses) { line.styleClasses = null; }\n    if (updateFrontier === cm.doc.highlightFrontier)\n      { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n  }\n  return line.styles\n}\n\nfunction getContextBefore(cm, n, precise) {\n  var doc = cm.doc, display = cm.display;\n  if (!doc.mode.startState) { return new Context(doc, true, n) }\n  var start = findStartLine(cm, n, precise);\n  var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n  var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n  doc.iter(start, n, function (line) {\n    processLine(cm, line.text, context);\n    var pos = context.line;\n    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n    context.nextLine();\n  });\n  if (precise) { doc.modeFrontier = context.line; }\n  return context\n}\n\n// Lightweight form of highlight -- proceed over this line and\n// update state, but don't save a style array. Used for lines that\n// aren't currently visible.\nfunction processLine(cm, text, context, startAt) {\n  var mode = cm.doc.mode;\n  var stream = new StringStream(text, cm.options.tabSize, context);\n  stream.start = stream.pos = startAt || 0;\n  if (text == \"\") { callBlankLine(mode, context.state); }\n  while (!stream.eol()) {\n    readToken(mode, stream, context.state);\n    stream.start = stream.pos;\n  }\n}\n\nfunction callBlankLine(mode, state) {\n  if (mode.blankLine) { return mode.blankLine(state) }\n  if (!mode.innerMode) { return }\n  var inner = innerMode(mode, state);\n  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n}\n\nfunction readToken(mode, stream, state, inner) {\n  for (var i = 0; i < 10; i++) {\n    if (inner) { inner[0] = innerMode(mode, state).mode; }\n    var style = mode.token(stream, state);\n    if (stream.pos > stream.start) { return style }\n  }\n  throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n}\n\nvar Token = function(stream, type, state) {\n  this.start = stream.start; this.end = stream.pos;\n  this.string = stream.current();\n  this.type = type || null;\n  this.state = state;\n};\n\n// Utility for getTokenAt and getLineTokens\nfunction takeToken(cm, pos, precise, asArray) {\n  var doc = cm.doc, mode = doc.mode, style;\n  pos = clipPos(doc, pos);\n  var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n  var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n  if (asArray) { tokens = []; }\n  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n    stream.start = stream.pos;\n    style = readToken(mode, stream, context.state);\n    if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n  }\n  return asArray ? tokens : new Token(stream, style, context.state)\n}\n\nfunction extractLineClasses(type, output) {\n  if (type) { for (;;) {\n    var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n    if (!lineClass) { break }\n    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n    var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n    if (output[prop] == null)\n      { output[prop] = lineClass[2]; }\n    else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n      { output[prop] += \" \" + lineClass[2]; }\n  } }\n  return type\n}\n\n// Run the given mode's parser over a line, calling f for each token.\nfunction runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n  var flattenSpans = mode.flattenSpans;\n  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n  var curStart = 0, curStyle = null;\n  var stream = new StringStream(text, cm.options.tabSize, context), style;\n  var inner = cm.options.addModeClass && [null];\n  if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n  while (!stream.eol()) {\n    if (stream.pos > cm.options.maxHighlightLength) {\n      flattenSpans = false;\n      if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n      stream.pos = text.length;\n      style = null;\n    } else {\n      style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n    }\n    if (inner) {\n      var mName = inner[0].name;\n      if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n    }\n    if (!flattenSpans || curStyle != style) {\n      while (curStart < stream.start) {\n        curStart = Math.min(stream.start, curStart + 5000);\n        f(curStart, curStyle);\n      }\n      curStyle = style;\n    }\n    stream.start = stream.pos;\n  }\n  while (curStart < stream.pos) {\n    // Webkit seems to refuse to render text nodes longer than 57444\n    // characters, and returns inaccurate measurements in nodes\n    // starting around 5000 chars.\n    var pos = Math.min(stream.pos, curStart + 5000);\n    f(pos, curStyle);\n    curStart = pos;\n  }\n}\n\n// Finds the line to start with when starting a parse. Tries to\n// find a line with a stateAfter, so that it can start with a\n// valid state. If that fails, it returns the line with the\n// smallest indentation, which tends to need the least context to\n// parse correctly.\nfunction findStartLine(cm, n, precise) {\n  var minindent, minline, doc = cm.doc;\n  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n  for (var search = n; search > lim; --search) {\n    if (search <= doc.first) { return doc.first }\n    var line = getLine(doc, search - 1), after = line.stateAfter;\n    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n      { return search }\n    var indented = countColumn(line.text, null, cm.options.tabSize);\n    if (minline == null || minindent > indented) {\n      minline = search - 1;\n      minindent = indented;\n    }\n  }\n  return minline\n}\n\nfunction retreatFrontier(doc, n) {\n  doc.modeFrontier = Math.min(doc.modeFrontier, n);\n  if (doc.highlightFrontier < n - 10) { return }\n  var start = doc.first;\n  for (var line = n - 1; line > start; line--) {\n    var saved = getLine(doc, line).stateAfter;\n    // change is on 3\n    // state on line 1 looked ahead 2 -- so saw 3\n    // test 1 + 2 < 3 should cover this\n    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n      start = line + 1;\n      break\n    }\n  }\n  doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n}\n\n// LINE DATA STRUCTURE\n\n// Line objects. These hold state related to a line, including\n// highlighting info (the styles array).\nvar Line = function(text, markedSpans, estimateHeight) {\n  this.text = text;\n  attachMarkedSpans(this, markedSpans);\n  this.height = estimateHeight ? estimateHeight(this) : 1;\n};\n\nLine.prototype.lineNo = function () { return lineNo(this) };\neventMixin(Line);\n\n// Change the content (text, markers) of a line. Automatically\n// invalidates cached information and tries to re-estimate the\n// line's height.\nfunction updateLine(line, text, markedSpans, estimateHeight) {\n  line.text = text;\n  if (line.stateAfter) { line.stateAfter = null; }\n  if (line.styles) { line.styles = null; }\n  if (line.order != null) { line.order = null; }\n  detachMarkedSpans(line);\n  attachMarkedSpans(line, markedSpans);\n  var estHeight = estimateHeight ? estimateHeight(line) : 1;\n  if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n}\n\n// Detach a line from the document tree and its markers.\nfunction cleanUpLine(line) {\n  line.parent = null;\n  detachMarkedSpans(line);\n}\n\n// Convert a style as returned by a mode (either null, or a string\n// containing one or more styles) to a CSS style. This is cached,\n// and also looks for line-wide styles.\nvar styleToClassCache = {};\nvar styleToClassCacheWithMode = {};\nfunction interpretTokenStyle(style, options) {\n  if (!style || /^\\s*$/.test(style)) { return null }\n  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n  return cache[style] ||\n    (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n}\n\n// Render the DOM representation of the text of a line. Also builds\n// up a 'line map', which points at the DOM nodes that represent\n// specific stretches of text, and is used by the measuring code.\n// The returned object contains the DOM node, this map, and\n// information about line-wide styles that were set by the mode.\nfunction buildLineContent(cm, lineView) {\n  // The padding-right forces the element to have a 'border', which\n  // is needed on Webkit to be able to get line-level bounding\n  // rectangles for it (in measureChar).\n  var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n  var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                 col: 0, pos: 0, cm: cm,\n                 trailingSpace: false,\n                 splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n  lineView.measure = {};\n\n  // Iterate over the logical lines that make up this visual line.\n  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n    builder.pos = 0;\n    builder.addToken = buildToken;\n    // Optionally wire in some hacks into the token-rendering\n    // algorithm, to deal with browser quirks.\n    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n    builder.map = [];\n    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n    if (line.styleClasses) {\n      if (line.styleClasses.bgClass)\n        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n      if (line.styleClasses.textClass)\n        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n    }\n\n    // Ensure at least a single node is present, for measuring.\n    if (builder.map.length == 0)\n      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n    // Store the map and a cache object for the current logical line\n    if (i == 0) {\n      lineView.measure.map = builder.map;\n      lineView.measure.cache = {};\n    } else {\n      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n    }\n  }\n\n  // See issue #2901\n  if (webkit) {\n    var last = builder.content.lastChild;\n    if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n      { builder.content.className = \"cm-tab-wrap-hack\"; }\n  }\n\n  signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n  if (builder.pre.className)\n    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n  return builder\n}\n\nfunction defaultSpecialCharPlaceholder(ch) {\n  var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n  token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n  token.setAttribute(\"aria-label\", token.title);\n  return token\n}\n\n// Build up the DOM representation for a single token, and add it to\n// the line map. Takes care to render special characters separately.\nfunction buildToken(builder, text, style, startStyle, endStyle, title, css) {\n  if (!text) { return }\n  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n  var special = builder.cm.state.specialChars, mustWrap = false;\n  var content;\n  if (!special.test(text)) {\n    builder.col += text.length;\n    content = document.createTextNode(displayText);\n    builder.map.push(builder.pos, builder.pos + text.length, content);\n    if (ie && ie_version < 9) { mustWrap = true; }\n    builder.pos += text.length;\n  } else {\n    content = document.createDocumentFragment();\n    var pos = 0;\n    while (true) {\n      special.lastIndex = pos;\n      var m = special.exec(text);\n      var skipped = m ? m.index - pos : text.length - pos;\n      if (skipped) {\n        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n        else { content.appendChild(txt); }\n        builder.map.push(builder.pos, builder.pos + skipped, txt);\n        builder.col += skipped;\n        builder.pos += skipped;\n      }\n      if (!m) { break }\n      pos += skipped + 1;\n      var txt$1 = (void 0);\n      if (m[0] == \"\\t\") {\n        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n        txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n        txt$1.setAttribute(\"role\", \"presentation\");\n        txt$1.setAttribute(\"cm-text\", \"\\t\");\n        builder.col += tabWidth;\n      } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n        txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        builder.col += 1;\n      } else {\n        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n        else { content.appendChild(txt$1); }\n        builder.col += 1;\n      }\n      builder.map.push(builder.pos, builder.pos + 1, txt$1);\n      builder.pos++;\n    }\n  }\n  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n  if (style || startStyle || endStyle || mustWrap || css) {\n    var fullStyle = style || \"\";\n    if (startStyle) { fullStyle += startStyle; }\n    if (endStyle) { fullStyle += endStyle; }\n    var token = elt(\"span\", [content], fullStyle, css);\n    if (title) { token.title = title; }\n    return builder.content.appendChild(token)\n  }\n  builder.content.appendChild(content);\n}\n\nfunction splitSpaces(text, trailingBefore) {\n  if (text.length > 1 && !/  /.test(text)) { return text }\n  var spaceBefore = trailingBefore, result = \"\";\n  for (var i = 0; i < text.length; i++) {\n    var ch = text.charAt(i);\n    if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n      { ch = \"\\u00a0\"; }\n    result += ch;\n    spaceBefore = ch == \" \";\n  }\n  return result\n}\n\n// Work around nonsense dimensions being reported for stretches of\n// right-to-left text.\nfunction buildTokenBadBidi(inner, order) {\n  return function (builder, text, style, startStyle, endStyle, title, css) {\n    style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n    var start = builder.pos, end = start + text.length;\n    for (;;) {\n      // Find the part that overlaps with the start of this text\n      var part = (void 0);\n      for (var i = 0; i < order.length; i++) {\n        part = order[i];\n        if (part.to > start && part.from <= start) { break }\n      }\n      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }\n      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n      startStyle = null;\n      text = text.slice(part.to - start);\n      start = part.to;\n    }\n  }\n}\n\nfunction buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n  var widget = !ignoreWidget && marker.widgetNode;\n  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n    if (!widget)\n      { widget = builder.content.appendChild(document.createElement(\"span\")); }\n    widget.setAttribute(\"cm-marker\", marker.id);\n  }\n  if (widget) {\n    builder.cm.display.input.setUneditable(widget);\n    builder.content.appendChild(widget);\n  }\n  builder.pos += size;\n  builder.trailingSpace = false;\n}\n\n// Outputs a number of spans to make up a line, taking highlighting\n// and marked text into account.\nfunction insertLineContent(line, builder, styles) {\n  var spans = line.markedSpans, allText = line.text, at = 0;\n  if (!spans) {\n    for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n    return\n  }\n\n  var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n  for (;;) {\n    if (nextChange == pos) { // Update current marker set\n      spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n      collapsed = null; nextChange = Infinity;\n      var foundBookmarks = [], endStyles = (void 0);\n      for (var j = 0; j < spans.length; ++j) {\n        var sp = spans[j], m = sp.marker;\n        if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n          foundBookmarks.push(m);\n        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n          if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n            nextChange = sp.to;\n            spanEndStyle = \"\";\n          }\n          if (m.className) { spanStyle += \" \" + m.className; }\n          if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n          if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n          if (m.title && !title) { title = m.title; }\n          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n            { collapsed = sp; }\n        } else if (sp.from > pos && nextChange > sp.from) {\n          nextChange = sp.from;\n        }\n      }\n      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n      if (collapsed && (collapsed.from || 0) == pos) {\n        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                           collapsed.marker, collapsed.from == null);\n        if (collapsed.to == null) { return }\n        if (collapsed.to == pos) { collapsed = false; }\n      }\n    }\n    if (pos >= len) { break }\n\n    var upto = Math.min(len, nextChange);\n    while (true) {\n      if (text) {\n        var end = pos + text.length;\n        if (!collapsed) {\n          var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n        }\n        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n        pos = end;\n        spanStartStyle = \"\";\n      }\n      text = allText.slice(at, at = styles[i++]);\n      style = interpretTokenStyle(styles[i++], builder.cm.options);\n    }\n  }\n}\n\n\n// These objects are used to represent the visible (currently drawn)\n// part of the document. A LineView may correspond to multiple\n// logical lines, if those are connected by collapsed ranges.\nfunction LineView(doc, line, lineN) {\n  // The starting line\n  this.line = line;\n  // Continuing lines, if any\n  this.rest = visualLineContinued(line);\n  // Number of logical lines in this visual line\n  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n  this.node = this.text = null;\n  this.hidden = lineIsHidden(doc, line);\n}\n\n// Create a range of LineView objects for the given lines.\nfunction buildViewArray(cm, from, to) {\n  var array = [], nextPos;\n  for (var pos = from; pos < to; pos = nextPos) {\n    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n    nextPos = pos + view.size;\n    array.push(view);\n  }\n  return array\n}\n\nvar operationGroup = null;\n\nfunction pushOperation(op) {\n  if (operationGroup) {\n    operationGroup.ops.push(op);\n  } else {\n    op.ownsGroup = operationGroup = {\n      ops: [op],\n      delayedCallbacks: []\n    };\n  }\n}\n\nfunction fireCallbacksForOps(group) {\n  // Calls delayed callbacks and cursorActivity handlers until no\n  // new ones appear\n  var callbacks = group.delayedCallbacks, i = 0;\n  do {\n    for (; i < callbacks.length; i++)\n      { callbacks[i].call(null); }\n    for (var j = 0; j < group.ops.length; j++) {\n      var op = group.ops[j];\n      if (op.cursorActivityHandlers)\n        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n    }\n  } while (i < callbacks.length)\n}\n\nfunction finishOperation(op, endCb) {\n  var group = op.ownsGroup;\n  if (!group) { return }\n\n  try { fireCallbacksForOps(group); }\n  finally {\n    operationGroup = null;\n    endCb(group);\n  }\n}\n\nvar orphanDelayedCallbacks = null;\n\n// Often, we want to signal events at a point where we are in the\n// middle of some work, but don't want the handler to start calling\n// other methods on the editor, which might be in an inconsistent\n// state or simply not expect any other events to happen.\n// signalLater looks whether there are any handlers, and schedules\n// them to be executed when the last operation ends, or, if no\n// operation is active, when a timeout fires.\nfunction signalLater(emitter, type /*, values...*/) {\n  var arr = getHandlers(emitter, type);\n  if (!arr.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2), list;\n  if (operationGroup) {\n    list = operationGroup.delayedCallbacks;\n  } else if (orphanDelayedCallbacks) {\n    list = orphanDelayedCallbacks;\n  } else {\n    list = orphanDelayedCallbacks = [];\n    setTimeout(fireOrphanDelayed, 0);\n  }\n  var loop = function ( i ) {\n    list.push(function () { return arr[i].apply(null, args); });\n  };\n\n  for (var i = 0; i < arr.length; ++i)\n    loop( i );\n}\n\nfunction fireOrphanDelayed() {\n  var delayed = orphanDelayedCallbacks;\n  orphanDelayedCallbacks = null;\n  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n}\n\n// When an aspect of a line changes, a string is added to\n// lineView.changes. This updates the relevant part of the line's\n// DOM structure.\nfunction updateLineForChanges(cm, lineView, lineN, dims) {\n  for (var j = 0; j < lineView.changes.length; j++) {\n    var type = lineView.changes[j];\n    if (type == \"text\") { updateLineText(cm, lineView); }\n    else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n    else if (type == \"class\") { updateLineClasses(cm, lineView); }\n    else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n  }\n  lineView.changes = null;\n}\n\n// Lines with gutter elements, widgets or a background class need to\n// be wrapped, and have the extra elements added to the wrapper div\nfunction ensureLineWrapped(lineView) {\n  if (lineView.node == lineView.text) {\n    lineView.node = elt(\"div\", null, null, \"position: relative\");\n    if (lineView.text.parentNode)\n      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n    lineView.node.appendChild(lineView.text);\n    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n  }\n  return lineView.node\n}\n\nfunction updateLineBackground(cm, lineView) {\n  var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n  if (cls) { cls += \" CodeMirror-linebackground\"; }\n  if (lineView.background) {\n    if (cls) { lineView.background.className = cls; }\n    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n  } else if (cls) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    cm.display.input.setUneditable(lineView.background);\n  }\n}\n\n// Wrapper around buildLineContent which will reuse the structure\n// in display.externalMeasured when possible.\nfunction getLineContent(cm, lineView) {\n  var ext = cm.display.externalMeasured;\n  if (ext && ext.line == lineView.line) {\n    cm.display.externalMeasured = null;\n    lineView.measure = ext.measure;\n    return ext.built\n  }\n  return buildLineContent(cm, lineView)\n}\n\n// Redraw the line's text. Interacts with the background and text\n// classes because the mode may output tokens that influence these\n// classes.\nfunction updateLineText(cm, lineView) {\n  var cls = lineView.text.className;\n  var built = getLineContent(cm, lineView);\n  if (lineView.text == lineView.node) { lineView.node = built.pre; }\n  lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n  lineView.text = built.pre;\n  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n    lineView.bgClass = built.bgClass;\n    lineView.textClass = built.textClass;\n    updateLineClasses(cm, lineView);\n  } else if (cls) {\n    lineView.text.className = cls;\n  }\n}\n\nfunction updateLineClasses(cm, lineView) {\n  updateLineBackground(cm, lineView);\n  if (lineView.line.wrapClass)\n    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n  else if (lineView.node != lineView.text)\n    { lineView.node.className = \"\"; }\n  var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n  lineView.text.className = textClass || \"\";\n}\n\nfunction updateLineGutter(cm, lineView, lineN, dims) {\n  if (lineView.gutter) {\n    lineView.node.removeChild(lineView.gutter);\n    lineView.gutter = null;\n  }\n  if (lineView.gutterBackground) {\n    lineView.node.removeChild(lineView.gutterBackground);\n    lineView.gutterBackground = null;\n  }\n  if (lineView.line.gutterClass) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                    (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(lineView.gutterBackground);\n    wrap.insertBefore(lineView.gutterBackground, lineView.text);\n  }\n  var markers = lineView.line.gutterMarkers;\n  if (cm.options.lineNumbers || markers) {\n    var wrap$1 = ensureLineWrapped(lineView);\n    var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(gutterWrap);\n    wrap$1.insertBefore(gutterWrap, lineView.text);\n    if (lineView.line.gutterClass)\n      { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n    if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n      { lineView.lineNumber = gutterWrap.appendChild(\n        elt(\"div\", lineNumberFor(cm.options, lineN),\n            \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n            (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\n      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n      if (found)\n        { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                   (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n    } }\n  }\n}\n\nfunction updateLineWidgets(cm, lineView, dims) {\n  if (lineView.alignable) { lineView.alignable = null; }\n  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n    next = node.nextSibling;\n    if (node.className == \"CodeMirror-linewidget\")\n      { lineView.node.removeChild(node); }\n  }\n  insertLineWidgets(cm, lineView, dims);\n}\n\n// Build a line's DOM representation from scratch\nfunction buildLineElement(cm, lineView, lineN, dims) {\n  var built = getLineContent(cm, lineView);\n  lineView.text = lineView.node = built.pre;\n  if (built.bgClass) { lineView.bgClass = built.bgClass; }\n  if (built.textClass) { lineView.textClass = built.textClass; }\n\n  updateLineClasses(cm, lineView);\n  updateLineGutter(cm, lineView, lineN, dims);\n  insertLineWidgets(cm, lineView, dims);\n  return lineView.node\n}\n\n// A lineView may contain multiple logical lines (when merged by\n// collapsed spans). The widgets for all of them need to be drawn.\nfunction insertLineWidgets(cm, lineView, dims) {\n  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n}\n\nfunction insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n  if (!line.widgets) { return }\n  var wrap = ensureLineWrapped(lineView);\n  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n    var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n    if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n    positionLineWidget(widget, node, lineView, dims);\n    cm.display.input.setUneditable(node);\n    if (allowAbove && widget.above)\n      { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n    else\n      { wrap.appendChild(node); }\n    signalLater(widget, \"redraw\");\n  }\n}\n\nfunction positionLineWidget(widget, node, lineView, dims) {\n  if (widget.noHScroll) {\n    (lineView.alignable || (lineView.alignable = [])).push(node);\n    var width = dims.wrapperWidth;\n    node.style.left = dims.fixedPos + \"px\";\n    if (!widget.coverGutter) {\n      width -= dims.gutterTotalWidth;\n      node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n    }\n    node.style.width = width + \"px\";\n  }\n  if (widget.coverGutter) {\n    node.style.zIndex = 5;\n    node.style.position = \"relative\";\n    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n  }\n}\n\nfunction widgetHeight(widget) {\n  if (widget.height != null) { return widget.height }\n  var cm = widget.doc.cm;\n  if (!cm) { return 0 }\n  if (!contains(document.body, widget.node)) {\n    var parentStyle = \"position: relative;\";\n    if (widget.coverGutter)\n      { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n    if (widget.noHScroll)\n      { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n    removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n  }\n  return widget.height = widget.node.parentNode.offsetHeight\n}\n\n// Return true when the given mouse event happened in a widget\nfunction eventInWidget(display, e) {\n  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n    if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n        (n.parentNode == display.sizer && n != display.mover))\n      { return true }\n  }\n}\n\n// POSITION MEASUREMENT\n\nfunction paddingTop(display) {return display.lineSpace.offsetTop}\nfunction paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\nfunction paddingH(display) {\n  if (display.cachedPaddingH) { return display.cachedPaddingH }\n  var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n  return data\n}\n\nfunction scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\nfunction displayWidth(cm) {\n  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n}\nfunction displayHeight(cm) {\n  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n}\n\n// Ensure the lineView.wrapping.heights array is populated. This is\n// an array of bottom offsets for the lines that make up a drawn\n// line. When lineWrapping is on, there might be more than one\n// height.\nfunction ensureLineHeights(cm, lineView, rect) {\n  var wrapping = cm.options.lineWrapping;\n  var curWidth = wrapping && displayWidth(cm);\n  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n    var heights = lineView.measure.heights = [];\n    if (wrapping) {\n      lineView.measure.width = curWidth;\n      var rects = lineView.text.firstChild.getClientRects();\n      for (var i = 0; i < rects.length - 1; i++) {\n        var cur = rects[i], next = rects[i + 1];\n        if (Math.abs(cur.bottom - next.bottom) > 2)\n          { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n      }\n    }\n    heights.push(rect.bottom - rect.top);\n  }\n}\n\n// Find a line map (mapping character offsets to text nodes) and a\n// measurement cache for the given line number. (A line view might\n// contain multiple lines when collapsed ranges are present.)\nfunction mapFromLineView(lineView, line, lineN) {\n  if (lineView.line == line)\n    { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n  for (var i = 0; i < lineView.rest.length; i++)\n    { if (lineView.rest[i] == line)\n      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n    { if (lineNo(lineView.rest[i$1]) > lineN)\n      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n}\n\n// Render a line into the hidden node display.externalMeasured. Used\n// when measurement is needed for a line that's not in the viewport.\nfunction updateExternalMeasurement(cm, line) {\n  line = visualLine(line);\n  var lineN = lineNo(line);\n  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n  view.lineN = lineN;\n  var built = view.built = buildLineContent(cm, view);\n  view.text = built.pre;\n  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n  return view\n}\n\n// Get a {top, bottom, left, right} box (in line-local coordinates)\n// for a given character.\nfunction measureChar(cm, line, ch, bias) {\n  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n}\n\n// Find a line view that corresponds to the given line number.\nfunction findViewForLine(cm, lineN) {\n  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n    { return cm.display.view[findViewIndex(cm, lineN)] }\n  var ext = cm.display.externalMeasured;\n  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n    { return ext }\n}\n\n// Measurement can be split in two steps, the set-up work that\n// applies to the whole line, and the measurement of the actual\n// character. Functions like coordsChar, that need to do a lot of\n// measurements in a row, can thus ensure that the set-up work is\n// only done once.\nfunction prepareMeasureForLine(cm, line) {\n  var lineN = lineNo(line);\n  var view = findViewForLine(cm, lineN);\n  if (view && !view.text) {\n    view = null;\n  } else if (view && view.changes) {\n    updateLineForChanges(cm, view, lineN, getDimensions(cm));\n    cm.curOp.forceUpdate = true;\n  }\n  if (!view)\n    { view = updateExternalMeasurement(cm, line); }\n\n  var info = mapFromLineView(view, line, lineN);\n  return {\n    line: line, view: view, rect: null,\n    map: info.map, cache: info.cache, before: info.before,\n    hasHeights: false\n  }\n}\n\n// Given a prepared measurement object, measures the position of an\n// actual character (or fetches it from the cache).\nfunction measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n  if (prepared.before) { ch = -1; }\n  var key = ch + (bias || \"\"), found;\n  if (prepared.cache.hasOwnProperty(key)) {\n    found = prepared.cache[key];\n  } else {\n    if (!prepared.rect)\n      { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n    if (!prepared.hasHeights) {\n      ensureLineHeights(cm, prepared.view, prepared.rect);\n      prepared.hasHeights = true;\n    }\n    found = measureCharInner(cm, prepared, ch, bias);\n    if (!found.bogus) { prepared.cache[key] = found; }\n  }\n  return {left: found.left, right: found.right,\n          top: varHeight ? found.rtop : found.top,\n          bottom: varHeight ? found.rbottom : found.bottom}\n}\n\nvar nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\nfunction nodeAndOffsetInLineMap(map$$1, ch, bias) {\n  var node, start, end, collapse, mStart, mEnd;\n  // First, search the line map for the text node corresponding to,\n  // or closest to, the target character.\n  for (var i = 0; i < map$$1.length; i += 3) {\n    mStart = map$$1[i];\n    mEnd = map$$1[i + 1];\n    if (ch < mStart) {\n      start = 0; end = 1;\n      collapse = \"left\";\n    } else if (ch < mEnd) {\n      start = ch - mStart;\n      end = start + 1;\n    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\n      end = mEnd - mStart;\n      start = end - 1;\n      if (ch >= mEnd) { collapse = \"right\"; }\n    }\n    if (start != null) {\n      node = map$$1[i + 2];\n      if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n        { collapse = bias; }\n      if (bias == \"left\" && start == 0)\n        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\n          node = map$$1[(i -= 3) + 2];\n          collapse = \"left\";\n        } }\n      if (bias == \"right\" && start == mEnd - mStart)\n        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\n          node = map$$1[(i += 3) + 2];\n          collapse = \"right\";\n        } }\n      break\n    }\n  }\n  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n}\n\nfunction getUsefulRect(rects, bias) {\n  var rect = nullRect;\n  if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n    if ((rect = rects[i]).left != rect.right) { break }\n  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n    if ((rect = rects[i$1]).left != rect.right) { break }\n  } }\n  return rect\n}\n\nfunction measureCharInner(cm, prepared, ch, bias) {\n  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n  var rect;\n  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n        { rect = node.parentNode.getBoundingClientRect(); }\n      else\n        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n      if (rect.left || rect.right || start == 0) { break }\n      end = start;\n      start = start - 1;\n      collapse = \"right\";\n    }\n    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n  } else { // If it is a widget, simply get the box for the whole widget.\n    if (start > 0) { collapse = bias = \"right\"; }\n    var rects;\n    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n      { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n    else\n      { rect = node.getBoundingClientRect(); }\n  }\n  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n    var rSpan = node.parentNode.getClientRects()[0];\n    if (rSpan)\n      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n    else\n      { rect = nullRect; }\n  }\n\n  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n  var mid = (rtop + rbot) / 2;\n  var heights = prepared.view.measure.heights;\n  var i = 0;\n  for (; i < heights.length - 1; i++)\n    { if (mid < heights[i]) { break } }\n  var top = i ? heights[i - 1] : 0, bot = heights[i];\n  var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                top: top, bottom: bot};\n  if (!rect.left && !rect.right) { result.bogus = true; }\n  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n  return result\n}\n\n// Work around problem with bounding client rects on ranges being\n// returned incorrectly when zoomed on IE10 and below.\nfunction maybeUpdateRectForZooming(measure, rect) {\n  if (!window.screen || screen.logicalXDPI == null ||\n      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n    { return rect }\n  var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n  var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n  return {left: rect.left * scaleX, right: rect.right * scaleX,\n          top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n}\n\nfunction clearLineMeasurementCacheFor(lineView) {\n  if (lineView.measure) {\n    lineView.measure.cache = {};\n    lineView.measure.heights = null;\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { lineView.measure.caches[i] = {}; } }\n  }\n}\n\nfunction clearLineMeasurementCache(cm) {\n  cm.display.externalMeasure = null;\n  removeChildren(cm.display.lineMeasure);\n  for (var i = 0; i < cm.display.view.length; i++)\n    { clearLineMeasurementCacheFor(cm.display.view[i]); }\n}\n\nfunction clearCaches(cm) {\n  clearLineMeasurementCache(cm);\n  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n  cm.display.lineNumChars = null;\n}\n\nfunction pageScrollX() {\n  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n  // which causes page_Offset and bounding client rects to use\n  // different reference viewports and invalidate our calculations.\n  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n  return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n}\nfunction pageScrollY() {\n  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n  return window.pageYOffset || (document.documentElement || document.body).scrollTop\n}\n\nfunction widgetTopHeight(lineObj) {\n  var height = 0;\n  if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\n    { height += widgetHeight(lineObj.widgets[i]); } } }\n  return height\n}\n\n// Converts a {top, bottom, left, right} box from line-local\n// coordinates into another coordinate system. Context may be one of\n// \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n// or \"page\".\nfunction intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n  if (!includeWidgets) {\n    var height = widgetTopHeight(lineObj);\n    rect.top += height; rect.bottom += height;\n  }\n  if (context == \"line\") { return rect }\n  if (!context) { context = \"local\"; }\n  var yOff = heightAtLine(lineObj);\n  if (context == \"local\") { yOff += paddingTop(cm.display); }\n  else { yOff -= cm.display.viewOffset; }\n  if (context == \"page\" || context == \"window\") {\n    var lOff = cm.display.lineSpace.getBoundingClientRect();\n    yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n    var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n    rect.left += xOff; rect.right += xOff;\n  }\n  rect.top += yOff; rect.bottom += yOff;\n  return rect\n}\n\n// Coverts a box from \"div\" coords to another coordinate system.\n// Context may be \"window\", \"page\", \"div\", or \"local\"./null.\nfunction fromCoordSystem(cm, coords, context) {\n  if (context == \"div\") { return coords }\n  var left = coords.left, top = coords.top;\n  // First move into \"page\" coordinate system\n  if (context == \"page\") {\n    left -= pageScrollX();\n    top -= pageScrollY();\n  } else if (context == \"local\" || !context) {\n    var localBox = cm.display.sizer.getBoundingClientRect();\n    left += localBox.left;\n    top += localBox.top;\n  }\n\n  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n}\n\nfunction charCoords(cm, pos, context, lineObj, bias) {\n  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n}\n\n// Returns a box for a given cursor position, which may have an\n// 'other' property containing the position of the secondary cursor\n// on a bidi boundary.\n// A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n// and after `char - 1` in writing order of `char - 1`\n// A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n// and before `char` in writing order of `char`\n// Examples (upper-case letters are RTL, lower-case are LTR):\n//     Pos(0, 1, ...)\n//     before   after\n// ab     a|b     a|b\n// aB     a|B     aB|\n// Ab     |Ab     A|b\n// AB     B|A     B|A\n// Every position after the last character on a line is considered to stick\n// to the last character on the line.\nfunction cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n  lineObj = lineObj || getLine(cm.doc, pos.line);\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n  function get(ch, right) {\n    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n    if (right) { m.left = m.right; } else { m.right = m.left; }\n    return intoCoordSystem(cm, lineObj, m, context)\n  }\n  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n  if (ch >= lineObj.text.length) {\n    ch = lineObj.text.length;\n    sticky = \"before\";\n  } else if (ch <= 0) {\n    ch = 0;\n    sticky = \"after\";\n  }\n  if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n  function getBidi(ch, partPos, invert) {\n    var part = order[partPos], right = part.level == 1;\n    return get(invert ? ch - 1 : ch, right != invert)\n  }\n  var partPos = getBidiPartAt(order, ch, sticky);\n  var other = bidiOther;\n  var val = getBidi(ch, partPos, sticky == \"before\");\n  if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n  return val\n}\n\n// Used to cheaply estimate the coordinates for a position. Used for\n// intermediate scroll updates.\nfunction estimateCoords(cm, pos) {\n  var left = 0;\n  pos = clipPos(cm.doc, pos);\n  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n  var lineObj = getLine(cm.doc, pos.line);\n  var top = heightAtLine(lineObj) + paddingTop(cm.display);\n  return {left: left, right: left, top: top, bottom: top + lineObj.height}\n}\n\n// Positions returned by coordsChar contain some extra information.\n// xRel is the relative x position of the input coordinates compared\n// to the found position (so xRel > 0 means the coordinates are to\n// the right of the character position, for example). When outside\n// is true, that means the coordinates lie outside the line's\n// vertical range.\nfunction PosWithInfo(line, ch, sticky, outside, xRel) {\n  var pos = Pos(line, ch, sticky);\n  pos.xRel = xRel;\n  if (outside) { pos.outside = true; }\n  return pos\n}\n\n// Compute the character position closest to the given coordinates.\n// Input must be lineSpace-local (\"div\" coordinate system).\nfunction coordsChar(cm, x, y) {\n  var doc = cm.doc;\n  y += cm.display.viewOffset;\n  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\n  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n  if (lineN > last)\n    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\n  if (x < 0) { x = 0; }\n\n  var lineObj = getLine(doc, lineN);\n  for (;;) {\n    var found = coordsCharInner(cm, lineObj, lineN, x, y);\n    var merged = collapsedSpanAtEnd(lineObj);\n    var mergedPos = merged && merged.find(0, true);\n    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n      { lineN = lineNo(lineObj = mergedPos.to.line); }\n    else\n      { return found }\n  }\n}\n\nfunction wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n  y -= widgetTopHeight(lineObj);\n  var end = lineObj.text.length;\n  var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\n  end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\n  return {begin: begin, end: end}\n}\n\nfunction wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n}\n\n// Returns true if the given side of a box is after the given\n// coordinates, in top-to-bottom, left-to-right order.\nfunction boxIsAfter(box, x, y, left) {\n  return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\n}\n\nfunction coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\n  // Move y into line-local coordinate space\n  y -= heightAtLine(lineObj);\n  var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n  // When directly calling `measureCharPrepared`, we have to adjust\n  // for the widgets at this line.\n  var widgetHeight$$1 = widgetTopHeight(lineObj);\n  var begin = 0, end = lineObj.text.length, ltr = true;\n\n  var order = getOrder(lineObj, cm.doc.direction);\n  // If the line isn't plain left-to-right text, first figure out\n  // which bidi section the coordinates fall into.\n  if (order) {\n    var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                 (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);\n    ltr = part.level != 1;\n    // The awkward -1 offsets are needed because findFirst (called\n    // on these below) will treat its first bound as inclusive,\n    // second as exclusive, but we want to actually address the\n    // characters in the part's range\n    begin = ltr ? part.from : part.to - 1;\n    end = ltr ? part.to : part.from - 1;\n  }\n\n  // A binary search to find the first character whose bounding box\n  // starts after the coordinates. If we run across any whose box wrap\n  // the coordinates, store that.\n  var chAround = null, boxAround = null;\n  var ch = findFirst(function (ch) {\n    var box = measureCharPrepared(cm, preparedMeasure, ch);\n    box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;\n    if (!boxIsAfter(box, x, y, false)) { return false }\n    if (box.top <= y && box.left <= x) {\n      chAround = ch;\n      boxAround = box;\n    }\n    return true\n  }, begin, end);\n\n  var baseX, sticky, outside = false;\n  // If a box around the coordinates was found, use that\n  if (boxAround) {\n    // Distinguish coordinates nearer to the left or right side of the box\n    var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n    ch = chAround + (atStart ? 0 : 1);\n    sticky = atStart ? \"after\" : \"before\";\n    baseX = atLeft ? boxAround.left : boxAround.right;\n  } else {\n    // (Adjust for extended bound, if necessary.)\n    if (!ltr && (ch == end || ch == begin)) { ch++; }\n    // To determine which side to associate with, get the box to the\n    // left of the character and compare it's vertical position to the\n    // coordinates\n    sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\n      (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?\n      \"after\" : \"before\";\n    // Now get accurate coordinates for this place, in order to get a\n    // base X position\n    var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), \"line\", lineObj, preparedMeasure);\n    baseX = coords.left;\n    outside = y < coords.top || y >= coords.bottom;\n  }\n\n  ch = skipExtendingChars(lineObj.text, ch, 1);\n  return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)\n}\n\nfunction coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {\n  // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n  // situation, we can take this ordering to correspond to the visual\n  // ordering. This finds the first part whose end is after the given\n  // coordinates.\n  var index = findFirst(function (i) {\n    var part = order[i], ltr = part.level != 1;\n    return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\n                                   \"line\", lineObj, preparedMeasure), x, y, true)\n  }, 0, order.length - 1);\n  var part = order[index];\n  // If this isn't the first part, the part's start is also after\n  // the coordinates, and the coordinates aren't on the same line as\n  // that start, move one part back.\n  if (index > 0) {\n    var ltr = part.level != 1;\n    var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\n                             \"line\", lineObj, preparedMeasure);\n    if (boxIsAfter(start, x, y, true) && start.top > y)\n      { part = order[index - 1]; }\n  }\n  return part\n}\n\nfunction coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n  // In a wrapped line, rtl text on wrapping boundaries can do things\n  // that don't correspond to the ordering in our `order` array at\n  // all, so a binary search doesn't work, and we want to return a\n  // part that only spans one line so that the binary search in\n  // coordsCharInner is safe. As such, we first find the extent of the\n  // wrapped line, and then do a flat search in which we discard any\n  // spans that aren't on the line.\n  var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n  var begin = ref.begin;\n  var end = ref.end;\n  if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n  var part = null, closestDist = null;\n  for (var i = 0; i < order.length; i++) {\n    var p = order[i];\n    if (p.from >= end || p.to <= begin) { continue }\n    var ltr = p.level != 1;\n    var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n    // Weigh against spans ending before this, so that they are only\n    // picked if nothing ends after\n    var dist = endX < x ? x - endX + 1e9 : endX - x;\n    if (!part || closestDist > dist) {\n      part = p;\n      closestDist = dist;\n    }\n  }\n  if (!part) { part = order[order.length - 1]; }\n  // Clip the part to the wrapped line.\n  if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\n  if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\n  return part\n}\n\nvar measureText;\n// Compute the default text height.\nfunction textHeight(display) {\n  if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n  if (measureText == null) {\n    measureText = elt(\"pre\");\n    // Measure a bunch of lines, for browsers that compute\n    // fractional heights.\n    for (var i = 0; i < 49; ++i) {\n      measureText.appendChild(document.createTextNode(\"x\"));\n      measureText.appendChild(elt(\"br\"));\n    }\n    measureText.appendChild(document.createTextNode(\"x\"));\n  }\n  removeChildrenAndAdd(display.measure, measureText);\n  var height = measureText.offsetHeight / 50;\n  if (height > 3) { display.cachedTextHeight = height; }\n  removeChildren(display.measure);\n  return height || 1\n}\n\n// Compute the default character width.\nfunction charWidth(display) {\n  if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n  var anchor = elt(\"span\", \"xxxxxxxxxx\");\n  var pre = elt(\"pre\", [anchor]);\n  removeChildrenAndAdd(display.measure, pre);\n  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n  if (width > 2) { display.cachedCharWidth = width; }\n  return width || 10\n}\n\n// Do a bulk-read of the DOM positions and sizes needed to draw the\n// view, so that we don't interleave reading and writing to the DOM.\nfunction getDimensions(cm) {\n  var d = cm.display, left = {}, width = {};\n  var gutterLeft = d.gutters.clientLeft;\n  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n    width[cm.options.gutters[i]] = n.clientWidth;\n  }\n  return {fixedPos: compensateForHScroll(d),\n          gutterTotalWidth: d.gutters.offsetWidth,\n          gutterLeft: left,\n          gutterWidth: width,\n          wrapperWidth: d.wrapper.clientWidth}\n}\n\n// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n// but using getBoundingClientRect to get a sub-pixel-accurate\n// result.\nfunction compensateForHScroll(display) {\n  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n}\n\n// Returns a function that estimates the height of a line, to use as\n// first approximation until the line becomes visible (and is thus\n// properly measurable).\nfunction estimateHeight(cm) {\n  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n  return function (line) {\n    if (lineIsHidden(cm.doc, line)) { return 0 }\n\n    var widgetsHeight = 0;\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n    } }\n\n    if (wrapping)\n      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n    else\n      { return widgetsHeight + th }\n  }\n}\n\nfunction estimateLineHeights(cm) {\n  var doc = cm.doc, est = estimateHeight(cm);\n  doc.iter(function (line) {\n    var estHeight = est(line);\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  });\n}\n\n// Given a mouse event, find the corresponding position. If liberal\n// is false, it checks whether a gutter or scrollbar was clicked,\n// and returns null if it was. forRect is used by rectangular\n// selections, and tries to estimate a character position even for\n// coordinates beyond the right of the text.\nfunction posFromMouse(cm, e, liberal, forRect) {\n  var display = cm.display;\n  if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n  var x, y, space = display.lineSpace.getBoundingClientRect();\n  // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n  try { x = e.clientX - space.left; y = e.clientY - space.top; }\n  catch (e) { return null }\n  var coords = coordsChar(cm, x, y), line;\n  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n  }\n  return coords\n}\n\n// Find the view element corresponding to a given line. Return null\n// when the line isn't visible.\nfunction findViewIndex(cm, n) {\n  if (n >= cm.display.viewTo) { return null }\n  n -= cm.display.viewFrom;\n  if (n < 0) { return null }\n  var view = cm.display.view;\n  for (var i = 0; i < view.length; i++) {\n    n -= view[i].size;\n    if (n < 0) { return i }\n  }\n}\n\nfunction updateSelection(cm) {\n  cm.display.input.showSelection(cm.display.input.prepareSelection());\n}\n\nfunction prepareSelection(cm, primary) {\n  if ( primary === void 0 ) primary = true;\n\n  var doc = cm.doc, result = {};\n  var curFragment = result.cursors = document.createDocumentFragment();\n  var selFragment = result.selection = document.createDocumentFragment();\n\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    if (!primary && i == doc.sel.primIndex) { continue }\n    var range$$1 = doc.sel.ranges[i];\n    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\n    var collapsed = range$$1.empty();\n    if (collapsed || cm.options.showCursorWhenSelecting)\n      { drawSelectionCursor(cm, range$$1.head, curFragment); }\n    if (!collapsed)\n      { drawSelectionRange(cm, range$$1, selFragment); }\n  }\n  return result\n}\n\n// Draws a cursor for the given range\nfunction drawSelectionCursor(cm, head, output) {\n  var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n  var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n  cursor.style.left = pos.left + \"px\";\n  cursor.style.top = pos.top + \"px\";\n  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n  if (pos.other) {\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\n    var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n    otherCursor.style.display = \"\";\n    otherCursor.style.left = pos.other.left + \"px\";\n    otherCursor.style.top = pos.other.top + \"px\";\n    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n  }\n}\n\nfunction cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n// Draws the given range as a highlighted selection\nfunction drawSelectionRange(cm, range$$1, output) {\n  var display = cm.display, doc = cm.doc;\n  var fragment = document.createDocumentFragment();\n  var padding = paddingH(cm.display), leftSide = padding.left;\n  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n  var docLTR = doc.direction == \"ltr\";\n\n  function add(left, top, width, bottom) {\n    if (top < 0) { top = 0; }\n    top = Math.round(top);\n    bottom = Math.round(bottom);\n    fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n  }\n\n  function drawForLine(line, fromArg, toArg) {\n    var lineObj = getLine(doc, line);\n    var lineLen = lineObj.text.length;\n    var start, end;\n    function coords(ch, bias) {\n      return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n    }\n\n    function wrapX(pos, dir, side) {\n      var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n      var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\n      var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n      return coords(ch, prop)[prop]\n    }\n\n    var order = getOrder(lineObj, doc.direction);\n    iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n      var ltr = dir == \"ltr\";\n      var fromPos = coords(from, ltr ? \"left\" : \"right\");\n      var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n\n      var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n      var first = i == 0, last = !order || i == order.length - 1;\n      if (toPos.top - fromPos.top <= 3) { // Single line\n        var openLeft = (docLTR ? openStart : openEnd) && first;\n        var openRight = (docLTR ? openEnd : openStart) && last;\n        var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n        var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n        add(left, fromPos.top, right - left, fromPos.bottom);\n      } else { // Multiple lines\n        var topLeft, topRight, botLeft, botRight;\n        if (ltr) {\n          topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n          topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n          botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n          botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n        } else {\n          topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n          topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n          botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n          botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n        }\n        add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n        if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n        add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n      }\n\n      if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\n      if (cmpCoords(toPos, start) < 0) { start = toPos; }\n      if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\n      if (cmpCoords(toPos, end) < 0) { end = toPos; }\n    });\n    return {start: start, end: end}\n  }\n\n  var sFrom = range$$1.from(), sTo = range$$1.to();\n  if (sFrom.line == sTo.line) {\n    drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n  } else {\n    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n    var singleVLine = visualLine(fromLine) == visualLine(toLine);\n    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n    if (singleVLine) {\n      if (leftEnd.top < rightStart.top - 2) {\n        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n      } else {\n        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n      }\n    }\n    if (leftEnd.bottom < rightStart.top)\n      { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n  }\n\n  output.appendChild(fragment);\n}\n\n// Cursor-blinking\nfunction restartBlink(cm) {\n  if (!cm.state.focused) { return }\n  var display = cm.display;\n  clearInterval(display.blinker);\n  var on = true;\n  display.cursorDiv.style.visibility = \"\";\n  if (cm.options.cursorBlinkRate > 0)\n    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\n      cm.options.cursorBlinkRate); }\n  else if (cm.options.cursorBlinkRate < 0)\n    { display.cursorDiv.style.visibility = \"hidden\"; }\n}\n\nfunction ensureFocus(cm) {\n  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n}\n\nfunction delayBlurEvent(cm) {\n  cm.state.delayingBlurEvent = true;\n  setTimeout(function () { if (cm.state.delayingBlurEvent) {\n    cm.state.delayingBlurEvent = false;\n    onBlur(cm);\n  } }, 100);\n}\n\nfunction onFocus(cm, e) {\n  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\n\n  if (cm.options.readOnly == \"nocursor\") { return }\n  if (!cm.state.focused) {\n    signal(cm, \"focus\", cm, e);\n    cm.state.focused = true;\n    addClass(cm.display.wrapper, \"CodeMirror-focused\");\n    // This test prevents this from firing when a context\n    // menu is closed (since the input reset would kill the\n    // select-all detection hack)\n    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n      cm.display.input.reset();\n      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n    }\n    cm.display.input.receivedFocus();\n  }\n  restartBlink(cm);\n}\nfunction onBlur(cm, e) {\n  if (cm.state.delayingBlurEvent) { return }\n\n  if (cm.state.focused) {\n    signal(cm, \"blur\", cm, e);\n    cm.state.focused = false;\n    rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n  }\n  clearInterval(cm.display.blinker);\n  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n}\n\n// Read the actual heights of the rendered lines, and update their\n// stored heights to match.\nfunction updateHeightsInViewport(cm) {\n  var display = cm.display;\n  var prevBottom = display.lineDiv.offsetTop;\n  for (var i = 0; i < display.view.length; i++) {\n    var cur = display.view[i], height = (void 0);\n    if (cur.hidden) { continue }\n    if (ie && ie_version < 8) {\n      var bot = cur.node.offsetTop + cur.node.offsetHeight;\n      height = bot - prevBottom;\n      prevBottom = bot;\n    } else {\n      var box = cur.node.getBoundingClientRect();\n      height = box.bottom - box.top;\n    }\n    var diff = cur.line.height - height;\n    if (height < 2) { height = textHeight(display); }\n    if (diff > .005 || diff < -.005) {\n      updateLineHeight(cur.line, height);\n      updateWidgetHeight(cur.line);\n      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n        { updateWidgetHeight(cur.rest[j]); } }\n    }\n  }\n}\n\n// Read and store the height of line widgets associated with the\n// given line.\nfunction updateWidgetHeight(line) {\n  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)\n    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight; } }\n}\n\n// Compute the lines that are visible in a given viewport (defaults\n// the the current scroll position). viewport may contain top,\n// height, and ensure (see op.scrollToPos) properties.\nfunction visibleLines(display, doc, viewport) {\n  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n  top = Math.floor(top - paddingTop(display));\n  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n  // forces those lines into the viewport (if possible).\n  if (viewport && viewport.ensure) {\n    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n    if (ensureFrom < from) {\n      from = ensureFrom;\n      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n      to = ensureTo;\n    }\n  }\n  return {from: from, to: Math.max(to, from + 1)}\n}\n\n// Re-align line numbers and gutter marks to compensate for\n// horizontal scrolling.\nfunction alignHorizontally(cm) {\n  var display = cm.display, view = display.view;\n  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n  var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n    if (cm.options.fixedGutter) {\n      if (view[i].gutter)\n        { view[i].gutter.style.left = left; }\n      if (view[i].gutterBackground)\n        { view[i].gutterBackground.style.left = left; }\n    }\n    var align = view[i].alignable;\n    if (align) { for (var j = 0; j < align.length; j++)\n      { align[j].style.left = left; } }\n  } }\n  if (cm.options.fixedGutter)\n    { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n}\n\n// Used to ensure that the line number gutter is still the right\n// size for the current document size. Returns true when an update\n// is needed.\nfunction maybeUpdateLineNumberWidth(cm) {\n  if (!cm.options.lineNumbers) { return false }\n  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n  if (last.length != display.lineNumChars) {\n    var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                               \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n    display.lineGutter.style.width = \"\";\n    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n    display.lineNumWidth = display.lineNumInnerWidth + padding;\n    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n    display.lineGutter.style.width = display.lineNumWidth + \"px\";\n    updateGutterSpace(cm);\n    return true\n  }\n  return false\n}\n\n// SCROLLING THINGS INTO VIEW\n\n// If an editor sits on the top or bottom of the window, partially\n// scrolled out of view, this ensures that the cursor is visible.\nfunction maybeScrollWindow(cm, rect) {\n  if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n  if (rect.top + box.top < 0) { doScroll = true; }\n  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n  if (doScroll != null && !phantom) {\n    var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n    cm.display.lineSpace.appendChild(scrollNode);\n    scrollNode.scrollIntoView(doScroll);\n    cm.display.lineSpace.removeChild(scrollNode);\n  }\n}\n\n// Scroll a given position into view (immediately), verifying that\n// it actually became visible (as line heights are accurately\n// measured, the position of something may 'drift' during drawing).\nfunction scrollPosIntoView(cm, pos, end, margin) {\n  if (margin == null) { margin = 0; }\n  var rect;\n  if (!cm.options.lineWrapping && pos == end) {\n    // Set pos and end to the cursor positions around the character pos sticks to\n    // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n    // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n    pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n    end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n  }\n  for (var limit = 0; limit < 5; limit++) {\n    var changed = false;\n    var coords = cursorCoords(cm, pos);\n    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n    rect = {left: Math.min(coords.left, endCoords.left),\n            top: Math.min(coords.top, endCoords.top) - margin,\n            right: Math.max(coords.left, endCoords.left),\n            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n    var scrollPos = calculateScrollPos(cm, rect);\n    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n    if (scrollPos.scrollTop != null) {\n      updateScrollTop(cm, scrollPos.scrollTop);\n      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n    }\n    if (scrollPos.scrollLeft != null) {\n      setScrollLeft(cm, scrollPos.scrollLeft);\n      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n    }\n    if (!changed) { break }\n  }\n  return rect\n}\n\n// Scroll a given set of coordinates into view (immediately).\nfunction scrollIntoView(cm, rect) {\n  var scrollPos = calculateScrollPos(cm, rect);\n  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n}\n\n// Calculate a new scroll position needed to scroll the given\n// rectangle into view. Returns an object with scrollTop and\n// scrollLeft properties. When these are undefined, the\n// vertical/horizontal position does not need to be adjusted.\nfunction calculateScrollPos(cm, rect) {\n  var display = cm.display, snapMargin = textHeight(cm.display);\n  if (rect.top < 0) { rect.top = 0; }\n  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n  var screen = displayHeight(cm), result = {};\n  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n  var docBottom = cm.doc.height + paddingVert(display);\n  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n  if (rect.top < screentop) {\n    result.scrollTop = atTop ? 0 : rect.top;\n  } else if (rect.bottom > screentop + screen) {\n    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n    if (newTop != screentop) { result.scrollTop = newTop; }\n  }\n\n  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n  var tooWide = rect.right - rect.left > screenw;\n  if (tooWide) { rect.right = rect.left + screenw; }\n  if (rect.left < 10)\n    { result.scrollLeft = 0; }\n  else if (rect.left < screenleft)\n    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\n  else if (rect.right > screenw + screenleft - 3)\n    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n  return result\n}\n\n// Store a relative adjustment to the scroll position in the current\n// operation (to be applied when the operation finishes).\nfunction addToScrollTop(cm, top) {\n  if (top == null) { return }\n  resolveScrollToPos(cm);\n  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n}\n\n// Make sure that at the end of the operation the current cursor is\n// shown.\nfunction ensureCursorVisible(cm) {\n  resolveScrollToPos(cm);\n  var cur = cm.getCursor();\n  cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n}\n\nfunction scrollToCoords(cm, x, y) {\n  if (x != null || y != null) { resolveScrollToPos(cm); }\n  if (x != null) { cm.curOp.scrollLeft = x; }\n  if (y != null) { cm.curOp.scrollTop = y; }\n}\n\nfunction scrollToRange(cm, range$$1) {\n  resolveScrollToPos(cm);\n  cm.curOp.scrollToPos = range$$1;\n}\n\n// When an operation has its scrollToPos property set, and another\n// scroll action is applied before the end of the operation, this\n// 'simulates' scrolling that position into view in a cheap way, so\n// that the effect of intermediate scroll commands is not ignored.\nfunction resolveScrollToPos(cm) {\n  var range$$1 = cm.curOp.scrollToPos;\n  if (range$$1) {\n    cm.curOp.scrollToPos = null;\n    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\n    scrollToCoordsRange(cm, from, to, range$$1.margin);\n  }\n}\n\nfunction scrollToCoordsRange(cm, from, to, margin) {\n  var sPos = calculateScrollPos(cm, {\n    left: Math.min(from.left, to.left),\n    top: Math.min(from.top, to.top) - margin,\n    right: Math.max(from.right, to.right),\n    bottom: Math.max(from.bottom, to.bottom) + margin\n  });\n  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n}\n\n// Sync the scrollable area and scrollbars, ensure the viewport\n// covers the visible area.\nfunction updateScrollTop(cm, val) {\n  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n  if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n  setScrollTop(cm, val, true);\n  if (gecko) { updateDisplaySimple(cm); }\n  startWorker(cm, 100);\n}\n\nfunction setScrollTop(cm, val, forceScroll) {\n  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\n  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n  cm.doc.scrollTop = val;\n  cm.display.scrollbars.setScrollTop(val);\n  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n}\n\n// Sync scroller and scrollbar, ensure the gutter elements are\n// aligned.\nfunction setScrollLeft(cm, val, isScroller, forceScroll) {\n  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n  cm.doc.scrollLeft = val;\n  alignHorizontally(cm);\n  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n  cm.display.scrollbars.setScrollLeft(val);\n}\n\n// SCROLLBARS\n\n// Prepare DOM reads needed to update the scrollbars. Done in one\n// shot to minimize update/measure roundtrips.\nfunction measureForScrollbars(cm) {\n  var d = cm.display, gutterW = d.gutters.offsetWidth;\n  var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n  return {\n    clientHeight: d.scroller.clientHeight,\n    viewHeight: d.wrapper.clientHeight,\n    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n    viewWidth: d.wrapper.clientWidth,\n    barLeft: cm.options.fixedGutter ? gutterW : 0,\n    docHeight: docH,\n    scrollHeight: docH + scrollGap(cm) + d.barHeight,\n    nativeBarWidth: d.nativeBarWidth,\n    gutterWidth: gutterW\n  }\n}\n\nvar NativeScrollbars = function(place, scroll, cm) {\n  this.cm = cm;\n  var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n  var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n  place(vert); place(horiz);\n\n  on(vert, \"scroll\", function () {\n    if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n  });\n  on(horiz, \"scroll\", function () {\n    if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n  });\n\n  this.checkedZeroWidth = false;\n  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n};\n\nNativeScrollbars.prototype.update = function (measure) {\n  var needsH = measure.scrollWidth > measure.clientWidth + 1;\n  var needsV = measure.scrollHeight > measure.clientHeight + 1;\n  var sWidth = measure.nativeBarWidth;\n\n  if (needsV) {\n    this.vert.style.display = \"block\";\n    this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n    // A bug in IE8 can cause this value to be negative, so guard it.\n    this.vert.firstChild.style.height =\n      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n  } else {\n    this.vert.style.display = \"\";\n    this.vert.firstChild.style.height = \"0\";\n  }\n\n  if (needsH) {\n    this.horiz.style.display = \"block\";\n    this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n    this.horiz.style.left = measure.barLeft + \"px\";\n    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n    this.horiz.firstChild.style.width =\n      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n  } else {\n    this.horiz.style.display = \"\";\n    this.horiz.firstChild.style.width = \"0\";\n  }\n\n  if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n    if (sWidth == 0) { this.zeroWidthHack(); }\n    this.checkedZeroWidth = true;\n  }\n\n  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n};\n\nNativeScrollbars.prototype.setScrollLeft = function (pos) {\n  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n};\n\nNativeScrollbars.prototype.setScrollTop = function (pos) {\n  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n};\n\nNativeScrollbars.prototype.zeroWidthHack = function () {\n  var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n  this.horiz.style.height = this.vert.style.width = w;\n  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n  this.disableHoriz = new Delayed;\n  this.disableVert = new Delayed;\n};\n\nNativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n  bar.style.pointerEvents = \"auto\";\n  function maybeDisable() {\n    // To find out whether the scrollbar is still visible, we\n    // check whether the element under the pixel in the bottom\n    // right corner of the scrollbar box is the scrollbar box\n    // itself (when the bar is still visible) or its filler child\n    // (when the bar is hidden). If it is still visible, we keep\n    // it enabled, if it's hidden, we disable pointer events.\n    var box = bar.getBoundingClientRect();\n    var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n    if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\n    else { delay.set(1000, maybeDisable); }\n  }\n  delay.set(1000, maybeDisable);\n};\n\nNativeScrollbars.prototype.clear = function () {\n  var parent = this.horiz.parentNode;\n  parent.removeChild(this.horiz);\n  parent.removeChild(this.vert);\n};\n\nvar NullScrollbars = function () {};\n\nNullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\nNullScrollbars.prototype.setScrollLeft = function () {};\nNullScrollbars.prototype.setScrollTop = function () {};\nNullScrollbars.prototype.clear = function () {};\n\nfunction updateScrollbars(cm, measure) {\n  if (!measure) { measure = measureForScrollbars(cm); }\n  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n  updateScrollbarsInner(cm, measure);\n  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n      { updateHeightsInViewport(cm); }\n    updateScrollbarsInner(cm, measureForScrollbars(cm));\n    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n  }\n}\n\n// Re-synchronize the fake scrollbars with the actual size of the\n// content.\nfunction updateScrollbarsInner(cm, measure) {\n  var d = cm.display;\n  var sizes = d.scrollbars.update(measure);\n\n  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n  d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n  if (sizes.right && sizes.bottom) {\n    d.scrollbarFiller.style.display = \"block\";\n    d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n    d.scrollbarFiller.style.width = sizes.right + \"px\";\n  } else { d.scrollbarFiller.style.display = \"\"; }\n  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n    d.gutterFiller.style.display = \"block\";\n    d.gutterFiller.style.height = sizes.bottom + \"px\";\n    d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n  } else { d.gutterFiller.style.display = \"\"; }\n}\n\nvar scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\nfunction initScrollbars(cm) {\n  if (cm.display.scrollbars) {\n    cm.display.scrollbars.clear();\n    if (cm.display.scrollbars.addClass)\n      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n    // Prevent clicks in the scrollbars from killing focus\n    on(node, \"mousedown\", function () {\n      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n    });\n    node.setAttribute(\"cm-not-content\", \"true\");\n  }, function (pos, axis) {\n    if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n    else { updateScrollTop(cm, pos); }\n  }, cm);\n  if (cm.display.scrollbars.addClass)\n    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n}\n\n// Operations are used to wrap a series of changes to the editor\n// state in such a way that each change won't have to update the\n// cursor and display (which would be awkward, slow, and\n// error-prone). Instead, display updates are batched and then all\n// combined and executed at once.\n\nvar nextOpId = 0;\n// Start a new operation.\nfunction startOperation(cm) {\n  cm.curOp = {\n    cm: cm,\n    viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n    startHeight: cm.doc.height, // Used to detect need to update scrollbar\n    forceUpdate: false,      // Used to force a redraw\n    updateInput: null,       // Whether to reset the input textarea\n    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n    changeObjs: null,        // Accumulated changes, for firing change events\n    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n    selectionChanged: false, // Whether the selection needs to be redrawn\n    updateMaxLine: false,    // Set when the widest line needs to be determined anew\n    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n    scrollToPos: null,       // Used to scroll to a specific position\n    focus: false,\n    id: ++nextOpId           // Unique ID\n  };\n  pushOperation(cm.curOp);\n}\n\n// Finish an operation, updating the display and signalling delayed events\nfunction endOperation(cm) {\n  var op = cm.curOp;\n  finishOperation(op, function (group) {\n    for (var i = 0; i < group.ops.length; i++)\n      { group.ops[i].cm.curOp = null; }\n    endOperations(group);\n  });\n}\n\n// The DOM updates done when an operation finishes are batched so\n// that the minimum number of relayouts are required.\nfunction endOperations(group) {\n  var ops = group.ops;\n  for (var i = 0; i < ops.length; i++) // Read DOM\n    { endOperation_R1(ops[i]); }\n  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n    { endOperation_W1(ops[i$1]); }\n  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n    { endOperation_R2(ops[i$2]); }\n  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n    { endOperation_W2(ops[i$3]); }\n  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n    { endOperation_finish(ops[i$4]); }\n}\n\nfunction endOperation_R1(op) {\n  var cm = op.cm, display = cm.display;\n  maybeClipScrollbars(cm);\n  if (op.updateMaxLine) { findMaxLine(cm); }\n\n  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                       op.scrollToPos.to.line >= display.viewTo) ||\n    display.maxLineChanged && cm.options.lineWrapping;\n  op.update = op.mustUpdate &&\n    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n}\n\nfunction endOperation_W1(op) {\n  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n}\n\nfunction endOperation_R2(op) {\n  var cm = op.cm, display = cm.display;\n  if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n  op.barMeasure = measureForScrollbars(cm);\n\n  // If the max line changed since it was last measured, measure it,\n  // and ensure the document's width matches it.\n  // updateDisplay_W2 will use these properties to do the actual resizing\n  if (display.maxLineChanged && !cm.options.lineWrapping) {\n    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n    cm.display.sizerWidth = op.adjustWidthTo;\n    op.barMeasure.scrollWidth =\n      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n  }\n\n  if (op.updatedDisplay || op.selectionChanged)\n    { op.preparedSelection = display.input.prepareSelection(); }\n}\n\nfunction endOperation_W2(op) {\n  var cm = op.cm;\n\n  if (op.adjustWidthTo != null) {\n    cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n    if (op.maxScrollLeft < cm.doc.scrollLeft)\n      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n    cm.display.maxLineChanged = false;\n  }\n\n  var takeFocus = op.focus && op.focus == activeElt();\n  if (op.preparedSelection)\n    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n  if (op.updatedDisplay || op.startHeight != cm.doc.height)\n    { updateScrollbars(cm, op.barMeasure); }\n  if (op.updatedDisplay)\n    { setDocumentHeight(cm, op.barMeasure); }\n\n  if (op.selectionChanged) { restartBlink(cm); }\n\n  if (cm.state.focused && op.updateInput)\n    { cm.display.input.reset(op.typing); }\n  if (takeFocus) { ensureFocus(op.cm); }\n}\n\nfunction endOperation_finish(op) {\n  var cm = op.cm, display = cm.display, doc = cm.doc;\n\n  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n  // Abort mouse wheel delta measurement, when scrolling explicitly\n  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n    { display.wheelStartX = display.wheelStartY = null; }\n\n  // Propagate the scroll position to the actual DOM scroller\n  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n  // If we need to scroll a specific position into view, do so.\n  if (op.scrollToPos) {\n    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n    maybeScrollWindow(cm, rect);\n  }\n\n  // Fire events for markers that are hidden/unidden by editing or\n  // undoing\n  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n  if (hidden) { for (var i = 0; i < hidden.length; ++i)\n    { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n  if (display.wrapper.offsetHeight)\n    { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n  // Fire change events, and delayed event handlers\n  if (op.changeObjs)\n    { signal(cm, \"changes\", cm, op.changeObjs); }\n  if (op.update)\n    { op.update.finish(); }\n}\n\n// Run the given function in an operation\nfunction runInOp(cm, f) {\n  if (cm.curOp) { return f() }\n  startOperation(cm);\n  try { return f() }\n  finally { endOperation(cm); }\n}\n// Wraps a function in an operation. Returns the wrapped function.\nfunction operation(cm, f) {\n  return function() {\n    if (cm.curOp) { return f.apply(cm, arguments) }\n    startOperation(cm);\n    try { return f.apply(cm, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n// Used to add methods to editor and doc instances, wrapping them in\n// operations.\nfunction methodOp(f) {\n  return function() {\n    if (this.curOp) { return f.apply(this, arguments) }\n    startOperation(this);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(this); }\n  }\n}\nfunction docMethodOp(f) {\n  return function() {\n    var cm = this.cm;\n    if (!cm || cm.curOp) { return f.apply(this, arguments) }\n    startOperation(cm);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n\n// Updates the display.view data structure for a given change to the\n// document. From and to are in pre-change coordinates. Lendiff is\n// the amount of lines added or subtracted by the change. This is\n// used for changes that span multiple lines, or change the way\n// lines are divided into visual lines. regLineChange (below)\n// registers single-line changes.\nfunction regChange(cm, from, to, lendiff) {\n  if (from == null) { from = cm.doc.first; }\n  if (to == null) { to = cm.doc.first + cm.doc.size; }\n  if (!lendiff) { lendiff = 0; }\n\n  var display = cm.display;\n  if (lendiff && to < display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers > from))\n    { display.updateLineNumbers = from; }\n\n  cm.curOp.viewChanged = true;\n\n  if (from >= display.viewTo) { // Change after\n    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n      { resetView(cm); }\n  } else if (to <= display.viewFrom) { // Change before\n    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n      resetView(cm);\n    } else {\n      display.viewFrom += lendiff;\n      display.viewTo += lendiff;\n    }\n  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n    resetView(cm);\n  } else if (from <= display.viewFrom) { // Top overlap\n    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cut) {\n      display.view = display.view.slice(cut.index);\n      display.viewFrom = cut.lineN;\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  } else if (to >= display.viewTo) { // Bottom overlap\n    var cut$1 = viewCuttingPoint(cm, from, from, -1);\n    if (cut$1) {\n      display.view = display.view.slice(0, cut$1.index);\n      display.viewTo = cut$1.lineN;\n    } else {\n      resetView(cm);\n    }\n  } else { // Gap in the middle\n    var cutTop = viewCuttingPoint(cm, from, from, -1);\n    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cutTop && cutBot) {\n      display.view = display.view.slice(0, cutTop.index)\n        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n        .concat(display.view.slice(cutBot.index));\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  }\n\n  var ext = display.externalMeasured;\n  if (ext) {\n    if (to < ext.lineN)\n      { ext.lineN += lendiff; }\n    else if (from < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n  }\n}\n\n// Register a change to a single line. Type must be one of \"text\",\n// \"gutter\", \"class\", \"widget\"\nfunction regLineChange(cm, line, type) {\n  cm.curOp.viewChanged = true;\n  var display = cm.display, ext = cm.display.externalMeasured;\n  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n    { display.externalMeasured = null; }\n\n  if (line < display.viewFrom || line >= display.viewTo) { return }\n  var lineView = display.view[findViewIndex(cm, line)];\n  if (lineView.node == null) { return }\n  var arr = lineView.changes || (lineView.changes = []);\n  if (indexOf(arr, type) == -1) { arr.push(type); }\n}\n\n// Clear the view.\nfunction resetView(cm) {\n  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n  cm.display.view = [];\n  cm.display.viewOffset = 0;\n}\n\nfunction viewCuttingPoint(cm, oldN, newN, dir) {\n  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n    { return {index: index, lineN: newN} }\n  var n = cm.display.viewFrom;\n  for (var i = 0; i < index; i++)\n    { n += view[i].size; }\n  if (n != oldN) {\n    if (dir > 0) {\n      if (index == view.length - 1) { return null }\n      diff = (n + view[index].size) - oldN;\n      index++;\n    } else {\n      diff = n - oldN;\n    }\n    oldN += diff; newN += diff;\n  }\n  while (visualLineNo(cm.doc, newN) != newN) {\n    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n    index += dir;\n  }\n  return {index: index, lineN: newN}\n}\n\n// Force the view to cover a given range, adding empty view element\n// or clipping off existing ones as needed.\nfunction adjustView(cm, from, to) {\n  var display = cm.display, view = display.view;\n  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n    display.view = buildViewArray(cm, from, to);\n    display.viewFrom = from;\n  } else {\n    if (display.viewFrom > from)\n      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n    else if (display.viewFrom < from)\n      { display.view = display.view.slice(findViewIndex(cm, from)); }\n    display.viewFrom = from;\n    if (display.viewTo < to)\n      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n    else if (display.viewTo > to)\n      { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n  }\n  display.viewTo = to;\n}\n\n// Count the number of lines in the view whose DOM representation is\n// out of date (or nonexistent).\nfunction countDirtyView(cm) {\n  var view = cm.display.view, dirty = 0;\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n  }\n  return dirty\n}\n\n// HIGHLIGHT WORKER\n\nfunction startWorker(cm, time) {\n  if (cm.doc.highlightFrontier < cm.display.viewTo)\n    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n}\n\nfunction highlightWorker(cm) {\n  var doc = cm.doc;\n  if (doc.highlightFrontier >= cm.display.viewTo) { return }\n  var end = +new Date + cm.options.workTime;\n  var context = getContextBefore(cm, doc.highlightFrontier);\n  var changedLines = [];\n\n  doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n    if (context.line >= cm.display.viewFrom) { // Visible\n      var oldStyles = line.styles;\n      var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n      var highlighted = highlightLine(cm, line, context, true);\n      if (resetState) { context.state = resetState; }\n      line.styles = highlighted.styles;\n      var oldCls = line.styleClasses, newCls = highlighted.classes;\n      if (newCls) { line.styleClasses = newCls; }\n      else if (oldCls) { line.styleClasses = null; }\n      var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n      if (ischange) { changedLines.push(context.line); }\n      line.stateAfter = context.save();\n      context.nextLine();\n    } else {\n      if (line.text.length <= cm.options.maxHighlightLength)\n        { processLine(cm, line.text, context); }\n      line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n      context.nextLine();\n    }\n    if (+new Date > end) {\n      startWorker(cm, cm.options.workDelay);\n      return true\n    }\n  });\n  doc.highlightFrontier = context.line;\n  doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n  if (changedLines.length) { runInOp(cm, function () {\n    for (var i = 0; i < changedLines.length; i++)\n      { regLineChange(cm, changedLines[i], \"text\"); }\n  }); }\n}\n\n// DISPLAY DRAWING\n\nvar DisplayUpdate = function(cm, viewport, force) {\n  var display = cm.display;\n\n  this.viewport = viewport;\n  // Store some values that we'll need later (but don't want to force a relayout for)\n  this.visible = visibleLines(display, cm.doc, viewport);\n  this.editorIsHidden = !display.wrapper.offsetWidth;\n  this.wrapperHeight = display.wrapper.clientHeight;\n  this.wrapperWidth = display.wrapper.clientWidth;\n  this.oldDisplayWidth = displayWidth(cm);\n  this.force = force;\n  this.dims = getDimensions(cm);\n  this.events = [];\n};\n\nDisplayUpdate.prototype.signal = function (emitter, type) {\n  if (hasHandler(emitter, type))\n    { this.events.push(arguments); }\n};\nDisplayUpdate.prototype.finish = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.events.length; i++)\n    { signal.apply(null, this$1.events[i]); }\n};\n\nfunction maybeClipScrollbars(cm) {\n  var display = cm.display;\n  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n    display.heightForcer.style.height = scrollGap(cm) + \"px\";\n    display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n    display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n    display.scrollbarsClipped = true;\n  }\n}\n\nfunction selectionSnapshot(cm) {\n  if (cm.hasFocus()) { return null }\n  var active = activeElt();\n  if (!active || !contains(cm.display.lineDiv, active)) { return null }\n  var result = {activeElt: active};\n  if (window.getSelection) {\n    var sel = window.getSelection();\n    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n      result.anchorNode = sel.anchorNode;\n      result.anchorOffset = sel.anchorOffset;\n      result.focusNode = sel.focusNode;\n      result.focusOffset = sel.focusOffset;\n    }\n  }\n  return result\n}\n\nfunction restoreSelection(snapshot) {\n  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n  snapshot.activeElt.focus();\n  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n    var sel = window.getSelection(), range$$1 = document.createRange();\n    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n    range$$1.collapse(false);\n    sel.removeAllRanges();\n    sel.addRange(range$$1);\n    sel.extend(snapshot.focusNode, snapshot.focusOffset);\n  }\n}\n\n// Does the actual updating of the line display. Bails out\n// (returning false) when there is nothing to be done and forced is\n// false.\nfunction updateDisplayIfNeeded(cm, update) {\n  var display = cm.display, doc = cm.doc;\n\n  if (update.editorIsHidden) {\n    resetView(cm);\n    return false\n  }\n\n  // Bail out if the visible area is already rendered and nothing changed.\n  if (!update.force &&\n      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n      display.renderedView == display.view && countDirtyView(cm) == 0)\n    { return false }\n\n  if (maybeUpdateLineNumberWidth(cm)) {\n    resetView(cm);\n    update.dims = getDimensions(cm);\n  }\n\n  // Compute a suitable new viewport (from & to)\n  var end = doc.first + doc.size;\n  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n  if (sawCollapsedSpans) {\n    from = visualLineNo(cm.doc, from);\n    to = visualLineEndNo(cm.doc, to);\n  }\n\n  var different = from != display.viewFrom || to != display.viewTo ||\n    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n  adjustView(cm, from, to);\n\n  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n  // Position the mover div to align with the current scroll position\n  cm.display.mover.style.top = display.viewOffset + \"px\";\n\n  var toUpdate = countDirtyView(cm);\n  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n    { return false }\n\n  // For big changes, we hide the enclosing element during the\n  // update, since that speeds up the operations on most browsers.\n  var selSnapshot = selectionSnapshot(cm);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n  patchDisplay(cm, display.updateLineNumbers, update.dims);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n  display.renderedView = display.view;\n  // There might have been a widget with a focused element that got\n  // hidden or updated, if so re-focus it.\n  restoreSelection(selSnapshot);\n\n  // Prevent selection and cursors from interfering with the scroll\n  // width and height.\n  removeChildren(display.cursorDiv);\n  removeChildren(display.selectionDiv);\n  display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n  if (different) {\n    display.lastWrapHeight = update.wrapperHeight;\n    display.lastWrapWidth = update.wrapperWidth;\n    startWorker(cm, 400);\n  }\n\n  display.updateLineNumbers = null;\n\n  return true\n}\n\nfunction postUpdateDisplay(cm, update) {\n  var viewport = update.viewport;\n\n  for (var first = true;; first = false) {\n    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n      // Clip forced viewport to actual scrollable area.\n      if (viewport && viewport.top != null)\n        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n      // Updated line heights might result in the drawn area not\n      // actually covering the viewport. Keep looping until it does.\n      update.visible = visibleLines(cm.display, cm.doc, viewport);\n      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n        { break }\n    }\n    if (!updateDisplayIfNeeded(cm, update)) { break }\n    updateHeightsInViewport(cm);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n    update.force = false;\n  }\n\n  update.signal(cm, \"update\", cm);\n  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n    update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n  }\n}\n\nfunction updateDisplaySimple(cm, viewport) {\n  var update = new DisplayUpdate(cm, viewport);\n  if (updateDisplayIfNeeded(cm, update)) {\n    updateHeightsInViewport(cm);\n    postUpdateDisplay(cm, update);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n    update.finish();\n  }\n}\n\n// Sync the actual display DOM structure with display.view, removing\n// nodes for lines that are no longer in view, and creating the ones\n// that are not there yet, and updating the ones that are out of\n// date.\nfunction patchDisplay(cm, updateNumbersFrom, dims) {\n  var display = cm.display, lineNumbers = cm.options.lineNumbers;\n  var container = display.lineDiv, cur = container.firstChild;\n\n  function rm(node) {\n    var next = node.nextSibling;\n    // Works around a throw-scroll bug in OS X Webkit\n    if (webkit && mac && cm.display.currentWheelTarget == node)\n      { node.style.display = \"none\"; }\n    else\n      { node.parentNode.removeChild(node); }\n    return next\n  }\n\n  var view = display.view, lineN = display.viewFrom;\n  // Loop over the elements in the view, syncing cur (the DOM nodes\n  // in display.lineDiv) with the view as we go.\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (lineView.hidden) {\n    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n      var node = buildLineElement(cm, lineView, lineN, dims);\n      container.insertBefore(node, cur);\n    } else { // Already drawn\n      while (cur != lineView.node) { cur = rm(cur); }\n      var updateNumber = lineNumbers && updateNumbersFrom != null &&\n        updateNumbersFrom <= lineN && lineView.lineNumber;\n      if (lineView.changes) {\n        if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n        updateLineForChanges(cm, lineView, lineN, dims);\n      }\n      if (updateNumber) {\n        removeChildren(lineView.lineNumber);\n        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n      }\n      cur = lineView.node.nextSibling;\n    }\n    lineN += lineView.size;\n  }\n  while (cur) { cur = rm(cur); }\n}\n\nfunction updateGutterSpace(cm) {\n  var width = cm.display.gutters.offsetWidth;\n  cm.display.sizer.style.marginLeft = width + \"px\";\n}\n\nfunction setDocumentHeight(cm, measure) {\n  cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n  cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n}\n\n// Rebuild the gutter elements, ensure the margin to the left of the\n// code matches their width.\nfunction updateGutters(cm) {\n  var gutters = cm.display.gutters, specs = cm.options.gutters;\n  removeChildren(gutters);\n  var i = 0;\n  for (; i < specs.length; ++i) {\n    var gutterClass = specs[i];\n    var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n    if (gutterClass == \"CodeMirror-linenumbers\") {\n      cm.display.lineGutter = gElt;\n      gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n    }\n  }\n  gutters.style.display = i ? \"\" : \"none\";\n  updateGutterSpace(cm);\n}\n\n// Make sure the gutters options contains the element\n// \"CodeMirror-linenumbers\" when the lineNumbers option is true.\nfunction setGuttersForLineNumbers(options) {\n  var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n  if (found == -1 && options.lineNumbers) {\n    options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n  } else if (found > -1 && !options.lineNumbers) {\n    options.gutters = options.gutters.slice(0);\n    options.gutters.splice(found, 1);\n  }\n}\n\n// Since the delta values reported on mouse wheel events are\n// unstandardized between browsers and even browser versions, and\n// generally horribly unpredictable, this code starts by measuring\n// the scroll effect that the first few mouse wheel events have,\n// and, from that, detects the way it can convert deltas to pixel\n// offsets afterwards.\n//\n// The reason we want to know the amount a wheel event will scroll\n// is that it gives us a chance to update the display before the\n// actual scrolling happens, reducing flickering.\n\nvar wheelSamples = 0;\nvar wheelPixelsPerUnit = null;\n// Fill in a browser-detected starting value on browsers where we\n// know one. These don't have to be accurate -- the result of them\n// being wrong would just be a slight flicker on the first wheel\n// scroll (if it is large enough).\nif (ie) { wheelPixelsPerUnit = -.53; }\nelse if (gecko) { wheelPixelsPerUnit = 15; }\nelse if (chrome) { wheelPixelsPerUnit = -.7; }\nelse if (safari) { wheelPixelsPerUnit = -1/3; }\n\nfunction wheelEventDelta(e) {\n  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n  else if (dy == null) { dy = e.wheelDelta; }\n  return {x: dx, y: dy}\n}\nfunction wheelEventPixels(e) {\n  var delta = wheelEventDelta(e);\n  delta.x *= wheelPixelsPerUnit;\n  delta.y *= wheelPixelsPerUnit;\n  return delta\n}\n\nfunction onScrollWheel(cm, e) {\n  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n  var display = cm.display, scroll = display.scroller;\n  // Quit if there's nothing to scroll here\n  var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n  var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n  if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n  // Webkit browsers on OS X abort momentum scrolls when the target\n  // of the scroll event is removed from the scrollable element.\n  // This hack (see related code in patchDisplay) makes sure the\n  // element is kept around.\n  if (dy && mac && webkit) {\n    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n      for (var i = 0; i < view.length; i++) {\n        if (view[i].node == cur) {\n          cm.display.currentWheelTarget = cur;\n          break outer\n        }\n      }\n    }\n  }\n\n  // On some browsers, horizontal scrolling will cause redraws to\n  // happen before the gutter has been realigned, causing it to\n  // wriggle around in a most unseemly way. When we have an\n  // estimated pixels/delta value, we just handle horizontal\n  // scrolling entirely here. It'll be slightly off from native, but\n  // better than glitching out.\n  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n    if (dy && canScrollY)\n      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n    // Only prevent default scrolling if vertical scrolling is\n    // actually possible. Otherwise, it causes vertical scroll\n    // jitter on OSX trackpads when deltaX is small and deltaY\n    // is large (issue #3579)\n    if (!dy || (dy && canScrollY))\n      { e_preventDefault(e); }\n    display.wheelStartX = null; // Abort measurement, if in progress\n    return\n  }\n\n  // 'Project' the visible viewport to cover the area that is being\n  // scrolled into view (if we know enough to estimate it).\n  if (dy && wheelPixelsPerUnit != null) {\n    var pixels = dy * wheelPixelsPerUnit;\n    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n    updateDisplaySimple(cm, {top: top, bottom: bot});\n  }\n\n  if (wheelSamples < 20) {\n    if (display.wheelStartX == null) {\n      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n      display.wheelDX = dx; display.wheelDY = dy;\n      setTimeout(function () {\n        if (display.wheelStartX == null) { return }\n        var movedX = scroll.scrollLeft - display.wheelStartX;\n        var movedY = scroll.scrollTop - display.wheelStartY;\n        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n          (movedX && display.wheelDX && movedX / display.wheelDX);\n        display.wheelStartX = display.wheelStartY = null;\n        if (!sample) { return }\n        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n        ++wheelSamples;\n      }, 200);\n    } else {\n      display.wheelDX += dx; display.wheelDY += dy;\n    }\n  }\n}\n\n// Selection objects are immutable. A new one is created every time\n// the selection changes. A selection is one or more non-overlapping\n// (and non-touching) ranges, sorted, and an integer that indicates\n// which one is the primary selection (the one that's scrolled into\n// view, that getCursor returns, etc).\nvar Selection = function(ranges, primIndex) {\n  this.ranges = ranges;\n  this.primIndex = primIndex;\n};\n\nSelection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\nSelection.prototype.equals = function (other) {\n    var this$1 = this;\n\n  if (other == this) { return true }\n  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var here = this$1.ranges[i], there = other.ranges[i];\n    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n  }\n  return true\n};\n\nSelection.prototype.deepCopy = function () {\n    var this$1 = this;\n\n  var out = [];\n  for (var i = 0; i < this.ranges.length; i++)\n    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\n  return new Selection(out, this.primIndex)\n};\n\nSelection.prototype.somethingSelected = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.ranges.length; i++)\n    { if (!this$1.ranges[i].empty()) { return true } }\n  return false\n};\n\nSelection.prototype.contains = function (pos, end) {\n    var this$1 = this;\n\n  if (!end) { end = pos; }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var range = this$1.ranges[i];\n    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n      { return i }\n  }\n  return -1\n};\n\nvar Range = function(anchor, head) {\n  this.anchor = anchor; this.head = head;\n};\n\nRange.prototype.from = function () { return minPos(this.anchor, this.head) };\nRange.prototype.to = function () { return maxPos(this.anchor, this.head) };\nRange.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n// Take an unsorted, potentially overlapping set of ranges, and\n// build a selection out of it. 'Consumes' ranges array (modifying\n// it).\nfunction normalizeSelection(ranges, primIndex) {\n  var prim = ranges[primIndex];\n  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n  primIndex = indexOf(ranges, prim);\n  for (var i = 1; i < ranges.length; i++) {\n    var cur = ranges[i], prev = ranges[i - 1];\n    if (cmp(prev.to(), cur.from()) >= 0) {\n      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n      if (i <= primIndex) { --primIndex; }\n      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n    }\n  }\n  return new Selection(ranges, primIndex)\n}\n\nfunction simpleSelection(anchor, head) {\n  return new Selection([new Range(anchor, head || anchor)], 0)\n}\n\n// Compute the position of the end of a change (its 'to' property\n// refers to the pre-change end).\nfunction changeEnd(change) {\n  if (!change.text) { return change.to }\n  return Pos(change.from.line + change.text.length - 1,\n             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n}\n\n// Adjust a position to refer to the post-change position of the\n// same text, or the end of the change if the change covers it.\nfunction adjustForChange(pos, change) {\n  if (cmp(pos, change.from) < 0) { return pos }\n  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n  return Pos(line, ch)\n}\n\nfunction computeSelAfterChange(doc, change) {\n  var out = [];\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    var range = doc.sel.ranges[i];\n    out.push(new Range(adjustForChange(range.anchor, change),\n                       adjustForChange(range.head, change)));\n  }\n  return normalizeSelection(out, doc.sel.primIndex)\n}\n\nfunction offsetPos(pos, old, nw) {\n  if (pos.line == old.line)\n    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n  else\n    { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n}\n\n// Used by replaceSelections to allow moving the selection to the\n// start or around the replaced test. Hint may be \"start\" or \"around\".\nfunction computeReplacedSel(doc, changes, hint) {\n  var out = [];\n  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n    var from = offsetPos(change.from, oldPrev, newPrev);\n    var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n    oldPrev = change.to;\n    newPrev = to;\n    if (hint == \"around\") {\n      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n      out[i] = new Range(inv ? to : from, inv ? from : to);\n    } else {\n      out[i] = new Range(from, from);\n    }\n  }\n  return new Selection(out, doc.sel.primIndex)\n}\n\n// Used to get the editor into a consistent state again when options change.\n\nfunction loadMode(cm) {\n  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n  resetModeState(cm);\n}\n\nfunction resetModeState(cm) {\n  cm.doc.iter(function (line) {\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n  });\n  cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n  startWorker(cm, 100);\n  cm.state.modeGen++;\n  if (cm.curOp) { regChange(cm); }\n}\n\n// DOCUMENT DATA STRUCTURE\n\n// By default, updates that start and end at the beginning of a line\n// are treated specially, in order to make the association of line\n// widgets and marker elements with the text behave more intuitive.\nfunction isWholeLineUpdate(doc, change) {\n  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n}\n\n// Perform a change on the document data structure.\nfunction updateDoc(doc, change, markedSpans, estimateHeight$$1) {\n  function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n  function update(line, text, spans) {\n    updateLine(line, text, spans, estimateHeight$$1);\n    signalLater(line, \"change\", line, change);\n  }\n  function linesFor(start, end) {\n    var result = [];\n    for (var i = start; i < end; ++i)\n      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\n    return result\n  }\n\n  var from = change.from, to = change.to, text = change.text;\n  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n  // Adjust the line structure\n  if (change.full) {\n    doc.insert(0, linesFor(0, text.length));\n    doc.remove(text.length, doc.size - text.length);\n  } else if (isWholeLineUpdate(doc, change)) {\n    // This is a whole-line replace. Treated specially to make\n    // sure line objects move the way they are supposed to.\n    var added = linesFor(0, text.length - 1);\n    update(lastLine, lastLine.text, lastSpans);\n    if (nlines) { doc.remove(from.line, nlines); }\n    if (added.length) { doc.insert(from.line, added); }\n  } else if (firstLine == lastLine) {\n    if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n    } else {\n      var added$1 = linesFor(1, text.length - 1);\n      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      doc.insert(from.line + 1, added$1);\n    }\n  } else if (text.length == 1) {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n    doc.remove(from.line + 1, nlines);\n  } else {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n    var added$2 = linesFor(1, text.length - 1);\n    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n    doc.insert(from.line + 1, added$2);\n  }\n\n  signalLater(doc, \"change\", doc, change);\n}\n\n// Call f for all linked documents.\nfunction linkedDocs(doc, f, sharedHistOnly) {\n  function propagate(doc, skip, sharedHist) {\n    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n      var rel = doc.linked[i];\n      if (rel.doc == skip) { continue }\n      var shared = sharedHist && rel.sharedHist;\n      if (sharedHistOnly && !shared) { continue }\n      f(rel.doc, shared);\n      propagate(rel.doc, doc, shared);\n    } }\n  }\n  propagate(doc, null, true);\n}\n\n// Attach a document to an editor.\nfunction attachDoc(cm, doc) {\n  if (doc.cm) { throw new Error(\"This document is already in use.\") }\n  cm.doc = doc;\n  doc.cm = cm;\n  estimateLineHeights(cm);\n  loadMode(cm);\n  setDirectionClass(cm);\n  if (!cm.options.lineWrapping) { findMaxLine(cm); }\n  cm.options.mode = doc.modeOption;\n  regChange(cm);\n}\n\nfunction setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n}\n\nfunction directionChanged(cm) {\n  runInOp(cm, function () {\n    setDirectionClass(cm);\n    regChange(cm);\n  });\n}\n\nfunction History(startGen) {\n  // Arrays of change events and selections. Doing something adds an\n  // event to done and clears undo. Undoing moves events from done\n  // to undone, redoing moves them in the other direction.\n  this.done = []; this.undone = [];\n  this.undoDepth = Infinity;\n  // Used to track when changes can be merged into a single undo\n  // event\n  this.lastModTime = this.lastSelTime = 0;\n  this.lastOp = this.lastSelOp = null;\n  this.lastOrigin = this.lastSelOrigin = null;\n  // Used by the isClean() method\n  this.generation = this.maxGeneration = startGen || 1;\n}\n\n// Create a history change event from an updateDoc-style change\n// object.\nfunction historyChangeFromChange(doc, change) {\n  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n  return histChange\n}\n\n// Pop all selection events off the end of a history array. Stop at\n// a change event.\nfunction clearSelectionEvents(array) {\n  while (array.length) {\n    var last = lst(array);\n    if (last.ranges) { array.pop(); }\n    else { break }\n  }\n}\n\n// Find the top change event in the history. Pop off selection\n// events that are in the way.\nfunction lastChangeEvent(hist, force) {\n  if (force) {\n    clearSelectionEvents(hist.done);\n    return lst(hist.done)\n  } else if (hist.done.length && !lst(hist.done).ranges) {\n    return lst(hist.done)\n  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n    hist.done.pop();\n    return lst(hist.done)\n  }\n}\n\n// Register a change in the history. Merges changes that are within\n// a single operation, or are close together with an origin that\n// allows merging (starting with \"+\") into a single event.\nfunction addChangeToHistory(doc, change, selAfter, opId) {\n  var hist = doc.history;\n  hist.undone.length = 0;\n  var time = +new Date, cur;\n  var last;\n\n  if ((hist.lastOp == opId ||\n       hist.lastOrigin == change.origin && change.origin &&\n       ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n        change.origin.charAt(0) == \"*\")) &&\n      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n    // Merge this change into the last event\n    last = lst(cur.changes);\n    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n      // Optimized case for simple insertion -- don't want to add\n      // new changesets for every character typed\n      last.to = changeEnd(change);\n    } else {\n      // Add new sub-event\n      cur.changes.push(historyChangeFromChange(doc, change));\n    }\n  } else {\n    // Can not be merged, start a new event.\n    var before = lst(hist.done);\n    if (!before || !before.ranges)\n      { pushSelectionToHistory(doc.sel, hist.done); }\n    cur = {changes: [historyChangeFromChange(doc, change)],\n           generation: hist.generation};\n    hist.done.push(cur);\n    while (hist.done.length > hist.undoDepth) {\n      hist.done.shift();\n      if (!hist.done[0].ranges) { hist.done.shift(); }\n    }\n  }\n  hist.done.push(selAfter);\n  hist.generation = ++hist.maxGeneration;\n  hist.lastModTime = hist.lastSelTime = time;\n  hist.lastOp = hist.lastSelOp = opId;\n  hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n  if (!last) { signal(doc, \"historyAdded\"); }\n}\n\nfunction selectionEventCanBeMerged(doc, origin, prev, sel) {\n  var ch = origin.charAt(0);\n  return ch == \"*\" ||\n    ch == \"+\" &&\n    prev.ranges.length == sel.ranges.length &&\n    prev.somethingSelected() == sel.somethingSelected() &&\n    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n}\n\n// Called whenever the selection changes, sets the new selection as\n// the pending selection in the history, and pushes the old pending\n// selection into the 'done' array when it was significantly\n// different (in number of selected ranges, emptiness, or time).\nfunction addSelectionToHistory(doc, sel, opId, options) {\n  var hist = doc.history, origin = options && options.origin;\n\n  // A new event is started when the previous origin does not match\n  // the current, or the origins don't allow matching. Origins\n  // starting with * are always merged, those starting with + are\n  // merged when similar and close together in time.\n  if (opId == hist.lastSelOp ||\n      (origin && hist.lastSelOrigin == origin &&\n       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n    { hist.done[hist.done.length - 1] = sel; }\n  else\n    { pushSelectionToHistory(sel, hist.done); }\n\n  hist.lastSelTime = +new Date;\n  hist.lastSelOrigin = origin;\n  hist.lastSelOp = opId;\n  if (options && options.clearRedo !== false)\n    { clearSelectionEvents(hist.undone); }\n}\n\nfunction pushSelectionToHistory(sel, dest) {\n  var top = lst(dest);\n  if (!(top && top.ranges && top.equals(sel)))\n    { dest.push(sel); }\n}\n\n// Used to store marked span information in the history.\nfunction attachLocalSpans(doc, change, from, to) {\n  var existing = change[\"spans_\" + doc.id], n = 0;\n  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n    if (line.markedSpans)\n      { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n    ++n;\n  });\n}\n\n// When un/re-doing restores text containing marked spans, those\n// that have been explicitly cleared should not be restored.\nfunction removeClearedSpans(spans) {\n  if (!spans) { return null }\n  var out;\n  for (var i = 0; i < spans.length; ++i) {\n    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n    else if (out) { out.push(spans[i]); }\n  }\n  return !out ? spans : out.length ? out : null\n}\n\n// Retrieve and filter the old marked spans stored in a change event.\nfunction getOldSpans(doc, change) {\n  var found = change[\"spans_\" + doc.id];\n  if (!found) { return null }\n  var nw = [];\n  for (var i = 0; i < change.text.length; ++i)\n    { nw.push(removeClearedSpans(found[i])); }\n  return nw\n}\n\n// Used for un/re-doing changes from the history. Combines the\n// result of computing the existing spans with the set of spans that\n// existed in the history (so that deleting around a span and then\n// undoing brings back the span).\nfunction mergeOldSpans(doc, change) {\n  var old = getOldSpans(doc, change);\n  var stretched = stretchSpansOverChange(doc, change);\n  if (!old) { return stretched }\n  if (!stretched) { return old }\n\n  for (var i = 0; i < old.length; ++i) {\n    var oldCur = old[i], stretchCur = stretched[i];\n    if (oldCur && stretchCur) {\n      spans: for (var j = 0; j < stretchCur.length; ++j) {\n        var span = stretchCur[j];\n        for (var k = 0; k < oldCur.length; ++k)\n          { if (oldCur[k].marker == span.marker) { continue spans } }\n        oldCur.push(span);\n      }\n    } else if (stretchCur) {\n      old[i] = stretchCur;\n    }\n  }\n  return old\n}\n\n// Used both to provide a JSON-safe object in .getHistory, and, when\n// detaching a document, to split the history in two\nfunction copyHistoryArray(events, newGroup, instantiateSel) {\n  var copy = [];\n  for (var i = 0; i < events.length; ++i) {\n    var event = events[i];\n    if (event.ranges) {\n      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n      continue\n    }\n    var changes = event.changes, newChanges = [];\n    copy.push({changes: newChanges});\n    for (var j = 0; j < changes.length; ++j) {\n      var change = changes[j], m = (void 0);\n      newChanges.push({from: change.from, to: change.to, text: change.text});\n      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n        if (indexOf(newGroup, Number(m[1])) > -1) {\n          lst(newChanges)[prop] = change[prop];\n          delete change[prop];\n        }\n      } } }\n    }\n  }\n  return copy\n}\n\n// The 'scroll' parameter given to many of these indicated whether\n// the new cursor position should be scrolled into view after\n// modifying the selection.\n\n// If shift is held or the extend flag is set, extends a range to\n// include a given position (and optionally a second position).\n// Otherwise, simply returns the range between the given positions.\n// Used for cursor motion and such.\nfunction extendRange(range, head, other, extend) {\n  if (extend) {\n    var anchor = range.anchor;\n    if (other) {\n      var posBefore = cmp(head, anchor) < 0;\n      if (posBefore != (cmp(other, anchor) < 0)) {\n        anchor = head;\n        head = other;\n      } else if (posBefore != (cmp(head, other) < 0)) {\n        head = other;\n      }\n    }\n    return new Range(anchor, head)\n  } else {\n    return new Range(other || head, head)\n  }\n}\n\n// Extend the primary selection range, discard the rest.\nfunction extendSelection(doc, head, other, options, extend) {\n  if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n  setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n}\n\n// Extend all selections (pos is an array of selections with length\n// equal the number of selections)\nfunction extendSelections(doc, heads, options) {\n  var out = [];\n  var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n  for (var i = 0; i < doc.sel.ranges.length; i++)\n    { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n  var newSel = normalizeSelection(out, doc.sel.primIndex);\n  setSelection(doc, newSel, options);\n}\n\n// Updates a single range in the selection.\nfunction replaceOneSelection(doc, i, range, options) {\n  var ranges = doc.sel.ranges.slice(0);\n  ranges[i] = range;\n  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n}\n\n// Reset the selection to a single range.\nfunction setSimpleSelection(doc, anchor, head, options) {\n  setSelection(doc, simpleSelection(anchor, head), options);\n}\n\n// Give beforeSelectionChange handlers a change to influence a\n// selection update.\nfunction filterSelectionChange(doc, sel, options) {\n  var obj = {\n    ranges: sel.ranges,\n    update: function(ranges) {\n      var this$1 = this;\n\n      this.ranges = [];\n      for (var i = 0; i < ranges.length; i++)\n        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                   clipPos(doc, ranges[i].head)); }\n    },\n    origin: options && options.origin\n  };\n  signal(doc, \"beforeSelectionChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }\n  else { return sel }\n}\n\nfunction setSelectionReplaceHistory(doc, sel, options) {\n  var done = doc.history.done, last = lst(done);\n  if (last && last.ranges) {\n    done[done.length - 1] = sel;\n    setSelectionNoUndo(doc, sel, options);\n  } else {\n    setSelection(doc, sel, options);\n  }\n}\n\n// Set a new selection.\nfunction setSelection(doc, sel, options) {\n  setSelectionNoUndo(doc, sel, options);\n  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n}\n\nfunction setSelectionNoUndo(doc, sel, options) {\n  if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n    { sel = filterSelectionChange(doc, sel, options); }\n\n  var bias = options && options.bias ||\n    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n  if (!(options && options.scroll === false) && doc.cm)\n    { ensureCursorVisible(doc.cm); }\n}\n\nfunction setSelectionInner(doc, sel) {\n  if (sel.equals(doc.sel)) { return }\n\n  doc.sel = sel;\n\n  if (doc.cm) {\n    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n    signalCursorActivity(doc.cm);\n  }\n  signalLater(doc, \"cursorActivity\", doc);\n}\n\n// Verify that the selection does not partially select any atomic\n// marked ranges.\nfunction reCheckSelection(doc) {\n  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n}\n\n// Return a selection that does not partially select any atomic\n// ranges.\nfunction skipAtomicInSelection(doc, sel, bias, mayClear) {\n  var out;\n  for (var i = 0; i < sel.ranges.length; i++) {\n    var range = sel.ranges[i];\n    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n    if (out || newAnchor != range.anchor || newHead != range.head) {\n      if (!out) { out = sel.ranges.slice(0, i); }\n      out[i] = new Range(newAnchor, newHead);\n    }\n  }\n  return out ? normalizeSelection(out, sel.primIndex) : sel\n}\n\nfunction skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n  var line = getLine(doc, pos.line);\n  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n    var sp = line.markedSpans[i], m = sp.marker;\n    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n      if (mayClear) {\n        signal(m, \"beforeCursorEnter\");\n        if (m.explicitlyCleared) {\n          if (!line.markedSpans) { break }\n          else {--i; continue}\n        }\n      }\n      if (!m.atomic) { continue }\n\n      if (oldPos) {\n        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\n          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n          { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n      }\n\n      var far = m.find(dir < 0 ? -1 : 1);\n      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\n        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n    }\n  } }\n  return pos\n}\n\n// Ensure a given position is not inside an atomic range.\nfunction skipAtomic(doc, pos, oldPos, bias, mayClear) {\n  var dir = bias || 1;\n  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n  if (!found) {\n    doc.cantEdit = true;\n    return Pos(doc.first, 0)\n  }\n  return found\n}\n\nfunction movePos(doc, pos, dir, line) {\n  if (dir < 0 && pos.ch == 0) {\n    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n    else { return null }\n  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n    else { return null }\n  } else {\n    return new Pos(pos.line, pos.ch + dir)\n  }\n}\n\nfunction selectAll(cm) {\n  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n}\n\n// UPDATING\n\n// Allow \"beforeChange\" event handlers to influence a change\nfunction filterChange(doc, change, update) {\n  var obj = {\n    canceled: false,\n    from: change.from,\n    to: change.to,\n    text: change.text,\n    origin: change.origin,\n    cancel: function () { return obj.canceled = true; }\n  };\n  if (update) { obj.update = function (from, to, text, origin) {\n    if (from) { obj.from = clipPos(doc, from); }\n    if (to) { obj.to = clipPos(doc, to); }\n    if (text) { obj.text = text; }\n    if (origin !== undefined) { obj.origin = origin; }\n  }; }\n  signal(doc, \"beforeChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n  if (obj.canceled) { return null }\n  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n}\n\n// Apply a change to a document, and add it to the document's\n// history, and propagating it to all linked documents.\nfunction makeChange(doc, change, ignoreReadOnly) {\n  if (doc.cm) {\n    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n    if (doc.cm.state.suppressEdits) { return }\n  }\n\n  if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n    change = filterChange(doc, change, true);\n    if (!change) { return }\n  }\n\n  // Possibly split or suppress the update based on the presence\n  // of read-only spans in its range.\n  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n  if (split) {\n    for (var i = split.length - 1; i >= 0; --i)\n      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\n  } else {\n    makeChangeInner(doc, change);\n  }\n}\n\nfunction makeChangeInner(doc, change) {\n  if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n  var selAfter = computeSelAfterChange(doc, change);\n  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n  var rebased = [];\n\n  linkedDocs(doc, function (doc, sharedHist) {\n    if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n      rebaseHist(doc.history, change);\n      rebased.push(doc.history);\n    }\n    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n  });\n}\n\n// Revert a change stored in a document's history.\nfunction makeChangeFromHistory(doc, type, allowSelectionOnly) {\n  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }\n\n  var hist = doc.history, event, selAfter = doc.sel;\n  var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n  // Verify that there is a useable event (so that ctrl-z won't\n  // needlessly clear selection events)\n  var i = 0;\n  for (; i < source.length; i++) {\n    event = source[i];\n    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n      { break }\n  }\n  if (i == source.length) { return }\n  hist.lastOrigin = hist.lastSelOrigin = null;\n\n  for (;;) {\n    event = source.pop();\n    if (event.ranges) {\n      pushSelectionToHistory(event, dest);\n      if (allowSelectionOnly && !event.equals(doc.sel)) {\n        setSelection(doc, event, {clearRedo: false});\n        return\n      }\n      selAfter = event;\n    }\n    else { break }\n  }\n\n  // Build up a reverse change object to add to the opposite history\n  // stack (redo when undoing, and vice versa).\n  var antiChanges = [];\n  pushSelectionToHistory(selAfter, dest);\n  dest.push({changes: antiChanges, generation: hist.generation});\n  hist.generation = event.generation || ++hist.maxGeneration;\n\n  var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n  var loop = function ( i ) {\n    var change = event.changes[i];\n    change.origin = type;\n    if (filter && !filterChange(doc, change, false)) {\n      source.length = 0;\n      return {}\n    }\n\n    antiChanges.push(historyChangeFromChange(doc, change));\n\n    var after = i ? computeSelAfterChange(doc, change) : lst(source);\n    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n    var rebased = [];\n\n    // Propagate to the linked documents\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n    });\n  };\n\n  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n    var returned = loop( i$1 );\n\n    if ( returned ) return returned.v;\n  }\n}\n\n// Sub-views need their line numbers shifted when text is added\n// above or below them in the parent document.\nfunction shiftDoc(doc, distance) {\n  if (distance == 0) { return }\n  doc.first += distance;\n  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n    Pos(range.anchor.line + distance, range.anchor.ch),\n    Pos(range.head.line + distance, range.head.ch)\n  ); }), doc.sel.primIndex);\n  if (doc.cm) {\n    regChange(doc.cm, doc.first, doc.first - distance, distance);\n    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n      { regLineChange(doc.cm, l, \"gutter\"); }\n  }\n}\n\n// More lower-level change function, handling only a single document\n// (not linked ones).\nfunction makeChangeSingleDoc(doc, change, selAfter, spans) {\n  if (doc.cm && !doc.cm.curOp)\n    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n  if (change.to.line < doc.first) {\n    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n    return\n  }\n  if (change.from.line > doc.lastLine()) { return }\n\n  // Clip the change to the size of this doc\n  if (change.from.line < doc.first) {\n    var shift = change.text.length - 1 - (doc.first - change.from.line);\n    shiftDoc(doc, shift);\n    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n              text: [lst(change.text)], origin: change.origin};\n  }\n  var last = doc.lastLine();\n  if (change.to.line > last) {\n    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n              text: [change.text[0]], origin: change.origin};\n  }\n\n  change.removed = getBetween(doc, change.from, change.to);\n\n  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n  else { updateDoc(doc, change, spans); }\n  setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n}\n\n// Handle the interaction of a change to a document with the editor\n// that this document is part of.\nfunction makeChangeSingleDocInEditor(cm, change, spans) {\n  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n  var recomputeMaxLength = false, checkWidthStart = from.line;\n  if (!cm.options.lineWrapping) {\n    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n    doc.iter(checkWidthStart, to.line + 1, function (line) {\n      if (line == display.maxLine) {\n        recomputeMaxLength = true;\n        return true\n      }\n    });\n  }\n\n  if (doc.sel.contains(change.from, change.to) > -1)\n    { signalCursorActivity(cm); }\n\n  updateDoc(doc, change, spans, estimateHeight(cm));\n\n  if (!cm.options.lineWrapping) {\n    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n      var len = lineLength(line);\n      if (len > display.maxLineLength) {\n        display.maxLine = line;\n        display.maxLineLength = len;\n        display.maxLineChanged = true;\n        recomputeMaxLength = false;\n      }\n    });\n    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n  }\n\n  retreatFrontier(doc, from.line);\n  startWorker(cm, 400);\n\n  var lendiff = change.text.length - (to.line - from.line) - 1;\n  // Remember that these lines changed, for updating the display\n  if (change.full)\n    { regChange(cm); }\n  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n    { regLineChange(cm, from.line, \"text\"); }\n  else\n    { regChange(cm, from.line, to.line + 1, lendiff); }\n\n  var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n  if (changeHandler || changesHandler) {\n    var obj = {\n      from: from, to: to,\n      text: change.text,\n      removed: change.removed,\n      origin: change.origin\n    };\n    if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n  }\n  cm.display.selForContextMenu = null;\n}\n\nfunction replaceRange(doc, code, from, to, origin) {\n  if (!to) { to = from; }\n  if (cmp(to, from) < 0) { var assign;\n    (assign = [to, from], from = assign[0], to = assign[1], assign); }\n  if (typeof code == \"string\") { code = doc.splitLines(code); }\n  makeChange(doc, {from: from, to: to, text: code, origin: origin});\n}\n\n// Rebasing/resetting history to deal with externally-sourced changes\n\nfunction rebaseHistSelSingle(pos, from, to, diff) {\n  if (to < pos.line) {\n    pos.line += diff;\n  } else if (from < pos.line) {\n    pos.line = from;\n    pos.ch = 0;\n  }\n}\n\n// Tries to rebase an array of history events given a change in the\n// document. If the change touches the same lines as the event, the\n// event, and everything 'behind' it, is discarded. If the change is\n// before the event, the event's positions are updated. Uses a\n// copy-on-write scheme for the positions, to avoid having to\n// reallocate them all on every rebase, but also avoid problems with\n// shared position objects being unsafely updated.\nfunction rebaseHistArray(array, from, to, diff) {\n  for (var i = 0; i < array.length; ++i) {\n    var sub = array[i], ok = true;\n    if (sub.ranges) {\n      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n      for (var j = 0; j < sub.ranges.length; j++) {\n        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n      }\n      continue\n    }\n    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n      var cur = sub.changes[j$1];\n      if (to < cur.from.line) {\n        cur.from = Pos(cur.from.line + diff, cur.from.ch);\n        cur.to = Pos(cur.to.line + diff, cur.to.ch);\n      } else if (from <= cur.to.line) {\n        ok = false;\n        break\n      }\n    }\n    if (!ok) {\n      array.splice(0, i + 1);\n      i = 0;\n    }\n  }\n}\n\nfunction rebaseHist(hist, change) {\n  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n  rebaseHistArray(hist.done, from, to, diff);\n  rebaseHistArray(hist.undone, from, to, diff);\n}\n\n// Utility for applying a change to a line by handle or number,\n// returning the number and optionally registering the line as\n// changed.\nfunction changeLine(doc, handle, changeType, op) {\n  var no = handle, line = handle;\n  if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n  else { no = lineNo(handle); }\n  if (no == null) { return null }\n  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n  return line\n}\n\n// The document is represented as a BTree consisting of leaves, with\n// chunk of lines in them, and branches, with up to ten leaves or\n// other branch nodes below them. The top node is always a branch\n// node, and is the document object itself (meaning it has\n// additional methods and properties).\n//\n// All nodes have parent links. The tree is used both to go from\n// line numbers to line objects, and to go from objects to numbers.\n// It also indexes by height, and is used to convert between height\n// and line object, and to find the total height of the document.\n//\n// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\nfunction LeafChunk(lines) {\n  var this$1 = this;\n\n  this.lines = lines;\n  this.parent = null;\n  var height = 0;\n  for (var i = 0; i < lines.length; ++i) {\n    lines[i].parent = this$1;\n    height += lines[i].height;\n  }\n  this.height = height;\n}\n\nLeafChunk.prototype = {\n  chunkSize: function chunkSize() { return this.lines.length },\n\n  // Remove the n lines at offset 'at'.\n  removeInner: function removeInner(at, n) {\n    var this$1 = this;\n\n    for (var i = at, e = at + n; i < e; ++i) {\n      var line = this$1.lines[i];\n      this$1.height -= line.height;\n      cleanUpLine(line);\n      signalLater(line, \"delete\");\n    }\n    this.lines.splice(at, n);\n  },\n\n  // Helper used to collapse a small branch into a single leaf.\n  collapse: function collapse(lines) {\n    lines.push.apply(lines, this.lines);\n  },\n\n  // Insert the given array of lines at offset 'at', count them as\n  // having the given height.\n  insertInner: function insertInner(at, lines, height) {\n    var this$1 = this;\n\n    this.height += height;\n    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }\n  },\n\n  // Used to iterate over a part of the tree.\n  iterN: function iterN(at, n, op) {\n    var this$1 = this;\n\n    for (var e = at + n; at < e; ++at)\n      { if (op(this$1.lines[at])) { return true } }\n  }\n};\n\nfunction BranchChunk(children) {\n  var this$1 = this;\n\n  this.children = children;\n  var size = 0, height = 0;\n  for (var i = 0; i < children.length; ++i) {\n    var ch = children[i];\n    size += ch.chunkSize(); height += ch.height;\n    ch.parent = this$1;\n  }\n  this.size = size;\n  this.height = height;\n  this.parent = null;\n}\n\nBranchChunk.prototype = {\n  chunkSize: function chunkSize() { return this.size },\n\n  removeInner: function removeInner(at, n) {\n    var this$1 = this;\n\n    this.size -= n;\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at < sz) {\n        var rm = Math.min(n, sz - at), oldHeight = child.height;\n        child.removeInner(at, rm);\n        this$1.height -= oldHeight - child.height;\n        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\n        if ((n -= rm) == 0) { break }\n        at = 0;\n      } else { at -= sz; }\n    }\n    // If the result is smaller than 25 lines, ensure that it is a\n    // single leaf node.\n    if (this.size - n < 25 &&\n        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n      var lines = [];\n      this.collapse(lines);\n      this.children = [new LeafChunk(lines)];\n      this.children[0].parent = this;\n    }\n  },\n\n  collapse: function collapse(lines) {\n    var this$1 = this;\n\n    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }\n  },\n\n  insertInner: function insertInner(at, lines, height) {\n    var this$1 = this;\n\n    this.size += lines.length;\n    this.height += height;\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at <= sz) {\n        child.insertInner(at, lines, height);\n        if (child.lines && child.lines.length > 50) {\n          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n          var remaining = child.lines.length % 25 + 25;\n          for (var pos = remaining; pos < child.lines.length;) {\n            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n            child.height -= leaf.height;\n            this$1.children.splice(++i, 0, leaf);\n            leaf.parent = this$1;\n          }\n          child.lines = child.lines.slice(0, remaining);\n          this$1.maybeSpill();\n        }\n        break\n      }\n      at -= sz;\n    }\n  },\n\n  // When a node has grown, check whether it should be split.\n  maybeSpill: function maybeSpill() {\n    if (this.children.length <= 10) { return }\n    var me = this;\n    do {\n      var spilled = me.children.splice(me.children.length - 5, 5);\n      var sibling = new BranchChunk(spilled);\n      if (!me.parent) { // Become the parent node\n        var copy = new BranchChunk(me.children);\n        copy.parent = me;\n        me.children = [copy, sibling];\n        me = copy;\n     } else {\n        me.size -= sibling.size;\n        me.height -= sibling.height;\n        var myIndex = indexOf(me.parent.children, me);\n        me.parent.children.splice(myIndex + 1, 0, sibling);\n      }\n      sibling.parent = me.parent;\n    } while (me.children.length > 10)\n    me.parent.maybeSpill();\n  },\n\n  iterN: function iterN(at, n, op) {\n    var this$1 = this;\n\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at < sz) {\n        var used = Math.min(n, sz - at);\n        if (child.iterN(at, used, op)) { return true }\n        if ((n -= used) == 0) { break }\n        at = 0;\n      } else { at -= sz; }\n    }\n  }\n};\n\n// Line widgets are block elements displayed above or below a line.\n\nvar LineWidget = function(doc, node, options) {\n  var this$1 = this;\n\n  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n    { this$1[opt] = options[opt]; } } }\n  this.doc = doc;\n  this.node = node;\n};\n\nLineWidget.prototype.clear = function () {\n    var this$1 = this;\n\n  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n  if (no == null || !ws) { return }\n  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\n  if (!ws.length) { line.widgets = null; }\n  var height = widgetHeight(this);\n  updateLineHeight(line, Math.max(0, line.height - height));\n  if (cm) {\n    runInOp(cm, function () {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n    });\n    signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n  }\n};\n\nLineWidget.prototype.changed = function () {\n    var this$1 = this;\n\n  var oldH = this.height, cm = this.doc.cm, line = this.line;\n  this.height = null;\n  var diff = widgetHeight(this) - oldH;\n  if (!diff) { return }\n  updateLineHeight(line, line.height + diff);\n  if (cm) {\n    runInOp(cm, function () {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n      signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n    });\n  }\n};\neventMixin(LineWidget);\n\nfunction adjustScrollWhenAboveVisible(cm, line, diff) {\n  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n    { addToScrollTop(cm, diff); }\n}\n\nfunction addLineWidget(doc, handle, node, options) {\n  var widget = new LineWidget(doc, node, options);\n  var cm = doc.cm;\n  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n  changeLine(doc, handle, \"widget\", function (line) {\n    var widgets = line.widgets || (line.widgets = []);\n    if (widget.insertAt == null) { widgets.push(widget); }\n    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\n    widget.line = line;\n    if (cm && !lineIsHidden(doc, line)) {\n      var aboveVisible = heightAtLine(line) < doc.scrollTop;\n      updateLineHeight(line, line.height + widgetHeight(widget));\n      if (aboveVisible) { addToScrollTop(cm, widget.height); }\n      cm.curOp.forceUpdate = true;\n    }\n    return true\n  });\n  signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle));\n  return widget\n}\n\n// TEXTMARKERS\n\n// Created with markText and setBookmark methods. A TextMarker is a\n// handle that can be used to clear or find a marked position in the\n// document. Line objects hold arrays (markedSpans) containing\n// {from, to, marker} object pointing to such marker objects, and\n// indicating that such a marker is present on that line. Multiple\n// lines may point to the same marker when it spans across lines.\n// The spans will have null for their from/to properties when the\n// marker continues beyond the start/end of the line. Markers have\n// links back to the lines they currently touch.\n\n// Collapsed markers have unique ids, in order to be able to order\n// them, which is needed for uniquely determining an outer marker\n// when they overlap (they may nest, but not partially overlap).\nvar nextMarkerId = 0;\n\nvar TextMarker = function(doc, type) {\n  this.lines = [];\n  this.type = type;\n  this.doc = doc;\n  this.id = ++nextMarkerId;\n};\n\n// Clear the marker.\nTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  var cm = this.doc.cm, withOp = cm && !cm.curOp;\n  if (withOp) { startOperation(cm); }\n  if (hasHandler(this, \"clear\")) {\n    var found = this.find();\n    if (found) { signalLater(this, \"clear\", found.from, found.to); }\n  }\n  var min = null, max = null;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n    else if (cm) {\n      if (span.to != null) { max = lineNo(line); }\n      if (span.from != null) { min = lineNo(line); }\n    }\n    line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\n      { updateLineHeight(line, textHeight(cm.display)); }\n  }\n  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\n    if (len > cm.display.maxLineLength) {\n      cm.display.maxLine = visual;\n      cm.display.maxLineLength = len;\n      cm.display.maxLineChanged = true;\n    }\n  } }\n\n  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n  this.lines.length = 0;\n  this.explicitlyCleared = true;\n  if (this.atomic && this.doc.cantEdit) {\n    this.doc.cantEdit = false;\n    if (cm) { reCheckSelection(cm.doc); }\n  }\n  if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n  if (withOp) { endOperation(cm); }\n  if (this.parent) { this.parent.clear(); }\n};\n\n// Find the position of the marker in the document. Returns a {from,\n// to} object by default. Side can be passed to get a specific side\n// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n// Pos objects returned contain a line object, rather than a line\n// number (used to prevent looking up the same line twice).\nTextMarker.prototype.find = function (side, lineObj) {\n    var this$1 = this;\n\n  if (side == null && this.type == \"bookmark\") { side = 1; }\n  var from, to;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (span.from != null) {\n      from = Pos(lineObj ? line : lineNo(line), span.from);\n      if (side == -1) { return from }\n    }\n    if (span.to != null) {\n      to = Pos(lineObj ? line : lineNo(line), span.to);\n      if (side == 1) { return to }\n    }\n  }\n  return from && {from: from, to: to}\n};\n\n// Signals that the marker's widget changed, and surrounding layout\n// should be recomputed.\nTextMarker.prototype.changed = function () {\n    var this$1 = this;\n\n  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n  if (!pos || !cm) { return }\n  runInOp(cm, function () {\n    var line = pos.line, lineN = lineNo(pos.line);\n    var view = findViewForLine(cm, lineN);\n    if (view) {\n      clearLineMeasurementCacheFor(view);\n      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n    }\n    cm.curOp.updateMaxLine = true;\n    if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n      var oldHeight = widget.height;\n      widget.height = null;\n      var dHeight = widgetHeight(widget) - oldHeight;\n      if (dHeight)\n        { updateLineHeight(line, line.height + dHeight); }\n    }\n    signalLater(cm, \"markerChanged\", cm, this$1);\n  });\n};\n\nTextMarker.prototype.attachLine = function (line) {\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;\n    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n  }\n  this.lines.push(line);\n};\n\nTextMarker.prototype.detachLine = function (line) {\n  this.lines.splice(indexOf(this.lines, line), 1);\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n  }\n};\neventMixin(TextMarker);\n\n// Create a marker, wire it up to the right lines, and\nfunction markText(doc, from, to, options, type) {\n  // Shared markers (across linked documents) are handled separately\n  // (markTextShared will call out to this again, once per\n  // document).\n  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n  // Ensure we are in an operation.\n  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n  var marker = new TextMarker(doc, type), diff = cmp(from, to);\n  if (options) { copyObj(options, marker, false); }\n  // Don't connect empty markers unless clearWhenEmpty is false\n  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n    { return marker }\n  if (marker.replacedWith) {\n    // Showing up as a widget implies collapsed (widget replaces text)\n    marker.collapsed = true;\n    marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n  }\n  if (marker.collapsed) {\n    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n      { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n    seeCollapsedSpans();\n  }\n\n  if (marker.addToHistory)\n    { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n  var curLine = from.line, cm = doc.cm, updateMaxLine;\n  doc.iter(curLine, to.line + 1, function (line) {\n    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n      { updateMaxLine = true; }\n    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n    addMarkedSpan(line, new MarkedSpan(marker,\n                                       curLine == from.line ? from.ch : null,\n                                       curLine == to.line ? to.ch : null));\n    ++curLine;\n  });\n  // lineIsHidden depends on the presence of the spans, so needs a second pass\n  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n  }); }\n\n  if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n  if (marker.readOnly) {\n    seeReadOnlySpans();\n    if (doc.history.done.length || doc.history.undone.length)\n      { doc.clearHistory(); }\n  }\n  if (marker.collapsed) {\n    marker.id = ++nextMarkerId;\n    marker.atomic = true;\n  }\n  if (cm) {\n    // Sync editor state\n    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n    if (marker.collapsed)\n      { regChange(cm, from.line, to.line + 1); }\n    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n    if (marker.atomic) { reCheckSelection(cm.doc); }\n    signalLater(cm, \"markerAdded\", cm, marker);\n  }\n  return marker\n}\n\n// SHARED TEXTMARKERS\n\n// A shared marker spans multiple linked documents. It is\n// implemented as a meta-marker-object controlling multiple normal\n// markers.\nvar SharedTextMarker = function(markers, primary) {\n  var this$1 = this;\n\n  this.markers = markers;\n  this.primary = primary;\n  for (var i = 0; i < markers.length; ++i)\n    { markers[i].parent = this$1; }\n};\n\nSharedTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  this.explicitlyCleared = true;\n  for (var i = 0; i < this.markers.length; ++i)\n    { this$1.markers[i].clear(); }\n  signalLater(this, \"clear\");\n};\n\nSharedTextMarker.prototype.find = function (side, lineObj) {\n  return this.primary.find(side, lineObj)\n};\neventMixin(SharedTextMarker);\n\nfunction markTextShared(doc, from, to, options, type) {\n  options = copyObj(options);\n  options.shared = false;\n  var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n  var widget = options.widgetNode;\n  linkedDocs(doc, function (doc) {\n    if (widget) { options.widgetNode = widget.cloneNode(true); }\n    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n    for (var i = 0; i < doc.linked.length; ++i)\n      { if (doc.linked[i].isParent) { return } }\n    primary = lst(markers);\n  });\n  return new SharedTextMarker(markers, primary)\n}\n\nfunction findSharedMarkers(doc) {\n  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n}\n\nfunction copySharedMarkers(doc, markers) {\n  for (var i = 0; i < markers.length; i++) {\n    var marker = markers[i], pos = marker.find();\n    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n    if (cmp(mFrom, mTo)) {\n      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n      marker.markers.push(subMark);\n      subMark.parent = marker;\n    }\n  }\n}\n\nfunction detachSharedMarkers(markers) {\n  var loop = function ( i ) {\n    var marker = markers[i], linked = [marker.primary.doc];\n    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n    for (var j = 0; j < marker.markers.length; j++) {\n      var subMarker = marker.markers[j];\n      if (indexOf(linked, subMarker.doc) == -1) {\n        subMarker.parent = null;\n        marker.markers.splice(j--, 1);\n      }\n    }\n  };\n\n  for (var i = 0; i < markers.length; i++) loop( i );\n}\n\nvar nextDocId = 0;\nvar Doc = function(text, mode, firstLine, lineSep, direction) {\n  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n  if (firstLine == null) { firstLine = 0; }\n\n  BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n  this.first = firstLine;\n  this.scrollTop = this.scrollLeft = 0;\n  this.cantEdit = false;\n  this.cleanGeneration = 1;\n  this.modeFrontier = this.highlightFrontier = firstLine;\n  var start = Pos(firstLine, 0);\n  this.sel = simpleSelection(start);\n  this.history = new History(null);\n  this.id = ++nextDocId;\n  this.modeOption = mode;\n  this.lineSep = lineSep;\n  this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n  this.extend = false;\n\n  if (typeof text == \"string\") { text = this.splitLines(text); }\n  updateDoc(this, {from: start, to: start, text: text});\n  setSelection(this, simpleSelection(start), sel_dontScroll);\n};\n\nDoc.prototype = createObj(BranchChunk.prototype, {\n  constructor: Doc,\n  // Iterate over the document. Supports two forms -- with only one\n  // argument, it calls that for each line in the document. With\n  // three, it iterates over the range given by the first two (with\n  // the second being non-inclusive).\n  iter: function(from, to, op) {\n    if (op) { this.iterN(from - this.first, to - from, op); }\n    else { this.iterN(this.first, this.first + this.size, from); }\n  },\n\n  // Non-public interface for adding and removing lines.\n  insert: function(at, lines) {\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n    this.insertInner(at - this.first, lines, height);\n  },\n  remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n  // From here, the methods are part of the public interface. Most\n  // are also available from CodeMirror (editor) instances.\n\n  getValue: function(lineSep) {\n    var lines = getLines(this, this.first, this.first + this.size);\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n  setValue: docMethodOp(function(code) {\n    var top = Pos(this.first, 0), last = this.first + this.size - 1;\n    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                      text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n    if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n    setSelection(this, simpleSelection(top), sel_dontScroll);\n  }),\n  replaceRange: function(code, from, to, origin) {\n    from = clipPos(this, from);\n    to = to ? clipPos(this, to) : from;\n    replaceRange(this, code, from, to, origin);\n  },\n  getRange: function(from, to, lineSep) {\n    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n\n  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n  getLineNumber: function(line) {return lineNo(line)},\n\n  getLineHandleVisualStart: function(line) {\n    if (typeof line == \"number\") { line = getLine(this, line); }\n    return visualLine(line)\n  },\n\n  lineCount: function() {return this.size},\n  firstLine: function() {return this.first},\n  lastLine: function() {return this.first + this.size - 1},\n\n  clipPos: function(pos) {return clipPos(this, pos)},\n\n  getCursor: function(start) {\n    var range$$1 = this.sel.primary(), pos;\n    if (start == null || start == \"head\") { pos = range$$1.head; }\n    else if (start == \"anchor\") { pos = range$$1.anchor; }\n    else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\n    else { pos = range$$1.from(); }\n    return pos\n  },\n  listSelections: function() { return this.sel.ranges },\n  somethingSelected: function() {return this.sel.somethingSelected()},\n\n  setCursor: docMethodOp(function(line, ch, options) {\n    setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n  }),\n  setSelection: docMethodOp(function(anchor, head, options) {\n    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n  }),\n  extendSelection: docMethodOp(function(head, other, options) {\n    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n  }),\n  extendSelections: docMethodOp(function(heads, options) {\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  extendSelectionsBy: docMethodOp(function(f, options) {\n    var heads = map(this.sel.ranges, f);\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  setSelections: docMethodOp(function(ranges, primary, options) {\n    var this$1 = this;\n\n    if (!ranges.length) { return }\n    var out = [];\n    for (var i = 0; i < ranges.length; i++)\n      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\n                         clipPos(this$1, ranges[i].head)); }\n    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n    setSelection(this, normalizeSelection(out, primary), options);\n  }),\n  addSelection: docMethodOp(function(anchor, head, options) {\n    var ranges = this.sel.ranges.slice(0);\n    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n  }),\n\n  getSelection: function(lineSep) {\n    var this$1 = this;\n\n    var ranges = this.sel.ranges, lines;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      lines = lines ? lines.concat(sel) : sel;\n    }\n    if (lineSep === false) { return lines }\n    else { return lines.join(lineSep || this.lineSeparator()) }\n  },\n  getSelections: function(lineSep) {\n    var this$1 = this;\n\n    var parts = [], ranges = this.sel.ranges;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\n      parts[i] = sel;\n    }\n    return parts\n  },\n  replaceSelection: function(code, collapse, origin) {\n    var dup = [];\n    for (var i = 0; i < this.sel.ranges.length; i++)\n      { dup[i] = code; }\n    this.replaceSelections(dup, collapse, origin || \"+input\");\n  },\n  replaceSelections: docMethodOp(function(code, collapse, origin) {\n    var this$1 = this;\n\n    var changes = [], sel = this.sel;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range$$1 = sel.ranges[i];\n      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\n    }\n    var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n      { makeChange(this$1, changes[i$1]); }\n    if (newSel) { setSelectionReplaceHistory(this, newSel); }\n    else if (this.cm) { ensureCursorVisible(this.cm); }\n  }),\n  undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n  redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n  setExtending: function(val) {this.extend = val;},\n  getExtending: function() {return this.extend},\n\n  historySize: function() {\n    var hist = this.history, done = 0, undone = 0;\n    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n    return {undo: done, redo: undone}\n  },\n  clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n  markClean: function() {\n    this.cleanGeneration = this.changeGeneration(true);\n  },\n  changeGeneration: function(forceSplit) {\n    if (forceSplit)\n      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n    return this.history.generation\n  },\n  isClean: function (gen) {\n    return this.history.generation == (gen || this.cleanGeneration)\n  },\n\n  getHistory: function() {\n    return {done: copyHistoryArray(this.history.done),\n            undone: copyHistoryArray(this.history.undone)}\n  },\n  setHistory: function(histData) {\n    var hist = this.history = new History(this.history.maxGeneration);\n    hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n  },\n\n  setGutterMarker: docMethodOp(function(line, gutterID, value) {\n    return changeLine(this, line, \"gutter\", function (line) {\n      var markers = line.gutterMarkers || (line.gutterMarkers = {});\n      markers[gutterID] = value;\n      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n      return true\n    })\n  }),\n\n  clearGutter: docMethodOp(function(gutterID) {\n    var this$1 = this;\n\n    this.iter(function (line) {\n      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n        changeLine(this$1, line, \"gutter\", function () {\n          line.gutterMarkers[gutterID] = null;\n          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n          return true\n        });\n      }\n    });\n  }),\n\n  lineInfo: function(line) {\n    var n;\n    if (typeof line == \"number\") {\n      if (!isLine(this, line)) { return null }\n      n = line;\n      line = getLine(this, line);\n      if (!line) { return null }\n    } else {\n      n = lineNo(line);\n      if (n == null) { return null }\n    }\n    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n            widgets: line.widgets}\n  },\n\n  addLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      if (!line[prop]) { line[prop] = cls; }\n      else if (classTest(cls).test(line[prop])) { return false }\n      else { line[prop] += \" \" + cls; }\n      return true\n    })\n  }),\n  removeLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      var cur = line[prop];\n      if (!cur) { return false }\n      else if (cls == null) { line[prop] = null; }\n      else {\n        var found = cur.match(classTest(cls));\n        if (!found) { return false }\n        var end = found.index + found[0].length;\n        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n      }\n      return true\n    })\n  }),\n\n  addLineWidget: docMethodOp(function(handle, node, options) {\n    return addLineWidget(this, handle, node, options)\n  }),\n  removeLineWidget: function(widget) { widget.clear(); },\n\n  markText: function(from, to, options) {\n    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n  },\n  setBookmark: function(pos, options) {\n    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                    insertLeft: options && options.insertLeft,\n                    clearWhenEmpty: false, shared: options && options.shared,\n                    handleMouseEvents: options && options.handleMouseEvents};\n    pos = clipPos(this, pos);\n    return markText(this, pos, pos, realOpts, \"bookmark\")\n  },\n  findMarksAt: function(pos) {\n    pos = clipPos(this, pos);\n    var markers = [], spans = getLine(this, pos.line).markedSpans;\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if ((span.from == null || span.from <= pos.ch) &&\n          (span.to == null || span.to >= pos.ch))\n        { markers.push(span.marker.parent || span.marker); }\n    } }\n    return markers\n  },\n  findMarks: function(from, to, filter) {\n    from = clipPos(this, from); to = clipPos(this, to);\n    var found = [], lineNo$$1 = from.line;\n    this.iter(from.line, to.line + 1, function (line) {\n      var spans = line.markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; i++) {\n        var span = spans[i];\n        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\n              span.from == null && lineNo$$1 != from.line ||\n              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\n            (!filter || filter(span.marker)))\n          { found.push(span.marker.parent || span.marker); }\n      } }\n      ++lineNo$$1;\n    });\n    return found\n  },\n  getAllMarks: function() {\n    var markers = [];\n    this.iter(function (line) {\n      var sps = line.markedSpans;\n      if (sps) { for (var i = 0; i < sps.length; ++i)\n        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n    });\n    return markers\n  },\n\n  posFromIndex: function(off) {\n    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\n    this.iter(function (line) {\n      var sz = line.text.length + sepSize;\n      if (sz > off) { ch = off; return true }\n      off -= sz;\n      ++lineNo$$1;\n    });\n    return clipPos(this, Pos(lineNo$$1, ch))\n  },\n  indexFromPos: function (coords) {\n    coords = clipPos(this, coords);\n    var index = coords.ch;\n    if (coords.line < this.first || coords.ch < 0) { return 0 }\n    var sepSize = this.lineSeparator().length;\n    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n      index += line.text.length + sepSize;\n    });\n    return index\n  },\n\n  copy: function(copyHistory) {\n    var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                      this.modeOption, this.first, this.lineSep, this.direction);\n    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n    doc.sel = this.sel;\n    doc.extend = false;\n    if (copyHistory) {\n      doc.history.undoDepth = this.history.undoDepth;\n      doc.setHistory(this.getHistory());\n    }\n    return doc\n  },\n\n  linkedDoc: function(options) {\n    if (!options) { options = {}; }\n    var from = this.first, to = this.first + this.size;\n    if (options.from != null && options.from > from) { from = options.from; }\n    if (options.to != null && options.to < to) { to = options.to; }\n    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n    if (options.sharedHist) { copy.history = this.history\n    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n    copySharedMarkers(copy, findSharedMarkers(this));\n    return copy\n  },\n  unlinkDoc: function(other) {\n    var this$1 = this;\n\n    if (other instanceof CodeMirror$1) { other = other.doc; }\n    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n      var link = this$1.linked[i];\n      if (link.doc != other) { continue }\n      this$1.linked.splice(i, 1);\n      other.unlinkDoc(this$1);\n      detachSharedMarkers(findSharedMarkers(this$1));\n      break\n    } }\n    // If the histories were shared, split them again\n    if (other.history == this.history) {\n      var splitIds = [other.id];\n      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n      other.history = new History(null);\n      other.history.done = copyHistoryArray(this.history.done, splitIds);\n      other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n    }\n  },\n  iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n  getMode: function() {return this.mode},\n  getEditor: function() {return this.cm},\n\n  splitLines: function(str) {\n    if (this.lineSep) { return str.split(this.lineSep) }\n    return splitLinesAuto(str)\n  },\n  lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n  setDirection: docMethodOp(function (dir) {\n    if (dir != \"rtl\") { dir = \"ltr\"; }\n    if (dir == this.direction) { return }\n    this.direction = dir;\n    this.iter(function (line) { return line.order = null; });\n    if (this.cm) { directionChanged(this.cm); }\n  })\n});\n\n// Public alias.\nDoc.prototype.eachLine = Doc.prototype.iter;\n\n// Kludge to work around strange IE behavior where it'll sometimes\n// re-fire a series of drag-related events right after the drop (#1551)\nvar lastDrop = 0;\n\nfunction onDrop(e) {\n  var cm = this;\n  clearDragCursor(cm);\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n    { return }\n  e_preventDefault(e);\n  if (ie) { lastDrop = +new Date; }\n  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n  if (!pos || cm.isReadOnly()) { return }\n  // Might be a file drop, in which case we simply extract the text\n  // and insert it.\n  if (files && files.length && window.FileReader && window.File) {\n    var n = files.length, text = Array(n), read = 0;\n    var loadFile = function (file, i) {\n      if (cm.options.allowDropFileTypes &&\n          indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n        { return }\n\n      var reader = new FileReader;\n      reader.onload = operation(cm, function () {\n        var content = reader.result;\n        if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\n        text[i] = content;\n        if (++read == n) {\n          pos = clipPos(cm.doc, pos);\n          var change = {from: pos, to: pos,\n                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                        origin: \"paste\"};\n          makeChange(cm.doc, change);\n          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n        }\n      });\n      reader.readAsText(file);\n    };\n    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\n  } else { // Normal drop\n    // Don't do a replace if the drop happened inside of the selected text.\n    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n      cm.state.draggingText(e);\n      // Ensure the editor is re-focused\n      setTimeout(function () { return cm.display.input.focus(); }, 20);\n      return\n    }\n    try {\n      var text$1 = e.dataTransfer.getData(\"Text\");\n      if (text$1) {\n        var selected;\n        if (cm.state.draggingText && !cm.state.draggingText.copy)\n          { selected = cm.listSelections(); }\n        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n          { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n        cm.replaceSelection(text$1, \"around\", \"paste\");\n        cm.display.input.focus();\n      }\n    }\n    catch(e){}\n  }\n}\n\nfunction onDragStart(cm, e) {\n  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n  e.dataTransfer.setData(\"Text\", cm.getSelection());\n  e.dataTransfer.effectAllowed = \"copyMove\";\n\n  // Use dummy image instead of default browsers image.\n  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n  if (e.dataTransfer.setDragImage && !safari) {\n    var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n    img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    if (presto) {\n      img.width = img.height = 1;\n      cm.display.wrapper.appendChild(img);\n      // Force a relayout, or Opera won't use our image for some obscure reason\n      img._top = img.offsetTop;\n    }\n    e.dataTransfer.setDragImage(img, 0, 0);\n    if (presto) { img.parentNode.removeChild(img); }\n  }\n}\n\nfunction onDragOver(cm, e) {\n  var pos = posFromMouse(cm, e);\n  if (!pos) { return }\n  var frag = document.createDocumentFragment();\n  drawSelectionCursor(cm, pos, frag);\n  if (!cm.display.dragCursor) {\n    cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n  }\n  removeChildrenAndAdd(cm.display.dragCursor, frag);\n}\n\nfunction clearDragCursor(cm) {\n  if (cm.display.dragCursor) {\n    cm.display.lineSpace.removeChild(cm.display.dragCursor);\n    cm.display.dragCursor = null;\n  }\n}\n\n// These must be handled carefully, because naively registering a\n// handler for each editor will cause the editors to never be\n// garbage collected.\n\nfunction forEachCodeMirror(f) {\n  if (!document.getElementsByClassName) { return }\n  var byClass = document.getElementsByClassName(\"CodeMirror\");\n  for (var i = 0; i < byClass.length; i++) {\n    var cm = byClass[i].CodeMirror;\n    if (cm) { f(cm); }\n  }\n}\n\nvar globalsRegistered = false;\nfunction ensureGlobalHandlers() {\n  if (globalsRegistered) { return }\n  registerGlobalHandlers();\n  globalsRegistered = true;\n}\nfunction registerGlobalHandlers() {\n  // When the window resizes, we need to refresh active editors.\n  var resizeTimer;\n  on(window, \"resize\", function () {\n    if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n      resizeTimer = null;\n      forEachCodeMirror(onResize);\n    }, 100); }\n  });\n  // When the window loses focus, we want to show the editor as blurred\n  on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n}\n// Called when the window resizes\nfunction onResize(cm) {\n  var d = cm.display;\n  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n    { return }\n  // Might be a text scaling operation, clear size caches.\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n  d.scrollbarsClipped = false;\n  cm.setSize();\n}\n\nvar keyNames = {\n  3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n  46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n  106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n  173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n  221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n  63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n};\n\n// Number keys\nfor (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n// Alphabetic keys\nfor (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n// Function keys\nfor (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\nvar keyMap = {};\n\nkeyMap.basic = {\n  \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n  \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n  \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n  \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n  \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n  \"Esc\": \"singleSelection\"\n};\n// Note that the save and find-related commands aren't defined by\n// default. User code or addons can define them. Unknown commands\n// are simply ignored.\nkeyMap.pcDefault = {\n  \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n  \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n  \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n  \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n  \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n  \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n  \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n  fallthrough: \"basic\"\n};\n// Very basic readline/emacs-style bindings, which are standard on Mac.\nkeyMap.emacsy = {\n  \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n  \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n  \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n  \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n  \"Ctrl-O\": \"openLine\"\n};\nkeyMap.macDefault = {\n  \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n  \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n  \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n  \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n  \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n  \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n  \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n  fallthrough: [\"basic\", \"emacsy\"]\n};\nkeyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n// KEYMAP DISPATCH\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/);\n  name = parts[parts.length - 1];\n  var alt, ctrl, shift, cmd;\n  for (var i = 0; i < parts.length - 1; i++) {\n    var mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n    else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n    else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n    else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n  }\n  if (alt) { name = \"Alt-\" + name; }\n  if (ctrl) { name = \"Ctrl-\" + name; }\n  if (cmd) { name = \"Cmd-\" + name; }\n  if (shift) { name = \"Shift-\" + name; }\n  return name\n}\n\n// This is a kludge to keep keymaps mostly working as raw objects\n// (backwards compatibility) while at the same time support features\n// like normalization and multi-stroke key bindings. It compiles a\n// new normalized keymap, and then updates the old object to reflect\n// this.\nfunction normalizeKeyMap(keymap) {\n  var copy = {};\n  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n    var value = keymap[keyname];\n    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n    if (value == \"...\") { delete keymap[keyname]; continue }\n\n    var keys = map(keyname.split(\" \"), normalizeKeyName);\n    for (var i = 0; i < keys.length; i++) {\n      var val = (void 0), name = (void 0);\n      if (i == keys.length - 1) {\n        name = keys.join(\" \");\n        val = value;\n      } else {\n        name = keys.slice(0, i + 1).join(\" \");\n        val = \"...\";\n      }\n      var prev = copy[name];\n      if (!prev) { copy[name] = val; }\n      else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n    }\n    delete keymap[keyname];\n  } }\n  for (var prop in copy) { keymap[prop] = copy[prop]; }\n  return keymap\n}\n\nfunction lookupKey(key, map$$1, handle, context) {\n  map$$1 = getKeyMap(map$$1);\n  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\n  if (found === false) { return \"nothing\" }\n  if (found === \"...\") { return \"multi\" }\n  if (found != null && handle(found)) { return \"handled\" }\n\n  if (map$$1.fallthrough) {\n    if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\n      { return lookupKey(key, map$$1.fallthrough, handle, context) }\n    for (var i = 0; i < map$$1.fallthrough.length; i++) {\n      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\n      if (result) { return result }\n    }\n  }\n}\n\n// Modifier key presses don't count as 'real' key presses for the\n// purpose of keymap fallthrough.\nfunction isModifierKey(value) {\n  var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n  return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n}\n\nfunction addModifierNames(name, event, noShift) {\n  var base = name;\n  if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") { name = \"Cmd-\" + name; }\n  if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n  return name\n}\n\n// Look up the name of a key as indicated by an event object.\nfunction keyName(event, noShift) {\n  if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n  var name = keyNames[event.keyCode];\n  if (name == null || event.altGraphKey) { return false }\n  return addModifierNames(name, event, noShift)\n}\n\nfunction getKeyMap(val) {\n  return typeof val == \"string\" ? keyMap[val] : val\n}\n\n// Helper for deleting text near the selection(s), used to implement\n// backspace, delete, and similar functionality.\nfunction deleteNearSelection(cm, compute) {\n  var ranges = cm.doc.sel.ranges, kill = [];\n  // Build up a set of ranges to kill first, merging overlapping\n  // ranges.\n  for (var i = 0; i < ranges.length; i++) {\n    var toKill = compute(ranges[i]);\n    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n      var replaced = kill.pop();\n      if (cmp(replaced.from, toKill.from) < 0) {\n        toKill.from = replaced.from;\n        break\n      }\n    }\n    kill.push(toKill);\n  }\n  // Next, remove those actual ranges.\n  runInOp(cm, function () {\n    for (var i = kill.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n    ensureCursorVisible(cm);\n  });\n}\n\nfunction moveCharLogically(line, ch, dir) {\n  var target = skipExtendingChars(line.text, ch + dir, dir);\n  return target < 0 || target > line.text.length ? null : target\n}\n\nfunction moveLogically(line, start, dir) {\n  var ch = moveCharLogically(line, start.ch, dir);\n  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n}\n\nfunction endOfLine(visually, cm, lineObj, lineNo, dir) {\n  if (visually) {\n    var order = getOrder(lineObj, cm.doc.direction);\n    if (order) {\n      var part = dir < 0 ? lst(order) : order[0];\n      var moveInStorageOrder = (dir < 0) == (part.level == 1);\n      var sticky = moveInStorageOrder ? \"after\" : \"before\";\n      var ch;\n      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n      // it could be that the last bidi part is not on the last visual line,\n      // since visual lines contain content order-consecutive chunks.\n      // Thus, in rtl, we are looking for the first (content-order) character\n      // in the rtl chunk that is on the last line (that is, the same line\n      // as the last (content-order) character).\n      if (part.level > 0 || cm.doc.direction == \"rtl\") {\n        var prep = prepareMeasureForLine(cm, lineObj);\n        ch = dir < 0 ? lineObj.text.length - 1 : 0;\n        var targetTop = measureCharPrepared(cm, prep, ch).top;\n        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n        if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n      } else { ch = dir < 0 ? part.to : part.from; }\n      return new Pos(lineNo, ch, sticky)\n    }\n  }\n  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n}\n\nfunction moveVisually(cm, line, start, dir) {\n  var bidi = getOrder(line, cm.doc.direction);\n  if (!bidi) { return moveLogically(line, start, dir) }\n  if (start.ch >= line.text.length) {\n    start.ch = line.text.length;\n    start.sticky = \"before\";\n  } else if (start.ch <= 0) {\n    start.ch = 0;\n    start.sticky = \"after\";\n  }\n  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n  if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n    // nothing interesting happens.\n    return moveLogically(line, start, dir)\n  }\n\n  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n  var prep;\n  var getWrappedLineExtent = function (ch) {\n    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n    prep = prep || prepareMeasureForLine(cm, line);\n    return wrappedLineExtentChar(cm, line, prep, ch)\n  };\n  var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n  if (cm.doc.direction == \"rtl\" || part.level == 1) {\n    var moveInStorageOrder = (part.level == 1) == (dir < 0);\n    var ch = mv(start, moveInStorageOrder ? 1 : -1);\n    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n      // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n      var sticky = moveInStorageOrder ? \"before\" : \"after\";\n      return new Pos(start.line, ch, sticky)\n    }\n  }\n\n  // Case 3: Could not move within this bidi part in this visual line, so leave\n  // the current bidi part\n\n  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n      ? new Pos(start.line, mv(ch, 1), \"before\")\n      : new Pos(start.line, ch, \"after\"); };\n\n    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n      var part = bidi[partPos];\n      var moveInStorageOrder = (dir > 0) == (part.level != 1);\n      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n      ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n    }\n  };\n\n  // Case 3a: Look for other bidi parts on the same visual line\n  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n  if (res) { return res }\n\n  // Case 3b: Look for other bidi parts on the next visual line\n  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n    if (res) { return res }\n  }\n\n  // Case 4: Nowhere to move\n  return null\n}\n\n// Commands are parameter-less actions that can be performed on an\n// editor, mostly used for keybindings.\nvar commands = {\n  selectAll: selectAll,\n  singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n  killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n    if (range.empty()) {\n      var len = getLine(cm.doc, range.head.line).text.length;\n      if (range.head.ch == len && range.head.line < cm.lastLine())\n        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n      else\n        { return {from: range.head, to: Pos(range.head.line, len)} }\n    } else {\n      return {from: range.from(), to: range.to()}\n    }\n  }); },\n  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0),\n    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n  }); }); },\n  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0), to: range.from()\n  }); }); },\n  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n    return {from: leftPos, to: range.from()}\n  }); },\n  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n    return {from: range.from(), to: rightPos }\n  }); },\n  undo: function (cm) { return cm.undo(); },\n  redo: function (cm) { return cm.redo(); },\n  undoSelection: function (cm) { return cm.undoSelection(); },\n  redoSelection: function (cm) { return cm.redoSelection(); },\n  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n    {origin: \"+move\", bias: -1}\n  ); },\n  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: 0, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n    if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n    return pos\n  }, sel_move); },\n  goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n  goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n  goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n  goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n  goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n  goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n  goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n  goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n  goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n  goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n  goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n  goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n  delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\n  delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n  delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n  delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n  delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n  delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n  indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n  indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n  indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n  insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n  insertSoftTab: function (cm) {\n    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n    for (var i = 0; i < ranges.length; i++) {\n      var pos = ranges[i].from();\n      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n      spaces.push(spaceStr(tabSize - col % tabSize));\n    }\n    cm.replaceSelections(spaces);\n  },\n  defaultTab: function (cm) {\n    if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n    else { cm.execCommand(\"insertTab\"); }\n  },\n  // Swap the two chars left and right of each selection's head.\n  // Move cursor behind the two swapped characters afterwards.\n  //\n  // Doesn't consider line feeds a character.\n  // Doesn't scan more than one line above to find a character.\n  // Doesn't do anything on an empty line.\n  // Doesn't do anything with non-empty selections.\n  transposeChars: function (cm) { return runInOp(cm, function () {\n    var ranges = cm.listSelections(), newSel = [];\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) { continue }\n      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n      if (line) {\n        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n        if (cur.ch > 0) {\n          cur = new Pos(cur.line, cur.ch + 1);\n          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                          Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n        } else if (cur.line > cm.doc.first) {\n          var prev = getLine(cm.doc, cur.line - 1).text;\n          if (prev) {\n            cur = new Pos(cur.line, 1);\n            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                            prev.charAt(prev.length - 1),\n                            Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n          }\n        }\n      }\n      newSel.push(new Range(cur, cur));\n    }\n    cm.setSelections(newSel);\n  }); },\n  newlineAndIndent: function (cm) { return runInOp(cm, function () {\n    var sels = cm.listSelections();\n    for (var i = sels.length - 1; i >= 0; i--)\n      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n    sels = cm.listSelections();\n    for (var i$1 = 0; i$1 < sels.length; i$1++)\n      { cm.indentLine(sels[i$1].from().line, null, true); }\n    ensureCursorVisible(cm);\n  }); },\n  openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n};\n\n\nfunction lineStart(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLine(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, visual, lineN, 1)\n}\nfunction lineEnd(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLineEnd(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, line, lineN, -1)\n}\nfunction lineStartSmart(cm, pos) {\n  var start = lineStart(cm, pos.line);\n  var line = getLine(cm.doc, start.line);\n  var order = getOrder(line, cm.doc.direction);\n  if (!order || order[0].level == 0) {\n    var firstNonWS = Math.max(0, line.text.search(/\\S/));\n    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n  }\n  return start\n}\n\n// Run a handler that was bound to a key.\nfunction doHandleBinding(cm, bound, dropShift) {\n  if (typeof bound == \"string\") {\n    bound = commands[bound];\n    if (!bound) { return false }\n  }\n  // Ensure previous input has been read, so that the handler sees a\n  // consistent view of the document\n  cm.display.input.ensurePolled();\n  var prevShift = cm.display.shift, done = false;\n  try {\n    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n    if (dropShift) { cm.display.shift = false; }\n    done = bound(cm) != Pass;\n  } finally {\n    cm.display.shift = prevShift;\n    cm.state.suppressEdits = false;\n  }\n  return done\n}\n\nfunction lookupKeyForEditor(cm, name, handle) {\n  for (var i = 0; i < cm.state.keyMaps.length; i++) {\n    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n    if (result) { return result }\n  }\n  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n    || lookupKey(name, cm.options.keyMap, handle, cm)\n}\n\n// Note that, despite the name, this function is also used to check\n// for bound mouse clicks.\n\nvar stopSeq = new Delayed;\nfunction dispatchKey(cm, name, e, handle) {\n  var seq = cm.state.keySeq;\n  if (seq) {\n    if (isModifierKey(name)) { return \"handled\" }\n    stopSeq.set(50, function () {\n      if (cm.state.keySeq == seq) {\n        cm.state.keySeq = null;\n        cm.display.input.reset();\n      }\n    });\n    name = seq + \" \" + name;\n  }\n  var result = lookupKeyForEditor(cm, name, handle);\n\n  if (result == \"multi\")\n    { cm.state.keySeq = name; }\n  if (result == \"handled\")\n    { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n  if (result == \"handled\" || result == \"multi\") {\n    e_preventDefault(e);\n    restartBlink(cm);\n  }\n\n  if (seq && !result && /\\'$/.test(name)) {\n    e_preventDefault(e);\n    return true\n  }\n  return !!result\n}\n\n// Handle a key from the keydown event.\nfunction handleKeyBinding(cm, e) {\n  var name = keyName(e, true);\n  if (!name) { return false }\n\n  if (e.shiftKey && !cm.state.keySeq) {\n    // First try to resolve full name (including 'Shift-'). Failing\n    // that, see if there is a cursor-motion command (starting with\n    // 'go') bound to the keyname without 'Shift-'.\n    return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n        || dispatchKey(cm, name, e, function (b) {\n             if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n               { return doHandleBinding(cm, b) }\n           })\n  } else {\n    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n  }\n}\n\n// Handle a key from the keypress event\nfunction handleCharBinding(cm, e, ch) {\n  return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n}\n\nvar lastStoppedKey = null;\nfunction onKeyDown(e) {\n  var cm = this;\n  cm.curOp.focus = activeElt();\n  if (signalDOMEvent(cm, e)) { return }\n  // IE does strange things with escape.\n  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n  var code = e.keyCode;\n  cm.display.shift = code == 16 || e.shiftKey;\n  var handled = handleKeyBinding(cm, e);\n  if (presto) {\n    lastStoppedKey = handled ? code : null;\n    // Opera has no cut event... we try to at least catch the key combo\n    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n      { cm.replaceSelection(\"\", null, \"cut\"); }\n  }\n\n  // Turn mouse into crosshair when Alt is held on Mac.\n  if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n    { showCrossHair(cm); }\n}\n\nfunction showCrossHair(cm) {\n  var lineDiv = cm.display.lineDiv;\n  addClass(lineDiv, \"CodeMirror-crosshair\");\n\n  function up(e) {\n    if (e.keyCode == 18 || !e.altKey) {\n      rmClass(lineDiv, \"CodeMirror-crosshair\");\n      off(document, \"keyup\", up);\n      off(document, \"mouseover\", up);\n    }\n  }\n  on(document, \"keyup\", up);\n  on(document, \"mouseover\", up);\n}\n\nfunction onKeyUp(e) {\n  if (e.keyCode == 16) { this.doc.sel.shift = false; }\n  signalDOMEvent(this, e);\n}\n\nfunction onKeyPress(e) {\n  var cm = this;\n  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n  var keyCode = e.keyCode, charCode = e.charCode;\n  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n  // Some browsers fire keypress events for backspace\n  if (ch == \"\\x08\") { return }\n  if (handleCharBinding(cm, e, ch)) { return }\n  cm.display.input.onKeyPress(e);\n}\n\nvar DOUBLECLICK_DELAY = 400;\n\nvar PastClick = function(time, pos, button) {\n  this.time = time;\n  this.pos = pos;\n  this.button = button;\n};\n\nPastClick.prototype.compare = function (time, pos, button) {\n  return this.time + DOUBLECLICK_DELAY > time &&\n    cmp(pos, this.pos) == 0 && button == this.button\n};\n\nvar lastClick;\nvar lastDoubleClick;\nfunction clickRepeat(pos, button) {\n  var now = +new Date;\n  if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n    lastClick = lastDoubleClick = null;\n    return \"triple\"\n  } else if (lastClick && lastClick.compare(now, pos, button)) {\n    lastDoubleClick = new PastClick(now, pos, button);\n    lastClick = null;\n    return \"double\"\n  } else {\n    lastClick = new PastClick(now, pos, button);\n    lastDoubleClick = null;\n    return \"single\"\n  }\n}\n\n// A mouse down can be a single click, double click, triple click,\n// start of selection drag, start of text drag, new cursor\n// (ctrl-click), rectangle drag (alt-drag), or xwin\n// middle-click-paste. Or it might be a click on something we should\n// not interfere with, such as a scrollbar or widget.\nfunction onMouseDown(e) {\n  var cm = this, display = cm.display;\n  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n  display.input.ensurePolled();\n  display.shift = e.shiftKey;\n\n  if (eventInWidget(display, e)) {\n    if (!webkit) {\n      // Briefly turn off draggability, to allow widgets to do\n      // normal dragging things.\n      display.scroller.draggable = false;\n      setTimeout(function () { return display.scroller.draggable = true; }, 100);\n    }\n    return\n  }\n  if (clickInGutter(cm, e)) { return }\n  var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n  window.focus();\n\n  // #3261: make sure, that we're not starting a second selection\n  if (button == 1 && cm.state.selectingText)\n    { cm.state.selectingText(e); }\n\n  if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n  if (button == 1) {\n    if (pos) { leftButtonDown(cm, pos, repeat, e); }\n    else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n  } else if (button == 2) {\n    if (pos) { extendSelection(cm.doc, pos); }\n    setTimeout(function () { return display.input.focus(); }, 20);\n  } else if (button == 3) {\n    if (captureRightClick) { onContextMenu(cm, e); }\n    else { delayBlurEvent(cm); }\n  }\n}\n\nfunction handleMappedButton(cm, button, pos, repeat, event) {\n  var name = \"Click\";\n  if (repeat == \"double\") { name = \"Double\" + name; }\n  else if (repeat == \"triple\") { name = \"Triple\" + name; }\n  name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n  return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n    if (typeof bound == \"string\") { bound = commands[bound]; }\n    if (!bound) { return false }\n    var done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      done = bound(cm, pos) != Pass;\n    } finally {\n      cm.state.suppressEdits = false;\n    }\n    return done\n  })\n}\n\nfunction configureMouse(cm, repeat, event) {\n  var option = cm.getOption(\"configureMouse\");\n  var value = option ? option(cm, repeat, event) : {};\n  if (value.unit == null) {\n    var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n    value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n  }\n  if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n  if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n  if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n  return value\n}\n\nfunction leftButtonDown(cm, pos, repeat, event) {\n  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n  else { cm.curOp.focus = activeElt(); }\n\n  var behavior = configureMouse(cm, repeat, event);\n\n  var sel = cm.doc.sel, contained;\n  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n      repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n      (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n      (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n    { leftButtonStartDrag(cm, event, pos, behavior); }\n  else\n    { leftButtonSelect(cm, event, pos, behavior); }\n}\n\n// Start a text drag. When it ends, see if any dragging actually\n// happen, and treat as a click if it didn't.\nfunction leftButtonStartDrag(cm, event, pos, behavior) {\n  var display = cm.display, moved = false;\n  var dragEnd = operation(cm, function (e) {\n    if (webkit) { display.scroller.draggable = false; }\n    cm.state.draggingText = false;\n    off(document, \"mouseup\", dragEnd);\n    off(document, \"mousemove\", mouseMove);\n    off(display.scroller, \"dragstart\", dragStart);\n    off(display.scroller, \"drop\", dragEnd);\n    if (!moved) {\n      e_preventDefault(e);\n      if (!behavior.addNew)\n        { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n      if (webkit || ie && ie_version == 9)\n        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }\n      else\n        { display.input.focus(); }\n    }\n  });\n  var mouseMove = function(e2) {\n    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n  };\n  var dragStart = function () { return moved = true; };\n  // Let the drag handler handle this.\n  if (webkit) { display.scroller.draggable = true; }\n  cm.state.draggingText = dragEnd;\n  dragEnd.copy = !behavior.moveOnDrag;\n  // IE's approach to draggable\n  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n  on(document, \"mouseup\", dragEnd);\n  on(document, \"mousemove\", mouseMove);\n  on(display.scroller, \"dragstart\", dragStart);\n  on(display.scroller, \"drop\", dragEnd);\n\n  delayBlurEvent(cm);\n  setTimeout(function () { return display.input.focus(); }, 20);\n}\n\nfunction rangeForUnit(cm, pos, unit) {\n  if (unit == \"char\") { return new Range(pos, pos) }\n  if (unit == \"word\") { return cm.findWordAt(pos) }\n  if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n  var result = unit(cm, pos);\n  return new Range(result.from, result.to)\n}\n\n// Normal selection, as opposed to text dragging.\nfunction leftButtonSelect(cm, event, start, behavior) {\n  var display = cm.display, doc = cm.doc;\n  e_preventDefault(event);\n\n  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n  if (behavior.addNew && !behavior.extend) {\n    ourIndex = doc.sel.contains(start);\n    if (ourIndex > -1)\n      { ourRange = ranges[ourIndex]; }\n    else\n      { ourRange = new Range(start, start); }\n  } else {\n    ourRange = doc.sel.primary();\n    ourIndex = doc.sel.primIndex;\n  }\n\n  if (behavior.unit == \"rectangle\") {\n    if (!behavior.addNew) { ourRange = new Range(start, start); }\n    start = posFromMouse(cm, event, true, true);\n    ourIndex = -1;\n  } else {\n    var range$$1 = rangeForUnit(cm, start, behavior.unit);\n    if (behavior.extend)\n      { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }\n    else\n      { ourRange = range$$1; }\n  }\n\n  if (!behavior.addNew) {\n    ourIndex = 0;\n    setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n    startSel = doc.sel;\n  } else if (ourIndex == -1) {\n    ourIndex = ranges.length;\n    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n                 {scroll: false, origin: \"*mouse\"});\n  } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                 {scroll: false, origin: \"*mouse\"});\n    startSel = doc.sel;\n  } else {\n    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n  }\n\n  var lastPos = start;\n  function extendTo(pos) {\n    if (cmp(lastPos, pos) == 0) { return }\n    lastPos = pos;\n\n    if (behavior.unit == \"rectangle\") {\n      var ranges = [], tabSize = cm.options.tabSize;\n      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n           line <= end; line++) {\n        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n        if (left == right)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n        else if (text.length > leftPos)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n      }\n      if (!ranges.length) { ranges.push(new Range(start, start)); }\n      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                   {origin: \"*mouse\", scroll: false});\n      cm.scrollIntoView(pos);\n    } else {\n      var oldRange = ourRange;\n      var range$$1 = rangeForUnit(cm, pos, behavior.unit);\n      var anchor = oldRange.anchor, head;\n      if (cmp(range$$1.anchor, anchor) > 0) {\n        head = range$$1.head;\n        anchor = minPos(oldRange.from(), range$$1.anchor);\n      } else {\n        head = range$$1.anchor;\n        anchor = maxPos(oldRange.to(), range$$1.head);\n      }\n      var ranges$1 = startSel.ranges.slice(0);\n      ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);\n    }\n  }\n\n  var editorSize = display.wrapper.getBoundingClientRect();\n  // Used to ensure timeout re-tries don't fire when another extend\n  // happened in the meantime (clearTimeout isn't reliable -- at\n  // least on Chrome, the timeouts still happen even when cleared,\n  // if the clear happens after their scheduled firing time).\n  var counter = 0;\n\n  function extend(e) {\n    var curCount = ++counter;\n    var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n    if (!cur) { return }\n    if (cmp(cur, lastPos) != 0) {\n      cm.curOp.focus = activeElt();\n      extendTo(cur);\n      var visible = visibleLines(display, doc);\n      if (cur.line >= visible.to || cur.line < visible.from)\n        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n    } else {\n      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n      if (outside) { setTimeout(operation(cm, function () {\n        if (counter != curCount) { return }\n        display.scroller.scrollTop += outside;\n        extend(e);\n      }), 50); }\n    }\n  }\n\n  function done(e) {\n    cm.state.selectingText = false;\n    counter = Infinity;\n    e_preventDefault(e);\n    display.input.focus();\n    off(document, \"mousemove\", move);\n    off(document, \"mouseup\", up);\n    doc.history.lastSelOrigin = null;\n  }\n\n  var move = operation(cm, function (e) {\n    if (!e_button(e)) { done(e); }\n    else { extend(e); }\n  });\n  var up = operation(cm, done);\n  cm.state.selectingText = up;\n  on(document, \"mousemove\", move);\n  on(document, \"mouseup\", up);\n}\n\n// Used when mouse-selecting to adjust the anchor to the proper side\n// of a bidi jump depending on the visual position of the head.\nfunction bidiSimplify(cm, range$$1) {\n  var anchor = range$$1.anchor;\n  var head = range$$1.head;\n  var anchorLine = getLine(cm.doc, anchor.line);\n  if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }\n  var order = getOrder(anchorLine);\n  if (!order) { return range$$1 }\n  var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n  if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }\n  var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n  if (boundary == 0 || boundary == order.length) { return range$$1 }\n\n  // Compute the relative visual position of the head compared to the\n  // anchor (<0 is to the left, >0 to the right)\n  var leftSide;\n  if (head.line != anchor.line) {\n    leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n  } else {\n    var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n    var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n    if (headIndex == boundary - 1 || headIndex == boundary)\n      { leftSide = dir < 0; }\n    else\n      { leftSide = dir > 0; }\n  }\n\n  var usePart = order[boundary + (leftSide ? -1 : 0)];\n  var from = leftSide == (usePart.level == 1);\n  var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n  return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)\n}\n\n\n// Determines whether an event happened in the gutter, and fires the\n// handlers for the corresponding event.\nfunction gutterEvent(cm, e, type, prevent) {\n  var mX, mY;\n  if (e.touches) {\n    mX = e.touches[0].clientX;\n    mY = e.touches[0].clientY;\n  } else {\n    try { mX = e.clientX; mY = e.clientY; }\n    catch(e) { return false }\n  }\n  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n  if (prevent) { e_preventDefault(e); }\n\n  var display = cm.display;\n  var lineBox = display.lineDiv.getBoundingClientRect();\n\n  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n  mY -= lineBox.top - display.viewOffset;\n\n  for (var i = 0; i < cm.options.gutters.length; ++i) {\n    var g = display.gutters.childNodes[i];\n    if (g && g.getBoundingClientRect().right >= mX) {\n      var line = lineAtHeight(cm.doc, mY);\n      var gutter = cm.options.gutters[i];\n      signal(cm, type, cm, line, gutter, e);\n      return e_defaultPrevented(e)\n    }\n  }\n}\n\nfunction clickInGutter(cm, e) {\n  return gutterEvent(cm, e, \"gutterClick\", true)\n}\n\n// CONTEXT MENU HANDLING\n\n// To make the context menu work, we need to briefly unhide the\n// textarea (making it as unobtrusive as possible) to let the\n// right-click take effect on it.\nfunction onContextMenu(cm, e) {\n  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n  if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n  cm.display.input.onContextMenu(e);\n}\n\nfunction contextMenuInGutter(cm, e) {\n  if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n  return gutterEvent(cm, e, \"gutterContextMenu\", false)\n}\n\nfunction themeChanged(cm) {\n  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n    cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n  clearCaches(cm);\n}\n\nvar Init = {toString: function(){return \"CodeMirror.Init\"}};\n\nvar defaults = {};\nvar optionHandlers = {};\n\nfunction defineOptions(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) { optionHandlers[name] =\n      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n  }\n\n  CodeMirror.defineOption = option;\n\n  // Passed to option handlers when there is no old value.\n  CodeMirror.Init = Init;\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n  option(\"mode\", null, function (cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function (cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"lineSeparator\", null, function (cm, val) {\n    cm.doc.lineSep = val;\n    if (!val) { return }\n    var newBreaks = [], lineNo = cm.doc.first;\n    cm.doc.iter(function (line) {\n      for (var pos = 0;;) {\n        var found = line.text.indexOf(val, pos);\n        if (found == -1) { break }\n        pos = found + val.length;\n        newBreaks.push(Pos(lineNo, found));\n      }\n      lineNo++;\n    });\n    for (var i = newBreaks.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n  });\n  option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function (cm, val, old) {\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    if (old != Init) { cm.refresh(); }\n  });\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n  option(\"electricChars\", true);\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n  }, true);\n  option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function (cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", function (cm, val, old) {\n    var next = getKeyMap(val);\n    var prev = old != Init && getKeyMap(old);\n    if (prev && prev.detach) { prev.detach(cm, next); }\n    if (next.attach) { next.attach(cm, prev || null); }\n  });\n  option(\"extraKeys\", null);\n  option(\"configureMouse\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function (cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n  option(\"scrollbarStyle\", \"native\", function (cm) {\n    initScrollbars(cm);\n    updateScrollbars(cm);\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n  }, true);\n  option(\"lineNumbers\", false, function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function (integer) { return integer; }, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n  option(\"lineWiseCopyCut\", true);\n  option(\"pasteLinesPerSelection\", true);\n\n  option(\"readOnly\", false, function (cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n    }\n    cm.display.input.readOnlyChanged(val);\n  });\n  option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n  option(\"dragDrop\", true, dragDropChanged);\n  option(\"allowDropFileTypes\", null);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function (cm, val) {\n    if (!val) { cm.display.input.resetPosition(); }\n  });\n\n  option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n  option(\"autofocus\", null);\n  option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n}\n\nfunction guttersChanged(cm) {\n  updateGutters(cm);\n  regChange(cm);\n  alignHorizontally(cm);\n}\n\nfunction dragDropChanged(cm, value, old) {\n  var wasOn = old && old != Init;\n  if (!value != !wasOn) {\n    var funcs = cm.display.dragFunctions;\n    var toggle = value ? on : off;\n    toggle(cm.display.scroller, \"dragstart\", funcs.start);\n    toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n    toggle(cm.display.scroller, \"dragover\", funcs.over);\n    toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n    toggle(cm.display.scroller, \"drop\", funcs.drop);\n  }\n}\n\nfunction wrappingChanged(cm) {\n  if (cm.options.lineWrapping) {\n    addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    cm.display.sizer.style.minWidth = \"\";\n    cm.display.sizerWidth = null;\n  } else {\n    rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    findMaxLine(cm);\n  }\n  estimateLineHeights(cm);\n  regChange(cm);\n  clearCaches(cm);\n  setTimeout(function () { return updateScrollbars(cm); }, 100);\n}\n\n// A CodeMirror instance represents an editor. This is the object\n// that user code is usually dealing with.\n\nfunction CodeMirror$1(place, options) {\n  var this$1 = this;\n\n  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }\n\n  this.options = options = options ? copyObj(options) : {};\n  // Determine effective options based on given values and defaults.\n  copyObj(defaults, options, false);\n  setGuttersForLineNumbers(options);\n\n  var doc = options.value;\n  if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n  this.doc = doc;\n\n  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);\n  var display = this.display = new Display(place, doc, input);\n  display.wrapper.CodeMirror = this;\n  updateGutters(this);\n  themeChanged(this);\n  if (options.lineWrapping)\n    { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n  initScrollbars(this);\n\n  this.state = {\n    keyMaps: [],  // stores maps added by addKeyMap\n    overlays: [], // highlighting overlays, as added by addOverlay\n    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n    overwrite: false,\n    delayingBlurEvent: false,\n    focused: false,\n    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n    selectingText: false,\n    draggingText: false,\n    highlight: new Delayed(), // stores highlight worker timeout\n    keySeq: null,  // Unfinished key sequence\n    specialChars: null\n  };\n\n  if (options.autofocus && !mobile) { display.input.focus(); }\n\n  // Override magic textarea content restore that IE sometimes does\n  // on our hidden textarea on reload\n  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n  registerEventHandlers(this);\n  ensureGlobalHandlers();\n\n  startOperation(this);\n  this.curOp.forceUpdate = true;\n  attachDoc(this, doc);\n\n  if ((options.autofocus && !mobile) || this.hasFocus())\n    { setTimeout(bind(onFocus, this), 20); }\n  else\n    { onBlur(this); }\n\n  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n    { optionHandlers[opt](this$1, options[opt], Init); } }\n  maybeUpdateLineNumberWidth(this);\n  if (options.finishInit) { options.finishInit(this); }\n  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }\n  endOperation(this);\n  // Suppress optimizelegibility in Webkit, since it breaks text\n  // measuring on line wrapping boundaries.\n  if (webkit && options.lineWrapping &&\n      getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n    { display.lineDiv.style.textRendering = \"auto\"; }\n}\n\n// The default configuration options.\nCodeMirror$1.defaults = defaults;\n// Functions to run when options are changed.\nCodeMirror$1.optionHandlers = optionHandlers;\n\n// Attach the necessary event handlers when initializing the editor\nfunction registerEventHandlers(cm) {\n  var d = cm.display;\n  on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n  // Older IE's will not fire a second mousedown for a double click\n  if (ie && ie_version < 11)\n    { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n      if (signalDOMEvent(cm, e)) { return }\n      var pos = posFromMouse(cm, e);\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n      e_preventDefault(e);\n      var word = cm.findWordAt(pos);\n      extendSelection(cm.doc, word.anchor, word.head);\n    })); }\n  else\n    { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n  // Some browsers fire contextmenu *after* opening the menu, at\n  // which point we can't mess with it anymore. Context menu is\n  // handled in onMouseDown for these browsers.\n  if (!captureRightClick) { on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); }); }\n\n  // Used to suppress mouse event handling when a touch happens\n  var touchFinished, prevTouch = {end: 0};\n  function finishTouch() {\n    if (d.activeTouch) {\n      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n      prevTouch = d.activeTouch;\n      prevTouch.end = +new Date;\n    }\n  }\n  function isMouseLikeTouchEvent(e) {\n    if (e.touches.length != 1) { return false }\n    var touch = e.touches[0];\n    return touch.radiusX <= 1 && touch.radiusY <= 1\n  }\n  function farAway(touch, other) {\n    if (other.left == null) { return true }\n    var dx = other.left - touch.left, dy = other.top - touch.top;\n    return dx * dx + dy * dy > 20 * 20\n  }\n  on(d.scroller, \"touchstart\", function (e) {\n    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n      d.input.ensurePolled();\n      clearTimeout(touchFinished);\n      var now = +new Date;\n      d.activeTouch = {start: now, moved: false,\n                       prev: now - prevTouch.end <= 300 ? prevTouch : null};\n      if (e.touches.length == 1) {\n        d.activeTouch.left = e.touches[0].pageX;\n        d.activeTouch.top = e.touches[0].pageY;\n      }\n    }\n  });\n  on(d.scroller, \"touchmove\", function () {\n    if (d.activeTouch) { d.activeTouch.moved = true; }\n  });\n  on(d.scroller, \"touchend\", function (e) {\n    var touch = d.activeTouch;\n    if (touch && !eventInWidget(d, e) && touch.left != null &&\n        !touch.moved && new Date - touch.start < 300) {\n      var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n      if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n        { range = new Range(pos, pos); }\n      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n        { range = cm.findWordAt(pos); }\n      else // Triple tap\n        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n      cm.setSelection(range.anchor, range.head);\n      cm.focus();\n      e_preventDefault(e);\n    }\n    finishTouch();\n  });\n  on(d.scroller, \"touchcancel\", finishTouch);\n\n  // Sync scrolling between fake scrollbars and real scrollable\n  // area, ensure viewport is updated when scrolling.\n  on(d.scroller, \"scroll\", function () {\n    if (d.scroller.clientHeight) {\n      updateScrollTop(cm, d.scroller.scrollTop);\n      setScrollLeft(cm, d.scroller.scrollLeft, true);\n      signal(cm, \"scroll\", cm);\n    }\n  });\n\n  // Listen to wheel events in order to try and update the viewport on time.\n  on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n  on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n  // Prevent wrapper from ever scrolling\n  on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n  d.dragFunctions = {\n    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n    start: function (e) { return onDragStart(cm, e); },\n    drop: operation(cm, onDrop),\n    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n  };\n\n  var inp = d.input.getField();\n  on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n  on(inp, \"keydown\", operation(cm, onKeyDown));\n  on(inp, \"keypress\", operation(cm, onKeyPress));\n  on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n  on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n}\n\nvar initHooks = [];\nCodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };\n\n// Indent the given line. The how parameter can be \"smart\",\n// \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n// (typically set to true for forced single-line indents), empty\n// lines are not indented, and places where the mode returns Pass\n// are left alone.\nfunction indentLine(cm, n, how, aggressive) {\n  var doc = cm.doc, state;\n  if (how == null) { how = \"add\"; }\n  if (how == \"smart\") {\n    // Fall back to \"prev\" when the mode doesn't have an indentation\n    // method.\n    if (!doc.mode.indent) { how = \"prev\"; }\n    else { state = getContextBefore(cm, n).state; }\n  }\n\n  var tabSize = cm.options.tabSize;\n  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n  if (line.stateAfter) { line.stateAfter = null; }\n  var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n  if (!aggressive && !/\\S/.test(line.text)) {\n    indentation = 0;\n    how = \"not\";\n  } else if (how == \"smart\") {\n    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n    if (indentation == Pass || indentation > 150) {\n      if (!aggressive) { return }\n      how = \"prev\";\n    }\n  }\n  if (how == \"prev\") {\n    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n    else { indentation = 0; }\n  } else if (how == \"add\") {\n    indentation = curSpace + cm.options.indentUnit;\n  } else if (how == \"subtract\") {\n    indentation = curSpace - cm.options.indentUnit;\n  } else if (typeof how == \"number\") {\n    indentation = curSpace + how;\n  }\n  indentation = Math.max(0, indentation);\n\n  var indentString = \"\", pos = 0;\n  if (cm.options.indentWithTabs)\n    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n  if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n  if (indentString != curSpaceString) {\n    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n    line.stateAfter = null;\n    return true\n  } else {\n    // Ensure that, if the cursor was in the whitespace at the start\n    // of the line, it is moved to the end of that space.\n    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n      var range = doc.sel.ranges[i$1];\n      if (range.head.line == n && range.head.ch < curSpaceString.length) {\n        var pos$1 = Pos(n, curSpaceString.length);\n        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n        break\n      }\n    }\n  }\n}\n\n// This will be set to a {lineWise: bool, text: [string]} object, so\n// that, when pasting, we know what kind of selections the copied\n// text was made out of.\nvar lastCopied = null;\n\nfunction setLastCopied(newLastCopied) {\n  lastCopied = newLastCopied;\n}\n\nfunction applyTextInput(cm, inserted, deleted, sel, origin) {\n  var doc = cm.doc;\n  cm.display.shift = false;\n  if (!sel) { sel = doc.sel; }\n\n  var paste = cm.state.pasteIncoming || origin == \"paste\";\n  var textLines = splitLinesAuto(inserted), multiPaste = null;\n  // When pasing N lines into N selections, insert one line per selection\n  if (paste && sel.ranges.length > 1) {\n    if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n      if (sel.ranges.length % lastCopied.text.length == 0) {\n        multiPaste = [];\n        for (var i = 0; i < lastCopied.text.length; i++)\n          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n      }\n    } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n      multiPaste = map(textLines, function (l) { return [l]; });\n    }\n  }\n\n  var updateInput;\n  // Normal behavior is to insert the new text into every selection\n  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n    var range$$1 = sel.ranges[i$1];\n    var from = range$$1.from(), to = range$$1.to();\n    if (range$$1.empty()) {\n      if (deleted && deleted > 0) // Handle deletion\n        { from = Pos(from.line, from.ch - deleted); }\n      else if (cm.state.overwrite && !paste) // Handle overwrite\n        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n        { from = to = Pos(from.line, 0); }\n    }\n    updateInput = cm.curOp.updateInput;\n    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                       origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n    makeChange(cm.doc, changeEvent);\n    signalLater(cm, \"inputRead\", cm, changeEvent);\n  }\n  if (inserted && !paste)\n    { triggerElectric(cm, inserted); }\n\n  ensureCursorVisible(cm);\n  cm.curOp.updateInput = updateInput;\n  cm.curOp.typing = true;\n  cm.state.pasteIncoming = cm.state.cutIncoming = false;\n}\n\nfunction handlePaste(e, cm) {\n  var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n  if (pasted) {\n    e.preventDefault();\n    if (!cm.isReadOnly() && !cm.options.disableInput)\n      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n    return true\n  }\n}\n\nfunction triggerElectric(cm, inserted) {\n  // When an 'electric' character is inserted, immediately trigger a reindent\n  if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n  var sel = cm.doc.sel;\n\n  for (var i = sel.ranges.length - 1; i >= 0; i--) {\n    var range$$1 = sel.ranges[i];\n    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\n    var mode = cm.getModeAt(range$$1.head);\n    var indented = false;\n    if (mode.electricChars) {\n      for (var j = 0; j < mode.electricChars.length; j++)\n        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n          indented = indentLine(cm, range$$1.head.line, \"smart\");\n          break\n        } }\n    } else if (mode.electricInput) {\n      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\n        { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\n    }\n    if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\n  }\n}\n\nfunction copyableRanges(cm) {\n  var text = [], ranges = [];\n  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n    var line = cm.doc.sel.ranges[i].head.line;\n    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n    ranges.push(lineRange);\n    text.push(cm.getRange(lineRange.anchor, lineRange.head));\n  }\n  return {text: text, ranges: ranges}\n}\n\nfunction disableBrowserMagic(field, spellcheck) {\n  field.setAttribute(\"autocorrect\", \"off\");\n  field.setAttribute(\"autocapitalize\", \"off\");\n  field.setAttribute(\"spellcheck\", !!spellcheck);\n}\n\nfunction hiddenTextarea() {\n  var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n  var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n  // The textarea is kept positioned near the cursor to prevent the\n  // fact that it'll be scrolled into view on input from scrolling\n  // our fake cursor out of view. On webkit, when wrap=off, paste is\n  // very slow. So make the area wide instead.\n  if (webkit) { te.style.width = \"1000px\"; }\n  else { te.setAttribute(\"wrap\", \"off\"); }\n  // If border: 0; -- iOS fails to open keyboard (issue #1287)\n  if (ios) { te.style.border = \"1px solid black\"; }\n  disableBrowserMagic(te);\n  return div\n}\n\n// The publicly visible API. Note that methodOp(f) means\n// 'wrap f in an operation, performed on its `this` parameter'.\n\n// This is not the complete set of editor methods. Most of the\n// methods defined on the Doc type are also injected into\n// CodeMirror.prototype, for backwards compatibility and\n// convenience.\n\nvar addEditorMethods = function(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  var helpers = CodeMirror.helpers = {};\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); this.display.input.focus();},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") { return }\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        { operation(this, optionHandlers[option])(this, value, old); }\n      signal(this, \"optionChange\", this, option);\n    },\n\n    getOption: function(option) {return this.options[option]},\n    getDoc: function() {return this.doc},\n\n    addKeyMap: function(map$$1, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\n    },\n    removeKeyMap: function(map$$1) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        { if (maps[i] == map$$1 || maps[i].name == map$$1) {\n          maps.splice(i, 1);\n          return true\n        } }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n      insertSorted(this.state.overlays,\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                    priority: (options && options.priority) || 0},\n                   function (overlay) { return overlay.priority; });\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var this$1 = this;\n\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this$1.state.modeGen++;\n          regChange(this$1);\n          return\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n        else { dir = dir ? \"add\" : \"subtract\"; }\n      }\n      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n    }),\n    indentSelection: methodOp(function(how) {\n      var this$1 = this;\n\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range$$1 = ranges[i];\n        if (!range$$1.empty()) {\n          var from = range$$1.from(), to = range$$1.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            { indentLine(this$1, j, how); }\n          var newRanges = this$1.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n        } else if (range$$1.head.line > end) {\n          indentLine(this$1, range$$1.head.line, how, true);\n          end = range$$1.head.line;\n          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      return takeToken(this, pos, precise)\n    },\n\n    getLineTokens: function(line, precise) {\n      return takeToken(this, Pos(line), precise, true)\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) { type = styles[2]; }\n      else { for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n        else { type = styles[mid * 2 + 2]; break }\n      } }\n      var cut = type ? type.indexOf(\"overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) { return mode }\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0]\n    },\n\n    getHelpers: function(pos, type) {\n      var this$1 = this;\n\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) { return found }\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) { found.push(help[mode[type]]); }\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) { found.push(val); }\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n        var cur = help._global[i$1];\n        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\n          { found.push(cur.val); }\n      }\n      return found\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getContextBefore(this, line + 1, precise).state\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range$$1 = this.doc.sel.primary();\n      if (start == null) { pos = range$$1.head; }\n      else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n      else { pos = start ? range$$1.from() : range$$1.to(); }\n      return cursorCoords(this, pos, mode || \"page\")\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top)\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset)\n    },\n    heightAtLine: function(line, mode, includeWidgets) {\n      var end = false, lineObj;\n      if (typeof line == \"number\") {\n        var last = this.doc.first + this.doc.size - 1;\n        if (line < this.doc.first) { line = this.doc.first; }\n        else if (line > last) { line = last; end = true; }\n        lineObj = getLine(this.doc, line);\n      } else {\n        lineObj = line;\n      }\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0)\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display) },\n    defaultCharWidth: function() { return charWidth(this.display) },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      node.setAttribute(\"cm-ignore-events\", \"true\");\n      this.display.input.setUneditable(node);\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          { top = pos.top - node.offsetHeight; }\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          { top = pos.bottom; }\n        if (left + node.offsetWidth > hspace)\n          { left = hspace - node.offsetWidth; }\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") { left = 0; }\n        else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n    triggerOnMouseDown: methodOp(onMouseDown),\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        { return commands[cmd].call(null, this) }\n    },\n\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n    findPosH: function(from, amount, unit, visually) {\n      var this$1 = this;\n\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        cur = findPosH(this$1.doc, cur, dir, unit, visually);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      this.extendSelectionsBy(function (range$$1) {\n        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\n          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\n        else\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        { doc.replaceSelection(\"\", null, \"+delete\"); }\n      else\n        { deleteNearSelection(this, function (range$$1) {\n          var other = findPosH(doc, range$$1.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\n        }); }\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var this$1 = this;\n\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        var coords = cursorCoords(this$1, cur, \"div\");\n        if (x == null) { x = coords.left; }\n        else { coords.left = x; }\n        cur = findPosV(this$1, coords, dir, unit);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      var doc = this.doc, goals = [];\n      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function (range$$1) {\n        if (collapse)\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n        var headPos = cursorCoords(this$1, range$$1.head, \"div\");\n        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\n        goals.push(headPos.left);\n        var pos = findPosV(this$1, headPos, dir, unit);\n        if (unit == \"page\" && range$$1 == doc.sel.primary())\n          { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n        return pos\n      }, sel_move);\n      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n        { doc.sel.ranges[i].goalColumn = goals[i]; } }\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function (ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n          : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n        while (start > 0 && check(line.charAt(start - 1))) { --start; }\n        while (end < line.length && check(line.charAt(end))) { ++end; }\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end))\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) { return }\n      if (this.state.overwrite = !this.state.overwrite)\n        { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n      else\n        { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return this.display.input.getField() == activeElt() },\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n    },\n\n    scrollIntoView: methodOp(function(range$$1, margin) {\n      if (range$$1 == null) {\n        range$$1 = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) { margin = this.options.cursorScrollMargin; }\n      } else if (typeof range$$1 == \"number\") {\n        range$$1 = {from: Pos(range$$1, 0), to: null};\n      } else if (range$$1.from == null) {\n        range$$1 = {from: range$$1, to: null};\n      }\n      if (!range$$1.to) { range$$1.to = range$$1.from; }\n      range$$1.margin = margin || 0;\n\n      if (range$$1.from.line != null) {\n        scrollToRange(this, range$$1);\n      } else {\n        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var this$1 = this;\n\n      var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n      if (width != null) { this.display.wrapper.style.width = interpret(width); }\n      if (height != null) { this.display.wrapper.style.height = interpret(height); }\n      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n      var lineNo$$1 = this.display.viewFrom;\n      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\n        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\n        ++lineNo$$1;\n      });\n      this.curOp.forceUpdate = true;\n      signal(this, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f)},\n    startOperation: function(){return startOperation(this)},\n    endOperation: function(){return endOperation(this)},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        { estimateLineHeights(this); }\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      this.display.input.reset();\n      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old\n    }),\n\n    getInputField: function(){return this.display.input.getField()},\n    getWrapperElement: function(){return this.display.wrapper},\n    getScrollerElement: function(){return this.display.scroller},\n    getGutterElement: function(){return this.display.gutters}\n  };\n  eventMixin(CodeMirror);\n\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n};\n\n// Used for horizontal relative motion. Dir is -1 or 1 (left or\n// right), unit can be \"char\", \"column\" (like char, but doesn't\n// cross line boundaries), \"word\" (across next word), or \"group\" (to\n// the start of next group of word or non-word-non-whitespace\n// chars). The visually param controls whether, in right-to-left\n// text, direction 1 means to move towards the next index in the\n// string, or towards the character to the right of the current\n// position. The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosH(doc, pos, dir, unit, visually) {\n  var oldPos = pos;\n  var origDir = dir;\n  var lineObj = getLine(doc, pos.line);\n  function findNextLine() {\n    var l = pos.line + dir;\n    if (l < doc.first || l >= doc.first + doc.size) { return false }\n    pos = new Pos(l, pos.ch, pos.sticky);\n    return lineObj = getLine(doc, l)\n  }\n  function moveOnce(boundToLine) {\n    var next;\n    if (visually) {\n      next = moveVisually(doc.cm, lineObj, pos, dir);\n    } else {\n      next = moveLogically(lineObj, pos, dir);\n    }\n    if (next == null) {\n      if (!boundToLine && findNextLine())\n        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\n      else\n        { return false }\n    } else {\n      pos = next;\n    }\n    return true\n  }\n\n  if (unit == \"char\") {\n    moveOnce();\n  } else if (unit == \"column\") {\n    moveOnce(true);\n  } else if (unit == \"word\" || unit == \"group\") {\n    var sawType = null, group = unit == \"group\";\n    var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n    for (var first = true;; first = false) {\n      if (dir < 0 && !moveOnce(!first)) { break }\n      var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n      var type = isWordChar(cur, helper) ? \"w\"\n        : group && cur == \"\\n\" ? \"n\"\n        : !group || /\\s/.test(cur) ? null\n        : \"p\";\n      if (group && !first && !type) { type = \"s\"; }\n      if (sawType && sawType != type) {\n        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n        break\n      }\n\n      if (type) { sawType = type; }\n      if (dir > 0 && !moveOnce(!first)) { break }\n    }\n  }\n  var result = skipAtomic(doc, pos, oldPos, origDir, true);\n  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n  return result\n}\n\n// For relative vertical movement. Dir may be -1 or 1. Unit can be\n// \"page\" or \"line\". The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosV(cm, pos, dir, unit) {\n  var doc = cm.doc, x = pos.left, y;\n  if (unit == \"page\") {\n    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n  } else if (unit == \"line\") {\n    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n  }\n  var target;\n  for (;;) {\n    target = coordsChar(cm, x, y);\n    if (!target.outside) { break }\n    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n    y += dir * 5;\n  }\n  return target\n}\n\n// CONTENTEDITABLE INPUT STYLE\n\nvar ContentEditableInput = function(cm) {\n  this.cm = cm;\n  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n  this.polling = new Delayed();\n  this.composing = null;\n  this.gracePeriod = false;\n  this.readDOMTimeout = null;\n};\n\nContentEditableInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = input.cm;\n  var div = input.div = display.lineDiv;\n  disableBrowserMagic(div, cm.options.spellcheck);\n\n  on(div, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n    // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n  });\n\n  on(div, \"compositionstart\", function (e) {\n    this$1.composing = {data: e.data, done: false};\n  });\n  on(div, \"compositionupdate\", function (e) {\n    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n  });\n  on(div, \"compositionend\", function (e) {\n    if (this$1.composing) {\n      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n      this$1.composing.done = true;\n    }\n  });\n\n  on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n  on(div, \"input\", function () {\n    if (!this$1.composing) { this$1.readFromDOMSoon(); }\n  });\n\n  function onCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n      if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.operation(function () {\n          cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n          cm.replaceSelection(\"\", null, \"cut\");\n        });\n      }\n    }\n    if (e.clipboardData) {\n      e.clipboardData.clearData();\n      var content = lastCopied.text.join(\"\\n\");\n      // iOS exposes the clipboard API, but seems to discard content inserted into it\n      e.clipboardData.setData(\"Text\", content);\n      if (e.clipboardData.getData(\"Text\") == content) {\n        e.preventDefault();\n        return\n      }\n    }\n    // Old-fashioned briefly-focus-a-textarea hack\n    var kludge = hiddenTextarea(), te = kludge.firstChild;\n    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n    te.value = lastCopied.text.join(\"\\n\");\n    var hadFocus = document.activeElement;\n    selectInput(te);\n    setTimeout(function () {\n      cm.display.lineSpace.removeChild(kludge);\n      hadFocus.focus();\n      if (hadFocus == div) { input.showPrimarySelection(); }\n    }, 50);\n  }\n  on(div, \"copy\", onCopyCut);\n  on(div, \"cut\", onCopyCut);\n};\n\nContentEditableInput.prototype.prepareSelection = function () {\n  var result = prepareSelection(this.cm, false);\n  result.focus = this.cm.state.focused;\n  return result\n};\n\nContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n  if (!info || !this.cm.display.view.length) { return }\n  if (info.focus || takeFocus) { this.showPrimarySelection(); }\n  this.showMultipleSelections(info);\n};\n\nContentEditableInput.prototype.showPrimarySelection = function () {\n  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n  var from = prim.from(), to = prim.to();\n\n  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n      cmp(minPos(curAnchor, curFocus), from) == 0 &&\n      cmp(maxPos(curAnchor, curFocus), to) == 0)\n    { return }\n\n  var view = cm.display.view;\n  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n      {node: view[0].measure.map[2], offset: 0};\n  var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n  if (!end) {\n    var measure = view[view.length - 1].measure;\n    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\n  }\n\n  if (!start || !end) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var old = sel.rangeCount && sel.getRangeAt(0), rng;\n  try { rng = range(start.node, start.offset, end.offset, end.node); }\n  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n  if (rng) {\n    if (!gecko && cm.state.focused) {\n      sel.collapse(start.node, start.offset);\n      if (!rng.collapsed) {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n    } else {\n      sel.removeAllRanges();\n      sel.addRange(rng);\n    }\n    if (old && sel.anchorNode == null) { sel.addRange(old); }\n    else if (gecko) { this.startGracePeriod(); }\n  }\n  this.rememberSelection();\n};\n\nContentEditableInput.prototype.startGracePeriod = function () {\n    var this$1 = this;\n\n  clearTimeout(this.gracePeriod);\n  this.gracePeriod = setTimeout(function () {\n    this$1.gracePeriod = false;\n    if (this$1.selectionChanged())\n      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n  }, 20);\n};\n\nContentEditableInput.prototype.showMultipleSelections = function (info) {\n  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n};\n\nContentEditableInput.prototype.rememberSelection = function () {\n  var sel = window.getSelection();\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n};\n\nContentEditableInput.prototype.selectionInEditor = function () {\n  var sel = window.getSelection();\n  if (!sel.rangeCount) { return false }\n  var node = sel.getRangeAt(0).commonAncestorContainer;\n  return contains(this.div, node)\n};\n\nContentEditableInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\") {\n    if (!this.selectionInEditor())\n      { this.showSelection(this.prepareSelection(), true); }\n    this.div.focus();\n  }\n};\nContentEditableInput.prototype.blur = function () { this.div.blur(); };\nContentEditableInput.prototype.getField = function () { return this.div };\n\nContentEditableInput.prototype.supportsTouch = function () { return true };\n\nContentEditableInput.prototype.receivedFocus = function () {\n  var input = this;\n  if (this.selectionInEditor())\n    { this.pollSelection(); }\n  else\n    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n  function poll() {\n    if (input.cm.state.focused) {\n      input.pollSelection();\n      input.polling.set(input.cm.options.pollInterval, poll);\n    }\n  }\n  this.polling.set(this.cm.options.pollInterval, poll);\n};\n\nContentEditableInput.prototype.selectionChanged = function () {\n  var sel = window.getSelection();\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n};\n\nContentEditableInput.prototype.pollSelection = function () {\n  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n  var sel = window.getSelection(), cm = this.cm;\n  // On Android Chrome (version 56, at least), backspacing into an\n  // uneditable block element will put the cursor in that element,\n  // and then, because it's not editable, hide the virtual keyboard.\n  // Because Android doesn't allow us to actually detect backspace\n  // presses in a sane way, this code checks for when that happens\n  // and simulates a backspace press in this case.\n  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\n    this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n    this.blur();\n    this.focus();\n    return\n  }\n  if (this.composing) { return }\n  this.rememberSelection();\n  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (anchor && head) { runInOp(cm, function () {\n    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n  }); }\n};\n\nContentEditableInput.prototype.pollContent = function () {\n  if (this.readDOMTimeout != null) {\n    clearTimeout(this.readDOMTimeout);\n    this.readDOMTimeout = null;\n  }\n\n  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n  var from = sel.from(), to = sel.to();\n  if (from.ch == 0 && from.line > cm.firstLine())\n    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n    { to = Pos(to.line + 1, 0); }\n  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n  var fromIndex, fromLine, fromNode;\n  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n    fromLine = lineNo(display.view[0].line);\n    fromNode = display.view[0].node;\n  } else {\n    fromLine = lineNo(display.view[fromIndex].line);\n    fromNode = display.view[fromIndex - 1].node.nextSibling;\n  }\n  var toIndex = findViewIndex(cm, to.line);\n  var toLine, toNode;\n  if (toIndex == display.view.length - 1) {\n    toLine = display.viewTo - 1;\n    toNode = display.lineDiv.lastChild;\n  } else {\n    toLine = lineNo(display.view[toIndex + 1].line) - 1;\n    toNode = display.view[toIndex + 1].node.previousSibling;\n  }\n\n  if (!fromNode) { return false }\n  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n  while (newText.length > 1 && oldText.length > 1) {\n    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n    else { break }\n  }\n\n  var cutFront = 0, cutEnd = 0;\n  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n    { ++cutFront; }\n  var newBot = lst(newText), oldBot = lst(oldText);\n  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                           oldBot.length - (oldText.length == 1 ? cutFront : 0));\n  while (cutEnd < maxCutEnd &&\n         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n    { ++cutEnd; }\n  // Try to move start of change to start of selection if ambiguous\n  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n    while (cutFront && cutFront > from.ch &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n      cutFront--;\n      cutEnd++;\n    }\n  }\n\n  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n  newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n  var chFrom = Pos(fromLine, cutFront);\n  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n    replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n    return true\n  }\n};\n\nContentEditableInput.prototype.ensurePolled = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.reset = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.forceCompositionEnd = function () {\n  if (!this.composing) { return }\n  clearTimeout(this.readDOMTimeout);\n  this.composing = null;\n  this.updateFromDOM();\n  this.div.blur();\n  this.div.focus();\n};\nContentEditableInput.prototype.readFromDOMSoon = function () {\n    var this$1 = this;\n\n  if (this.readDOMTimeout != null) { return }\n  this.readDOMTimeout = setTimeout(function () {\n    this$1.readDOMTimeout = null;\n    if (this$1.composing) {\n      if (this$1.composing.done) { this$1.composing = null; }\n      else { return }\n    }\n    this$1.updateFromDOM();\n  }, 80);\n};\n\nContentEditableInput.prototype.updateFromDOM = function () {\n    var this$1 = this;\n\n  if (this.cm.isReadOnly() || !this.pollContent())\n    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n};\n\nContentEditableInput.prototype.setUneditable = function (node) {\n  node.contentEditable = \"false\";\n};\n\nContentEditableInput.prototype.onKeyPress = function (e) {\n  if (e.charCode == 0) { return }\n  e.preventDefault();\n  if (!this.cm.isReadOnly())\n    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n};\n\nContentEditableInput.prototype.readOnlyChanged = function (val) {\n  this.div.contentEditable = String(val != \"nocursor\");\n};\n\nContentEditableInput.prototype.onContextMenu = function () {};\nContentEditableInput.prototype.resetPosition = function () {};\n\nContentEditableInput.prototype.needsContentAttribute = true;\n\nfunction posToDOM(cm, pos) {\n  var view = findViewForLine(cm, pos.line);\n  if (!view || view.hidden) { return null }\n  var line = getLine(cm.doc, pos.line);\n  var info = mapFromLineView(view, line, pos.line);\n\n  var order = getOrder(line, cm.doc.direction), side = \"left\";\n  if (order) {\n    var partPos = getBidiPartAt(order, pos.ch);\n    side = partPos % 2 ? \"right\" : \"left\";\n  }\n  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n  result.offset = result.collapse == \"right\" ? result.end : result.start;\n  return result\n}\n\nfunction isInGutter(node) {\n  for (var scan = node; scan; scan = scan.parentNode)\n    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n  return false\n}\n\nfunction badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\nfunction domTextBetween(cm, from, to, fromLine, toLine) {\n  var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n  function close() {\n    if (closing) {\n      text += lineSep;\n      closing = false;\n    }\n  }\n  function addText(str) {\n    if (str) {\n      close();\n      text += str;\n    }\n  }\n  function walk(node) {\n    if (node.nodeType == 1) {\n      var cmText = node.getAttribute(\"cm-text\");\n      if (cmText != null) {\n        addText(cmText || node.textContent.replace(/\\u200b/g, \"\"));\n        return\n      }\n      var markerID = node.getAttribute(\"cm-marker\"), range$$1;\n      if (markerID) {\n        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n        if (found.length && (range$$1 = found[0].find(0)))\n          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\n        return\n      }\n      if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);\n      if (isBlock) { close(); }\n      for (var i = 0; i < node.childNodes.length; i++)\n        { walk(node.childNodes[i]); }\n      if (isBlock) { closing = true; }\n    } else if (node.nodeType == 3) {\n      addText(node.nodeValue);\n    }\n  }\n  for (;;) {\n    walk(from);\n    if (from == to) { break }\n    from = from.nextSibling;\n  }\n  return text\n}\n\nfunction domToPos(cm, node, offset) {\n  var lineNode;\n  if (node == cm.display.lineDiv) {\n    lineNode = cm.display.lineDiv.childNodes[offset];\n    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n    node = null; offset = 0;\n  } else {\n    for (lineNode = node;; lineNode = lineNode.parentNode) {\n      if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n    }\n  }\n  for (var i = 0; i < cm.display.view.length; i++) {\n    var lineView = cm.display.view[i];\n    if (lineView.node == lineNode)\n      { return locateNodeInLineView(lineView, node, offset) }\n  }\n}\n\nfunction locateNodeInLineView(lineView, node, offset) {\n  var wrapper = lineView.text.firstChild, bad = false;\n  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n  if (node == wrapper) {\n    bad = true;\n    node = wrapper.childNodes[offset];\n    offset = 0;\n    if (!node) {\n      var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n      return badPos(Pos(lineNo(line), line.text.length), bad)\n    }\n  }\n\n  var textNode = node.nodeType == 3 ? node : null, topNode = node;\n  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n    textNode = node.firstChild;\n    if (offset) { offset = textNode.nodeValue.length; }\n  }\n  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n  var measure = lineView.measure, maps = measure.maps;\n\n  function find(textNode, topNode, offset) {\n    for (var i = -1; i < (maps ? maps.length : 0); i++) {\n      var map$$1 = i < 0 ? measure.map : maps[i];\n      for (var j = 0; j < map$$1.length; j += 3) {\n        var curNode = map$$1[j + 2];\n        if (curNode == textNode || curNode == topNode) {\n          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n          var ch = map$$1[j] + offset;\n          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\n          return Pos(line, ch)\n        }\n      }\n    }\n  }\n  var found = find(textNode, topNode, offset);\n  if (found) { return badPos(found, bad) }\n\n  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n    found = find(after, after.firstChild, 0);\n    if (found)\n      { return badPos(Pos(found.line, found.ch - dist), bad) }\n    else\n      { dist += after.textContent.length; }\n  }\n  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n    found = find(before, before.firstChild, -1);\n    if (found)\n      { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n    else\n      { dist$1 += before.textContent.length; }\n  }\n}\n\n// TEXTAREA INPUT STYLE\n\nvar TextareaInput = function(cm) {\n  this.cm = cm;\n  // See input.poll and input.reset\n  this.prevInput = \"\";\n\n  // Flag that indicates whether we expect input to appear real soon\n  // now (after some event like 'keypress' or 'input') and are\n  // polling intensively.\n  this.pollingFast = false;\n  // Self-resetting timeout for the poller\n  this.polling = new Delayed();\n  // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n  this.hasSelection = false;\n  this.composing = null;\n};\n\nTextareaInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = this.cm;\n\n  // Wraps and hides input textarea\n  var div = this.wrapper = hiddenTextarea();\n  // The semihidden textarea that is focused when the editor is\n  // focused, and receives input.\n  var te = this.textarea = div.firstChild;\n  display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\n  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n  if (ios) { te.style.width = \"0px\"; }\n\n  on(te, \"input\", function () {\n    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n    input.poll();\n  });\n\n  on(te, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n    cm.state.pasteIncoming = true;\n    input.fastPoll();\n  });\n\n  function prepareCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.setSelections(ranges.ranges, null, sel_dontScroll);\n      } else {\n        input.prevInput = \"\";\n        te.value = ranges.text.join(\"\\n\");\n        selectInput(te);\n      }\n    }\n    if (e.type == \"cut\") { cm.state.cutIncoming = true; }\n  }\n  on(te, \"cut\", prepareCopyCut);\n  on(te, \"copy\", prepareCopyCut);\n\n  on(display.scroller, \"paste\", function (e) {\n    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n    cm.state.pasteIncoming = true;\n    input.focus();\n  });\n\n  // Prevent normal selection in the editor (we handle our own)\n  on(display.lineSpace, \"selectstart\", function (e) {\n    if (!eventInWidget(display, e)) { e_preventDefault(e); }\n  });\n\n  on(te, \"compositionstart\", function () {\n    var start = cm.getCursor(\"from\");\n    if (input.composing) { input.composing.range.clear(); }\n    input.composing = {\n      start: start,\n      range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n    };\n  });\n  on(te, \"compositionend\", function () {\n    if (input.composing) {\n      input.poll();\n      input.composing.range.clear();\n      input.composing = null;\n    }\n  });\n};\n\nTextareaInput.prototype.prepareSelection = function () {\n  // Redraw the selection and/or cursor\n  var cm = this.cm, display = cm.display, doc = cm.doc;\n  var result = prepareSelection(cm);\n\n  // Move the hidden textarea near the cursor to prevent scrolling artifacts\n  if (cm.options.moveInputWithCursor) {\n    var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                        headPos.top + lineOff.top - wrapOff.top));\n    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                         headPos.left + lineOff.left - wrapOff.left));\n  }\n\n  return result\n};\n\nTextareaInput.prototype.showSelection = function (drawn) {\n  var cm = this.cm, display = cm.display;\n  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n  removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n  if (drawn.teTop != null) {\n    this.wrapper.style.top = drawn.teTop + \"px\";\n    this.wrapper.style.left = drawn.teLeft + \"px\";\n  }\n};\n\n// Reset the input to correspond to the selection (or to be empty,\n// when not typing and nothing is selected)\nTextareaInput.prototype.reset = function (typing) {\n  if (this.contextMenuPending || this.composing) { return }\n  var cm = this.cm;\n  if (cm.somethingSelected()) {\n    this.prevInput = \"\";\n    var content = cm.getSelection();\n    this.textarea.value = content;\n    if (cm.state.focused) { selectInput(this.textarea); }\n    if (ie && ie_version >= 9) { this.hasSelection = content; }\n  } else if (!typing) {\n    this.prevInput = this.textarea.value = \"\";\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n  }\n};\n\nTextareaInput.prototype.getField = function () { return this.textarea };\n\nTextareaInput.prototype.supportsTouch = function () { return false };\n\nTextareaInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n    try { this.textarea.focus(); }\n    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n  }\n};\n\nTextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\nTextareaInput.prototype.resetPosition = function () {\n  this.wrapper.style.top = this.wrapper.style.left = 0;\n};\n\nTextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n// Poll for input changes, using the normal rate of polling. This\n// runs as long as the editor is focused.\nTextareaInput.prototype.slowPoll = function () {\n    var this$1 = this;\n\n  if (this.pollingFast) { return }\n  this.polling.set(this.cm.options.pollInterval, function () {\n    this$1.poll();\n    if (this$1.cm.state.focused) { this$1.slowPoll(); }\n  });\n};\n\n// When an event has just come in that is likely to add or change\n// something in the input textarea, we poll faster, to ensure that\n// the change appears on the screen quickly.\nTextareaInput.prototype.fastPoll = function () {\n  var missed = false, input = this;\n  input.pollingFast = true;\n  function p() {\n    var changed = input.poll();\n    if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n    else {input.pollingFast = false; input.slowPoll();}\n  }\n  input.polling.set(20, p);\n};\n\n// Read input from the textarea, and update the document to match.\n// When something is selected, it is present in the textarea, and\n// selected (unless it is huge, in which case a placeholder is\n// used). When nothing is selected, the cursor sits after previously\n// seen text (can be empty), which is stored in prevInput (we must\n// not reset the textarea when typing, because that breaks IME).\nTextareaInput.prototype.poll = function () {\n    var this$1 = this;\n\n  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n  // Since this is called a *lot*, try to bail out as cheaply as\n  // possible when it is clear that nothing happened. hasSelection\n  // will be the case when there is a lot of text in the textarea,\n  // in which case reading its value would be expensive.\n  if (this.contextMenuPending || !cm.state.focused ||\n      (hasSelection(input) && !prevInput && !this.composing) ||\n      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n    { return false }\n\n  var text = input.value;\n  // If nothing changed, bail.\n  if (text == prevInput && !cm.somethingSelected()) { return false }\n  // Work around nonsensical selection resetting in IE9/10, and\n  // inexplicable appearance of private area unicode characters on\n  // some key combos in Mac (#2689).\n  if (ie && ie_version >= 9 && this.hasSelection === text ||\n      mac && /[\\uf700-\\uf7ff]/.test(text)) {\n    cm.display.input.reset();\n    return false\n  }\n\n  if (cm.doc.sel == cm.display.selForContextMenu) {\n    var first = text.charCodeAt(0);\n    if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n    if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n  }\n  // Find the part of the input that is actually new\n  var same = 0, l = Math.min(prevInput.length, text.length);\n  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n  runInOp(cm, function () {\n    applyTextInput(cm, text.slice(same), prevInput.length - same,\n                   null, this$1.composing ? \"*compose\" : null);\n\n    // Don't leave long text in the textarea, since it makes further polling slow\n    if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n    else { this$1.prevInput = text; }\n\n    if (this$1.composing) {\n      this$1.composing.range.clear();\n      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                         {className: \"CodeMirror-composing\"});\n    }\n  });\n  return true\n};\n\nTextareaInput.prototype.ensurePolled = function () {\n  if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n};\n\nTextareaInput.prototype.onKeyPress = function () {\n  if (ie && ie_version >= 9) { this.hasSelection = null; }\n  this.fastPoll();\n};\n\nTextareaInput.prototype.onContextMenu = function (e) {\n  var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n  if (!pos || presto) { return } // Opera is difficult.\n\n  // Reset the current text selection only if the click is done outside of the selection\n  // and 'resetSelectionOnContextMenu' option is true.\n  var reset = cm.options.resetSelectionOnContextMenu;\n  if (reset && cm.doc.sel.contains(pos) == -1)\n    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n  input.wrapper.style.cssText = \"position: absolute\";\n  var wrapperBox = input.wrapper.getBoundingClientRect();\n  te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n  var oldScrollY;\n  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n  display.input.focus();\n  if (webkit) { window.scrollTo(null, oldScrollY); }\n  display.input.reset();\n  // Adds \"Select all\" to context menu in FF\n  if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n  input.contextMenuPending = true;\n  display.selForContextMenu = cm.doc.sel;\n  clearTimeout(display.detectingSelectAll);\n\n  // Select-all will be greyed out if there's nothing to select, so\n  // this adds a zero-width space so that we can later check whether\n  // it got selected.\n  function prepareSelectAllHack() {\n    if (te.selectionStart != null) {\n      var selected = cm.somethingSelected();\n      var extval = \"\\u200b\" + (selected ? te.value : \"\");\n      te.value = \"\\u21da\"; // Used to catch context-menu undo\n      te.value = extval;\n      input.prevInput = selected ? \"\" : \"\\u200b\";\n      te.selectionStart = 1; te.selectionEnd = extval.length;\n      // Re-set this, in case some other handler touched the\n      // selection in the meantime.\n      display.selForContextMenu = cm.doc.sel;\n    }\n  }\n  function rehide() {\n    input.contextMenuPending = false;\n    input.wrapper.style.cssText = oldWrapperCSS;\n    te.style.cssText = oldCSS;\n    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n    // Try to detect the user choosing select-all\n    if (te.selectionStart != null) {\n      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n      var i = 0, poll = function () {\n        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n            te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n          operation(cm, selectAll)(cm);\n        } else if (i++ < 10) {\n          display.detectingSelectAll = setTimeout(poll, 500);\n        } else {\n          display.selForContextMenu = null;\n          display.input.reset();\n        }\n      };\n      display.detectingSelectAll = setTimeout(poll, 200);\n    }\n  }\n\n  if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n  if (captureRightClick) {\n    e_stop(e);\n    var mouseup = function () {\n      off(window, \"mouseup\", mouseup);\n      setTimeout(rehide, 20);\n    };\n    on(window, \"mouseup\", mouseup);\n  } else {\n    setTimeout(rehide, 50);\n  }\n};\n\nTextareaInput.prototype.readOnlyChanged = function (val) {\n  if (!val) { this.reset(); }\n  this.textarea.disabled = val == \"nocursor\";\n};\n\nTextareaInput.prototype.setUneditable = function () {};\n\nTextareaInput.prototype.needsContentAttribute = false;\n\nfunction fromTextArea(textarea, options) {\n  options = options ? copyObj(options) : {};\n  options.value = textarea.value;\n  if (!options.tabindex && textarea.tabIndex)\n    { options.tabindex = textarea.tabIndex; }\n  if (!options.placeholder && textarea.placeholder)\n    { options.placeholder = textarea.placeholder; }\n  // Set autofocus to true if this textarea is focused, or if it has\n  // autofocus and no other element is focused.\n  if (options.autofocus == null) {\n    var hasFocus = activeElt();\n    options.autofocus = hasFocus == textarea ||\n      textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n  }\n\n  function save() {textarea.value = cm.getValue();}\n\n  var realSubmit;\n  if (textarea.form) {\n    on(textarea.form, \"submit\", save);\n    // Deplorable hack to make the submit method do the right thing.\n    if (!options.leaveSubmitMethodAlone) {\n      var form = textarea.form;\n      realSubmit = form.submit;\n      try {\n        var wrappedSubmit = form.submit = function () {\n          save();\n          form.submit = realSubmit;\n          form.submit();\n          form.submit = wrappedSubmit;\n        };\n      } catch(e) {}\n    }\n  }\n\n  options.finishInit = function (cm) {\n    cm.save = save;\n    cm.getTextArea = function () { return textarea; };\n    cm.toTextArea = function () {\n      cm.toTextArea = isNaN; // Prevent this from being ran twice\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        off(textarea.form, \"submit\", save);\n        if (typeof textarea.form.submit == \"function\")\n          { textarea.form.submit = realSubmit; }\n      }\n    };\n  };\n\n  textarea.style.display = \"none\";\n  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n    options);\n  return cm\n}\n\nfunction addLegacyProps(CodeMirror) {\n  CodeMirror.off = off;\n  CodeMirror.on = on;\n  CodeMirror.wheelEventPixels = wheelEventPixels;\n  CodeMirror.Doc = Doc;\n  CodeMirror.splitLines = splitLinesAuto;\n  CodeMirror.countColumn = countColumn;\n  CodeMirror.findColumn = findColumn;\n  CodeMirror.isWordChar = isWordCharBasic;\n  CodeMirror.Pass = Pass;\n  CodeMirror.signal = signal;\n  CodeMirror.Line = Line;\n  CodeMirror.changeEnd = changeEnd;\n  CodeMirror.scrollbarModel = scrollbarModel;\n  CodeMirror.Pos = Pos;\n  CodeMirror.cmpPos = cmp;\n  CodeMirror.modes = modes;\n  CodeMirror.mimeModes = mimeModes;\n  CodeMirror.resolveMode = resolveMode;\n  CodeMirror.getMode = getMode;\n  CodeMirror.modeExtensions = modeExtensions;\n  CodeMirror.extendMode = extendMode;\n  CodeMirror.copyState = copyState;\n  CodeMirror.startState = startState;\n  CodeMirror.innerMode = innerMode;\n  CodeMirror.commands = commands;\n  CodeMirror.keyMap = keyMap;\n  CodeMirror.keyName = keyName;\n  CodeMirror.isModifierKey = isModifierKey;\n  CodeMirror.lookupKey = lookupKey;\n  CodeMirror.normalizeKeyMap = normalizeKeyMap;\n  CodeMirror.StringStream = StringStream;\n  CodeMirror.SharedTextMarker = SharedTextMarker;\n  CodeMirror.TextMarker = TextMarker;\n  CodeMirror.LineWidget = LineWidget;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.addClass = addClass;\n  CodeMirror.contains = contains;\n  CodeMirror.rmClass = rmClass;\n  CodeMirror.keyNames = keyNames;\n}\n\n// EDITOR CONSTRUCTOR\n\ndefineOptions(CodeMirror$1);\n\naddEditorMethods(CodeMirror$1);\n\n// Set up methods on CodeMirror's prototype to redirect to the editor's document.\nvar dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\nfor (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n  { CodeMirror$1.prototype[prop] = (function(method) {\n    return function() {return method.apply(this.doc, arguments)}\n  })(Doc.prototype[prop]); } }\n\neventMixin(Doc);\n\n// INPUT HANDLING\n\nCodeMirror$1.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n// MODE DEFINITION AND QUERYING\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nCodeMirror$1.defineMode = function(name/*, mode, */) {\n  if (!CodeMirror$1.defaults.mode && name != \"null\") { CodeMirror$1.defaults.mode = name; }\n  defineMode.apply(this, arguments);\n};\n\nCodeMirror$1.defineMIME = defineMIME;\n\n// Minimal default mode.\nCodeMirror$1.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\nCodeMirror$1.defineMIME(\"text/plain\", \"null\");\n\n// EXTENSIONS\n\nCodeMirror$1.defineExtension = function (name, func) {\n  CodeMirror$1.prototype[name] = func;\n};\nCodeMirror$1.defineDocExtension = function (name, func) {\n  Doc.prototype[name] = func;\n};\n\nCodeMirror$1.fromTextArea = fromTextArea;\n\naddLegacyProps(CodeMirror$1);\n\nCodeMirror$1.version = \"5.31.0\";\n\nreturn CodeMirror$1;\n\n})));\n\n\n/***/ }),\n\n/***/ \"CjAo\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".cm-s-eclipse span.cm-meta{color:#ff1717}.cm-s-eclipse span.cm-keyword{line-height:1em;font-weight:700;color:#7f0055}.cm-s-eclipse span.cm-atom{color:#219}.cm-s-eclipse span.cm-number{color:#164}.cm-s-eclipse span.cm-def{color:#00f}.cm-s-eclipse span.cm-variable{color:#000}.cm-s-eclipse span.cm-type,.cm-s-eclipse span.cm-variable-2,.cm-s-eclipse span.cm-variable-3{color:#0000c0}.cm-s-eclipse span.cm-operator,.cm-s-eclipse span.cm-property{color:#000}.cm-s-eclipse span.cm-comment{color:#3f7f5f}.cm-s-eclipse span.cm-string{color:#2a00ff}.cm-s-eclipse span.cm-string-2{color:#f50}.cm-s-eclipse span.cm-qualifier{color:#555}.cm-s-eclipse span.cm-builtin{color:#30a}.cm-s-eclipse span.cm-bracket{color:#cc7}.cm-s-eclipse span.cm-tag{color:#170}.cm-s-eclipse span.cm-attribute{color:#00c}.cm-s-eclipse span.cm-link{color:#219}.cm-s-eclipse span.cm-error{color:red}.cm-s-eclipse .CodeMirror-activeline-background{background:#e8f2ff}.cm-s-eclipse .CodeMirror-matchingbracket{outline:1px solid grey;color:#000!important}\", \"\", {\"version\":3,\"sources\":[\"/home/travis/build/voorhoede/manifiesta/node_modules/codemirror/theme/eclipse.css\"],\"names\":[],\"mappings\":\"AAAA,2BAA6B,aAAe,CAAE,AAC9C,8BAAgC,gBAAiB,AAAC,gBAAkB,AAAC,aAAe,CAAE,AACtF,2BAA6B,UAAY,CAAE,AAC3C,6BAA+B,UAAY,CAAE,AAC7C,0BAA4B,UAAY,CAAE,AAC1C,+BAAiC,UAAa,CAAE,AAEhD,6FAA+D,aAAe,CAAE,AAEhF,8DAAiC,UAAa,CAAE,AAChD,8BAAgC,aAAe,CAAE,AACjD,6BAA+B,aAAe,CAAE,AAChD,+BAAiC,UAAY,CAAE,AAC/C,gCAAkC,UAAY,CAAE,AAChD,8BAAgC,UAAY,CAAE,AAC9C,8BAAgC,UAAY,CAAE,AAC9C,0BAA4B,UAAY,CAAE,AAC1C,gCAAkC,UAAY,CAAE,AAChD,2BAA6B,UAAY,CAAE,AAC3C,4BAA8B,SAAY,CAAE,AAE5C,gDAAkD,kBAAoB,CAAE,AACxE,0CAA4C,uBAAuB,AAAC,oBAAuB,CAAE\",\"file\":\"eclipse.css\",\"sourcesContent\":[\".cm-s-eclipse span.cm-meta { color: #FF1717; }\\n.cm-s-eclipse span.cm-keyword { line-height: 1em; font-weight: bold; color: #7F0055; }\\n.cm-s-eclipse span.cm-atom { color: #219; }\\n.cm-s-eclipse span.cm-number { color: #164; }\\n.cm-s-eclipse span.cm-def { color: #00f; }\\n.cm-s-eclipse span.cm-variable { color: black; }\\n.cm-s-eclipse span.cm-variable-2 { color: #0000C0; }\\n.cm-s-eclipse span.cm-variable-3, .cm-s-eclipse span.cm-type { color: #0000C0; }\\n.cm-s-eclipse span.cm-property { color: black; }\\n.cm-s-eclipse span.cm-operator { color: black; }\\n.cm-s-eclipse span.cm-comment { color: #3F7F5F; }\\n.cm-s-eclipse span.cm-string { color: #2A00FF; }\\n.cm-s-eclipse span.cm-string-2 { color: #f50; }\\n.cm-s-eclipse span.cm-qualifier { color: #555; }\\n.cm-s-eclipse span.cm-builtin { color: #30a; }\\n.cm-s-eclipse span.cm-bracket { color: #cc7; }\\n.cm-s-eclipse span.cm-tag { color: #170; }\\n.cm-s-eclipse span.cm-attribute { color: #00c; }\\n.cm-s-eclipse span.cm-link { color: #219; }\\n.cm-s-eclipse span.cm-error { color: #f00; }\\n\\n.cm-s-eclipse .CodeMirror-activeline-background { background: #e8f2ff; }\\n.cm-s-eclipse .CodeMirror-matchingbracket { outline:1px solid grey; color:black !important; }\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"GypT\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"IrVb\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"6d73906a\", content, true);\n\n/***/ }),\n\n/***/ \"IXFo\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-fat-cursor-mark{background-color:rgba(20,255,20,.5)}.cm-animate-fat-cursor,.cm-fat-cursor-mark{-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite}.cm-animate-fat-cursor{width:auto;border:0;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:blue}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-invalidchar,.cm-s-default .cm-error{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:none;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:none!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:none}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}.CodeMirror-focused div.CodeMirror-cursors,div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:\\\"\\\"}span.CodeMirror-selectedtext{background:none}\", \"\", {\"version\":3,\"sources\":[\"/home/travis/build/voorhoede/manifiesta/node_modules/codemirror/lib/codemirror.css\"],\"names\":[],\"mappings\":\"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\",\"file\":\"codemirror.css\",\"sourcesContent\":[\"/* BASICS */\\n\\n.CodeMirror {\\n  /* Set height, width, borders, and global font properties here */\\n  font-family: monospace;\\n  height: 300px;\\n  color: black;\\n  direction: ltr;\\n}\\n\\n/* PADDING */\\n\\n.CodeMirror-lines {\\n  padding: 4px 0; /* Vertical padding around content */\\n}\\n.CodeMirror pre {\\n  padding: 0 4px; /* Horizontal padding of content */\\n}\\n\\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\\n  background-color: white; /* The little square between H and V scrollbars */\\n}\\n\\n/* GUTTER */\\n\\n.CodeMirror-gutters {\\n  border-right: 1px solid #ddd;\\n  background-color: #f7f7f7;\\n  white-space: nowrap;\\n}\\n.CodeMirror-linenumbers {}\\n.CodeMirror-linenumber {\\n  padding: 0 3px 0 5px;\\n  min-width: 20px;\\n  text-align: right;\\n  color: #999;\\n  white-space: nowrap;\\n}\\n\\n.CodeMirror-guttermarker { color: black; }\\n.CodeMirror-guttermarker-subtle { color: #999; }\\n\\n/* CURSOR */\\n\\n.CodeMirror-cursor {\\n  border-left: 1px solid black;\\n  border-right: none;\\n  width: 0;\\n}\\n/* Shown when moving in bi-directional text */\\n.CodeMirror div.CodeMirror-secondarycursor {\\n  border-left: 1px solid silver;\\n}\\n.cm-fat-cursor .CodeMirror-cursor {\\n  width: auto;\\n  border: 0 !important;\\n  background: #7e7;\\n}\\n.cm-fat-cursor div.CodeMirror-cursors {\\n  z-index: 1;\\n}\\n.cm-fat-cursor-mark {\\n  background-color: rgba(20, 255, 20, 0.5);\\n  -webkit-animation: blink 1.06s steps(1) infinite;\\n  -moz-animation: blink 1.06s steps(1) infinite;\\n  animation: blink 1.06s steps(1) infinite;\\n}\\n.cm-animate-fat-cursor {\\n  width: auto;\\n  border: 0;\\n  -webkit-animation: blink 1.06s steps(1) infinite;\\n  -moz-animation: blink 1.06s steps(1) infinite;\\n  animation: blink 1.06s steps(1) infinite;\\n  background-color: #7e7;\\n}\\n@-moz-keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n@-webkit-keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n@keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n\\n/* Can style cursor different in overwrite (non-insert) mode */\\n.CodeMirror-overwrite .CodeMirror-cursor {}\\n\\n.cm-tab { display: inline-block; text-decoration: inherit; }\\n\\n.CodeMirror-rulers {\\n  position: absolute;\\n  left: 0; right: 0; top: -50px; bottom: -20px;\\n  overflow: hidden;\\n}\\n.CodeMirror-ruler {\\n  border-left: 1px solid #ccc;\\n  top: 0; bottom: 0;\\n  position: absolute;\\n}\\n\\n/* DEFAULT THEME */\\n\\n.cm-s-default .cm-header {color: blue;}\\n.cm-s-default .cm-quote {color: #090;}\\n.cm-negative {color: #d44;}\\n.cm-positive {color: #292;}\\n.cm-header, .cm-strong {font-weight: bold;}\\n.cm-em {font-style: italic;}\\n.cm-link {text-decoration: underline;}\\n.cm-strikethrough {text-decoration: line-through;}\\n\\n.cm-s-default .cm-keyword {color: #708;}\\n.cm-s-default .cm-atom {color: #219;}\\n.cm-s-default .cm-number {color: #164;}\\n.cm-s-default .cm-def {color: #00f;}\\n.cm-s-default .cm-variable,\\n.cm-s-default .cm-punctuation,\\n.cm-s-default .cm-property,\\n.cm-s-default .cm-operator {}\\n.cm-s-default .cm-variable-2 {color: #05a;}\\n.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}\\n.cm-s-default .cm-comment {color: #a50;}\\n.cm-s-default .cm-string {color: #a11;}\\n.cm-s-default .cm-string-2 {color: #f50;}\\n.cm-s-default .cm-meta {color: #555;}\\n.cm-s-default .cm-qualifier {color: #555;}\\n.cm-s-default .cm-builtin {color: #30a;}\\n.cm-s-default .cm-bracket {color: #997;}\\n.cm-s-default .cm-tag {color: #170;}\\n.cm-s-default .cm-attribute {color: #00c;}\\n.cm-s-default .cm-hr {color: #999;}\\n.cm-s-default .cm-link {color: #00c;}\\n\\n.cm-s-default .cm-error {color: #f00;}\\n.cm-invalidchar {color: #f00;}\\n\\n.CodeMirror-composing { border-bottom: 2px solid; }\\n\\n/* Default styles for common addons */\\n\\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;}\\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;}\\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }\\n.CodeMirror-activeline-background {background: #e8f2ff;}\\n\\n/* STOP */\\n\\n/* The rest of this file contains styles related to the mechanics of\\n   the editor. You probably shouldn't touch them. */\\n\\n.CodeMirror {\\n  position: relative;\\n  overflow: hidden;\\n  background: white;\\n}\\n\\n.CodeMirror-scroll {\\n  overflow: scroll !important; /* Things will break if this is overridden */\\n  /* 30px is the magic margin used to hide the element's real scrollbars */\\n  /* See overflow: hidden in .CodeMirror */\\n  margin-bottom: -30px; margin-right: -30px;\\n  padding-bottom: 30px;\\n  height: 100%;\\n  outline: none; /* Prevent dragging from highlighting the element */\\n  position: relative;\\n}\\n.CodeMirror-sizer {\\n  position: relative;\\n  border-right: 30px solid transparent;\\n}\\n\\n/* The fake, visible scrollbars. Used to force redraw during scrolling\\n   before actual scrolling happens, thus preventing shaking and\\n   flickering artifacts. */\\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\\n  position: absolute;\\n  z-index: 6;\\n  display: none;\\n}\\n.CodeMirror-vscrollbar {\\n  right: 0; top: 0;\\n  overflow-x: hidden;\\n  overflow-y: scroll;\\n}\\n.CodeMirror-hscrollbar {\\n  bottom: 0; left: 0;\\n  overflow-y: hidden;\\n  overflow-x: scroll;\\n}\\n.CodeMirror-scrollbar-filler {\\n  right: 0; bottom: 0;\\n}\\n.CodeMirror-gutter-filler {\\n  left: 0; bottom: 0;\\n}\\n\\n.CodeMirror-gutters {\\n  position: absolute; left: 0; top: 0;\\n  min-height: 100%;\\n  z-index: 3;\\n}\\n.CodeMirror-gutter {\\n  white-space: normal;\\n  height: 100%;\\n  display: inline-block;\\n  vertical-align: top;\\n  margin-bottom: -30px;\\n}\\n.CodeMirror-gutter-wrapper {\\n  position: absolute;\\n  z-index: 4;\\n  background: none !important;\\n  border: none !important;\\n}\\n.CodeMirror-gutter-background {\\n  position: absolute;\\n  top: 0; bottom: 0;\\n  z-index: 4;\\n}\\n.CodeMirror-gutter-elt {\\n  position: absolute;\\n  cursor: default;\\n  z-index: 4;\\n}\\n.CodeMirror-gutter-wrapper ::selection { background-color: transparent }\\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }\\n\\n.CodeMirror-lines {\\n  cursor: text;\\n  min-height: 1px; /* prevents collapsing before first draw */\\n}\\n.CodeMirror pre {\\n  /* Reset some styles that the rest of the page might have set */\\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\\n  border-width: 0;\\n  background: transparent;\\n  font-family: inherit;\\n  font-size: inherit;\\n  margin: 0;\\n  white-space: pre;\\n  word-wrap: normal;\\n  line-height: inherit;\\n  color: inherit;\\n  z-index: 2;\\n  position: relative;\\n  overflow: visible;\\n  -webkit-tap-highlight-color: transparent;\\n  -webkit-font-variant-ligatures: contextual;\\n  font-variant-ligatures: contextual;\\n}\\n.CodeMirror-wrap pre {\\n  word-wrap: break-word;\\n  white-space: pre-wrap;\\n  word-break: normal;\\n}\\n\\n.CodeMirror-linebackground {\\n  position: absolute;\\n  left: 0; right: 0; top: 0; bottom: 0;\\n  z-index: 0;\\n}\\n\\n.CodeMirror-linewidget {\\n  position: relative;\\n  z-index: 2;\\n  overflow: auto;\\n}\\n\\n.CodeMirror-widget {}\\n\\n.CodeMirror-rtl pre { direction: rtl; }\\n\\n.CodeMirror-code {\\n  outline: none;\\n}\\n\\n/* Force content-box sizing for the elements where we expect it */\\n.CodeMirror-scroll,\\n.CodeMirror-sizer,\\n.CodeMirror-gutter,\\n.CodeMirror-gutters,\\n.CodeMirror-linenumber {\\n  -moz-box-sizing: content-box;\\n  box-sizing: content-box;\\n}\\n\\n.CodeMirror-measure {\\n  position: absolute;\\n  width: 100%;\\n  height: 0;\\n  overflow: hidden;\\n  visibility: hidden;\\n}\\n\\n.CodeMirror-cursor {\\n  position: absolute;\\n  pointer-events: none;\\n}\\n.CodeMirror-measure pre { position: static; }\\n\\ndiv.CodeMirror-cursors {\\n  visibility: hidden;\\n  position: relative;\\n  z-index: 3;\\n}\\ndiv.CodeMirror-dragcursors {\\n  visibility: visible;\\n}\\n\\n.CodeMirror-focused div.CodeMirror-cursors {\\n  visibility: visible;\\n}\\n\\n.CodeMirror-selected { background: #d9d9d9; }\\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\\n.CodeMirror-crosshair { cursor: crosshair; }\\n.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }\\n.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }\\n\\n.cm-searching {\\n  background-color: #ffa;\\n  background-color: rgba(255, 255, 0, .4);\\n}\\n\\n/* Used to force a border model for a node */\\n.cm-force-border { padding-right: .1px; }\\n\\n@media print {\\n  /* Hide the cursor when printing */\\n  .CodeMirror div.CodeMirror-cursors {\\n    visibility: hidden;\\n  }\\n}\\n\\n/* See issue #2901 */\\n.cm-tab-wrap-hack:after { content: ''; }\\n\\n/* Help users use markselection to safely style text background */\\nspan.CodeMirror-selectedtext { background: none; }\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"IrVb\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\nexports.i(__webpack_require__(\"IXFo\"), \"\");\nexports.i(__webpack_require__(\"aSS6\"), \"\");\nexports.i(__webpack_require__(\"CjAo\"), \"\");\n\n// module\nexports.push([module.i, \"a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:\\\"\\\";content:none}table{border-collapse:collapse;border-spacing:0}*{-webkit-box-sizing:border-box;box-sizing:border-box}:after,:before{-webkit-box-sizing:inherit;box-sizing:inherit}body{font-family:Roboto,sans-serif;color:#212121}.a11y-only{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;padding:0;position:absolute;width:1px}.manifest-editor{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;position:relative}.CodeMirror{position:absolute;width:100%;height:100%;border-top:1px solid #e0e0e0;border-bottom:1px solid #e0e0e0}.CodeMirror pre{font-size:1em;font-family:monospace;line-height:1.6}\", \"\", {\"version\":3,\"sources\":[\"/home/travis/build/voorhoede/manifiesta/src/components/manifest-editor/manifest-editor.scss\"],\"names\":[],\"mappings\":\"AAOA,2ZAaE,SAAU,AACV,UAAW,AACX,SAAU,AACV,eAAgB,AAChB,aAAc,AACd,uBAAyB,CAC1B,AAGD,8EAEE,aAAe,CAChB,AACD,KACE,aAAe,CAChB,AACD,MACE,eAAiB,CAClB,AACD,aACE,WAAa,CACd,AACD,oDAEE,WAAY,AACZ,YAAc,CACf,AACD,MACE,yBAA0B,AAC1B,gBAAkB,CACnB,AACD,EACE,8BAA+B,AACvB,qBAAuB,CAChC,AACD,eACE,2BAA4B,AACpB,kBAAoB,CAC7B,AACD,KACE,8BAAkC,AAClC,aAAe,CAChB,AACD,WACE,SAAU,AACV,mBAAoB,AACpB,WAAY,AACZ,YAAa,AACb,UAAW,AACX,kBAAmB,AACnB,SAAW,CACZ,AACD,iBACE,mBAAoB,AAChB,oBAAqB,AACjB,YAAa,AACrB,iBAAmB,CACpB,AACD,YACE,kBAAmB,AACnB,WAAY,AACZ,YAAa,AACb,6BAA8B,AAC9B,+BAAiC,CAClC,AACD,gBACE,cAAe,AACf,sBAAuB,AACvB,eAAiB,CAClB\",\"file\":\"manifest-editor.scss\",\"sourcesContent\":[\"/* http://meyerweb.com/eric/tools/css/reset/\\n   v2.0 | 20110126\\n   License: none (public domain)\\n*/\\n@import url(../../../node_modules/codemirror/lib/codemirror.css);\\n@import url(../../../node_modules/codemirror/addon/lint/lint.css);\\n@import url(../../../node_modules/codemirror/theme/eclipse.css);\\nhtml, body, div, span, applet, object, iframe,\\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\\na, abbr, acronym, address, big, cite, code,\\ndel, dfn, em, img, ins, kbd, q, s, samp,\\nsmall, strike, strong, sub, sup, tt, var,\\nb, u, i, center,\\ndl, dt, dd, ol, ul, li,\\nfieldset, form, label, legend,\\ntable, caption, tbody, tfoot, thead, tr, th, td,\\narticle, aside, canvas, details, embed,\\nfigure, figcaption, footer, header, hgroup,\\nmenu, nav, output, ruby, section, summary,\\ntime, mark, audio, video {\\n  margin: 0;\\n  padding: 0;\\n  border: 0;\\n  font-size: 100%;\\n  font: inherit;\\n  vertical-align: baseline;\\n}\\n\\n/* HTML5 display-role reset for older browsers */\\narticle, aside, details, figcaption, figure,\\nfooter, header, hgroup, menu, nav, section {\\n  display: block;\\n}\\nbody {\\n  line-height: 1;\\n}\\nol, ul {\\n  list-style: none;\\n}\\nblockquote, q {\\n  quotes: none;\\n}\\nblockquote:before, blockquote:after,\\nq:before, q:after {\\n  content: '';\\n  content: none;\\n}\\ntable {\\n  border-collapse: collapse;\\n  border-spacing: 0;\\n}\\n* {\\n  -webkit-box-sizing: border-box;\\n          box-sizing: border-box;\\n}\\n*:before, *:after {\\n  -webkit-box-sizing: inherit;\\n          box-sizing: inherit;\\n}\\nbody {\\n  font-family: 'Roboto', sans-serif;\\n  color: #212121;\\n}\\n.a11y-only {\\n  border: 0;\\n  clip: rect(0 0 0 0);\\n  height: 1px;\\n  margin: -1px;\\n  padding: 0;\\n  position: absolute;\\n  width: 1px;\\n}\\n.manifest-editor {\\n  -webkit-box-flex: 1;\\n      -ms-flex-positive: 1;\\n          flex-grow: 1;\\n  position: relative;\\n}\\n.CodeMirror {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  border-top: 1px solid #E0E0E0;\\n  border-bottom: 1px solid #E0E0E0;\\n}\\n.CodeMirror pre {\\n  font-size: 1em;\\n  font-family: monospace;\\n  line-height: 1.6;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"Lgoy\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_vue_loader_lib_selector_type_script_index_0_codemirror_vue__ = __webpack_require__(\"gC+Y\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vue_loader_lib_template_compiler_index_id_data_v_5c584404_hasScoped_false_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_vue_loader_lib_selector_type_template_index_0_codemirror_vue__ = __webpack_require__(\"R2wf\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"7xRv\")\n}\nvar normalizeComponent = __webpack_require__(\"VU/8\")\n/* script */\n\n/* template */\n\n/* template functional */\n  var __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_vue_loader_lib_selector_type_script_index_0_codemirror_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__vue_loader_lib_template_compiler_index_id_data_v_5c584404_hasScoped_false_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_vue_loader_lib_selector_type_template_index_0_codemirror_vue__[\"a\" /* default */],\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"MsCo\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\treturn punycode;\n\t\t}.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"3IRH\")(module), __webpack_require__(\"DuR2\")))\n\n/***/ }),\n\n/***/ \"OlnX\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  'af': 'Afrikaans',\n  'af-ZA': 'Afrikaans (South Africa)',\n  'ar': 'Arabic',\n  'ar-AE': 'Arabic (U.A.E.)',\n  'ar-BH': 'Arabic (Bahrain)',\n  'ar-DZ': 'Arabic (Algeria)',\n  'ar-EG': 'Arabic (Egypt)',\n  'ar-IQ': 'Arabic (Iraq)',\n  'ar-JO': 'Arabic (Jordan)',\n  'ar-KW': 'Arabic (Kuwait)',\n  'ar-LB': 'Arabic (Lebanon)',\n  'ar-LY': 'Arabic (Libya)',\n  'ar-MA': 'Arabic (Morocco)',\n  'ar-OM': 'Arabic (Oman)',\n  'ar-QA': 'Arabic (Qatar)',\n  'ar-SA': 'Arabic (Saudi Arabia)',\n  'ar-SY': 'Arabic (Syria)',\n  'ar-TN': 'Arabic (Tunisia)',\n  'ar-YE': 'Arabic (Yemen)',\n  'az': 'Azeri (Latin)',\n  'az-AZ': 'Azeri (Latin) (Azerbaijan)',\n  'az-Cyrl-AZ': 'Azeri (Cyrillic) (Azerbaijan)',\n  'be': 'Belarusian',\n  'be-BY': 'Belarusian (Belarus)',\n  'bg': 'Bulgarian',\n  'bg-BG': 'Bulgarian (Bulgaria)',\n  'bs-BA': 'Bosnian (Bosnia and Herzegovina)',\n  'ca': 'Catalan',\n  'ca-ES': 'Catalan (Spain)',\n  'cs': 'Czech',\n  'cs-CZ': 'Czech (Czech Republic)',\n  'cy': 'Welsh',\n  'cy-GB': 'Welsh (United Kingdom)',\n  'da': 'Danish',\n  'da-DK': 'Danish (Denmark)',\n  'de': 'German',\n  'de-AT': 'German (Austria)',\n  'de-CH': 'German (Switzerland)',\n  'de-DE': 'German (Germany)',\n  'de-LI': 'German (Liechtenstein)',\n  'de-LU': 'German (Luxembourg)',\n  'dv': 'Divehi',\n  'dv-MV': 'Divehi (Maldives)',\n  'el': 'Greek',\n  'el-GR': 'Greek (Greece)',\n  'en': 'English',\n  'en-AU': 'English (Australia)',\n  'en-BZ': 'English (Belize)',\n  'en-CA': 'English (Canada)',\n  'en-CB': 'English (Caribbean)',\n  'en-GB': 'English (United Kingdom)',\n  'en-IE': 'English (Ireland)',\n  'en-JM': 'English (Jamaica)',\n  'en-NZ': 'English (New Zealand)',\n  'en-PH': 'English (Republic of the Philippines)',\n  'en-TT': 'English (Trinidad and Tobago)',\n  'en-US': 'English (United States)',\n  'en-ZA': 'English (South Africa)',\n  'en-ZW': 'English (Zimbabwe)',\n  'eo': 'Esperanto',\n  'es': 'Spanish',\n  'es-AR': 'Spanish (Argentina)',\n  'es-BO': 'Spanish (Bolivia)',\n  'es-CL': 'Spanish (Chile)',\n  'es-CO': 'Spanish (Colombia)',\n  'es-CR': 'Spanish (Costa Rica)',\n  'es-DO': 'Spanish (Dominican Republic)',\n  'es-EC': 'Spanish (Ecuador)',\n  'es-ES': 'Spanish (Spain)',\n  'es-GT': 'Spanish (Guatemala)',\n  'es-HN': 'Spanish (Honduras)',\n  'es-MX': 'Spanish (Mexico)',\n  'es-NI': 'Spanish (Nicaragua)',\n  'es-PA': 'Spanish (Panama)',\n  'es-PE': 'Spanish (Peru)',\n  'es-PR': 'Spanish (Puerto Rico)',\n  'es-PY': 'Spanish (Paraguay)',\n  'es-SV': 'Spanish (El Salvador)',\n  'es-UY': 'Spanish (Uruguay)',\n  'es-VE': 'Spanish (Venezuela)',\n  'et': 'Estonian',\n  'et-EE': 'Estonian (Estonia)',\n  'eu': 'Basque',\n  'eu-ES': 'Basque (Spain)',\n  'fa': 'Farsi',\n  'fa-IR': 'Farsi (Iran)',\n  'fi': 'Finnish',\n  'fi-FI': 'Finnish (Finland)',\n  'fo': 'Faroese',\n  'fo-FO': 'Faroese (Faroe Islands)',\n  'fr': 'French',\n  'fr-BE': 'French (Belgium)',\n  'fr-CA': 'French (Canada)',\n  'fr-CH': 'French (Switzerland)',\n  'fr-FR': 'French (France)',\n  'fr-LU': 'French (Luxembourg)',\n  'fr-MC': 'French (Principality of Monaco)',\n  'gl': 'Galician',\n  'gl-ES': 'Galician (Spain)',\n  'gu': 'Gujarati',\n  'gu-IN': 'Gujarati (India)',\n  'he': 'Hebrew',\n  'he-IL': 'Hebrew (Israel)',\n  'hi': 'Hindi',\n  'hi-IN': 'Hindi (India)',\n  'hr': 'Croatian',\n  'hr-BA': 'Croatian (Bosnia and Herzegovina)',\n  'hr-HR': 'Croatian (Croatia)',\n  'hu': 'Hungarian',\n  'hu-HU': 'Hungarian (Hungary)',\n  'hy': 'Armenian',\n  'hy-AM': 'Armenian (Armenia)',\n  'id': 'Indonesian',\n  'id-ID': 'Indonesian (Indonesia)',\n  'is': 'Icelandic',\n  'is-IS': 'Icelandic (Iceland)',\n  'it': 'Italian',\n  'it-CH': 'Italian (Switzerland)',\n  'it-IT': 'Italian (Italy)',\n  'ja': 'Japanese',\n  'ja-JP': 'Japanese (Japan)',\n  'ka': 'Georgian',\n  'ka-GE': 'Georgian (Georgia)',\n  'kk': 'Kazakh',\n  'kk-KZ': 'Kazakh (Kazakhstan)',\n  'kn': 'Kannada',\n  'kn-IN': 'Kannada (India)',\n  'ko': 'Korean',\n  'ko-KR': 'Korean (Korea)',\n  'kok': 'Konkani',\n  'kok-IN': 'Konkani (India)',\n  'ky': 'Kyrgyz',\n  'ky-KG': 'Kyrgyz (Kyrgyzstan)',\n  'lt': 'Lithuanian',\n  'lt-LT': 'Lithuanian (Lithuania)',\n  'lv': 'Latvian',\n  'lv-LV': 'Latvian (Latvia)',\n  'mi': 'Maori',\n  'mi-NZ': 'Maori (New Zealand)',\n  'mk': 'FYRO Macedonian',\n  'mk-MK': 'FYRO Macedonian (Former Yugoslav Republic of Macedonia)',\n  'mn': 'Mongolian',\n  'mn-MN': 'Mongolian (Mongolia)',\n  'mr': 'Marathi',\n  'mr-IN': 'Marathi (India)',\n  'ms': 'Malay',\n  'ms-BN': 'Malay (Brunei Darussalam)',\n  'ms-MY': 'Malay (Malaysia)',\n  'mt': 'Maltese',\n  'mt-MT': 'Maltese (Malta)',\n  'nb': 'Norwegian (Bokm?l)',\n  'nb-NO': 'Norwegian (Bokm?l) (Norway)',\n  'nl': 'Dutch',\n  'nl-BE': 'Dutch (Belgium)',\n  'nl-NL': 'Dutch (Netherlands)',\n  'nn-NO': 'Norwegian (Nynorsk) (Norway)',\n  'ns': 'Northern Sotho',\n  'ns-ZA': 'Northern Sotho (South Africa)',\n  'pa': 'Punjabi',\n  'pa-IN': 'Punjabi (India)',\n  'pl': 'Polish',\n  'pl-PL': 'Polish (Poland)',\n  'ps': 'Pashto',\n  'ps-AR': 'Pashto (Afghanistan)',\n  'pt': 'Portuguese',\n  'pt-BR': 'Portuguese (Brazil)',\n  'pt-PT': 'Portuguese (Portugal)',\n  'qu': 'Quechua',\n  'qu-BO': 'Quechua (Bolivia)',\n  'qu-EC': 'Quechua (Ecuador)',\n  'qu-PE': 'Quechua (Peru)',\n  'ro': 'Romanian',\n  'ro-RO': 'Romanian (Romania)',\n  'ru': 'Russian',\n  'ru-RU': 'Russian (Russia)',\n  'sa': 'Sanskrit',\n  'sa-IN': 'Sanskrit (India)',\n  'se': 'Sami',\n  'se-FI': 'Sami (Finland)',\n  'se-NO': 'Sami (Norway)',\n  'se-SE': 'Sami (Sweden)',\n  'sk': 'Slovak',\n  'sk-SK': 'Slovak (Slovakia)',\n  'sl': 'Slovenian',\n  'sl-SI': 'Slovenian (Slovenia)',\n  'sq': 'Albanian',\n  'sq-AL': 'Albanian (Albania)',\n  'sr-BA': 'Serbian (Latin) (Bosnia and Herzegovina)',\n  'sr-Cyrl-BA': 'Serbian (Cyrillic) (Bosnia and Herzegovina)',\n  'sr-SP': 'Serbian (Latin) (Serbia and Montenegro)',\n  'sr-Cyrl-SP': 'Serbian (Cyrillic) (Serbia and Montenegro)',\n  'sv': 'Swedish',\n  'sv-FI': 'Swedish (Finland)',\n  'sv-SE': 'Swedish (Sweden)',\n  'sw': 'Swahili',\n  'sw-KE': 'Swahili (Kenya)',\n  'syr': 'Syriac',\n  'syr-SY': 'Syriac (Syria)',\n  'ta': 'Tamil',\n  'ta-IN': 'Tamil (India)',\n  'te': 'Telugu',\n  'te-IN': 'Telugu (India)',\n  'th': 'Thai',\n  'th-TH': 'Thai (Thailand)',\n  'tl': 'Tagalog',\n  'tl-PH': 'Tagalog (Philippines)',\n  'tn': 'Tswana',\n  'tn-ZA': 'Tswana (South Africa)',\n  'tr': 'Turkish',\n  'tr-TR': 'Turkish (Turkey)',\n  'tt': 'Tatar',\n  'tt-RU': 'Tatar (Russia)',\n  'ts': 'Tsonga',\n  'uk': 'Ukrainian',\n  'uk-UA': 'Ukrainian (Ukraine)',\n  'ur': 'Urdu',\n  'ur-PK': 'Urdu (Islamic Republic of Pakistan)',\n  'uz': 'Uzbek (Latin)',\n  'uz-UZ': 'Uzbek (Latin) (Uzbekistan)',\n  'uz-Cyrl-UZ': 'Uzbek (Cyrillic) (Uzbekistan)',\n  'vi': 'Vietnamese',\n  'vi-VN': 'Vietnamese (Viet Nam)',\n  'xh': 'Xhosa',\n  'xh-ZA': 'Xhosa (South Africa)',\n  'zh': 'Chinese',\n  'zh-CN': 'Chinese (S)',\n  'zh-HK': 'Chinese (Hong Kong)',\n  'zh-MO': 'Chinese (Macau)',\n  'zh-SG': 'Chinese (Singapore)',\n  'zh-TW': 'Chinese (T)',\n  'zu': 'Zulu',\n  'zu-ZA': 'Zulu (South Africa)'\n});\n\n/***/ }),\n\n/***/ \"Qudd\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"manifest-editor\"},[_c('codemirror',{attrs:{\"options\":_vm.options},model:{value:(_vm.code),callback:function ($$v) {_vm.code=$$v},expression:\"code\"}})],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"R2wf\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('textarea')}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"StWd\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = debounce;\nfunction debounce(func, wait, immediate) {\n  var timeout = void 0;\n  return function () {\n    var _this = this;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      timeout = null;\n      if (!immediate) func.apply(_this, args);\n    }, wait);\n    if (immediate && !timeout) func.apply(this, [].concat(args));\n  };\n}\n\n/***/ }),\n\n/***/ \"UZ5h\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar punycode = __webpack_require__(\"MsCo\");\nvar util = __webpack_require__(\"qOJP\");\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = __webpack_require__(\"1nuA\");\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n\n/***/ }),\n\n/***/ \"V5hE\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".CodeMirror-code{font-family:Menlo,Monaco,Consolas,Courier New,monospace}\", \"\", {\"version\":3,\"sources\":[\"/home/travis/build/voorhoede/manifiesta/node_modules/vue-codemirror-lite/codemirror.vue\"],\"names\":[],\"mappings\":\"AACA,iBACE,uDAA+D,CAChE\",\"file\":\"codemirror.vue\",\"sourcesContent\":[\"\\n.CodeMirror-code {\\n  font-family: Menlo, Monaco, Consolas, \\\"Courier New\\\", monospace;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"VDic\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_codemirror_lite__ = __webpack_require__(\"gZhU\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_codemirror_lite___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue_codemirror_lite__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jsonschema__ = __webpack_require__(\"7HRn\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jsonschema___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jsonschema__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__manifest_schema__ = __webpack_require__(\"d6Mc\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_json_lint__ = __webpack_require__(\"ZbcI\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_json_lint___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_json_lint__);\n\n\n\n\n__webpack_require__(\"5IAE\");\n__webpack_require__(\"ryyk\");\n\nvar validator = new __WEBPACK_IMPORTED_MODULE_1_jsonschema__[\"Validator\"]();\nvar tabSize = 2;\nvar prefix = 'instance.';\n\n__WEBPACK_IMPORTED_MODULE_0_vue_codemirror_lite__[\"CodeMirror\"].registerHelper('lint', 'json', function (text) {\n  var lint = __WEBPACK_IMPORTED_MODULE_3_json_lint___default()(text, {});\n  if (lint.error) {\n    return [{\n      from: __WEBPACK_IMPORTED_MODULE_0_vue_codemirror_lite__[\"CodeMirror\"].Pos(lint.line - 1, lint.character - 1),\n      to: __WEBPACK_IMPORTED_MODULE_0_vue_codemirror_lite__[\"CodeMirror\"].Pos(lint.line - 1, lint.character),\n      message: lint.error\n    }];\n  } else {\n    var _validator$validate = validator.validate(JSON.parse(text), __WEBPACK_IMPORTED_MODULE_2__manifest_schema__[\"a\" /* default */]),\n        errors = _validator$validate.errors;\n\n    var messages = [];\n    if (errors) {\n      errors.forEach(function (error) {\n        messages.push(generateErrorMessage(error, text));\n      });\n\n      return messages;\n    }\n  }\n\n  return [];\n});\n\nfunction generateErrorMessage(error, text) {\n  if (error.name === 'required') {\n    return {\n      from: __WEBPACK_IMPORTED_MODULE_0_vue_codemirror_lite__[\"CodeMirror\"].Pos(0, 1),\n      to: __WEBPACK_IMPORTED_MODULE_0_vue_codemirror_lite__[\"CodeMirror\"].Pos(0, 1),\n      message: removePrefix(error.stack)\n    };\n  } else {\n    var position = getLinePosition(error, text);\n    return {\n      from: __WEBPACK_IMPORTED_MODULE_0_vue_codemirror_lite__[\"CodeMirror\"].Pos(position.from.line, position.from.char),\n      to: __WEBPACK_IMPORTED_MODULE_0_vue_codemirror_lite__[\"CodeMirror\"].Pos(position.to.line, position.to.char),\n      message: removePrefix(error.stack)\n    };\n  }\n}\n\nfunction getLinePosition(error, text) {\n  var propertyName = error.property.substr('instance.'.length);\n  var pattern = new RegExp('(\\\\s*\"' + propertyName + '\"\\\\s*:\\\\s*)(.*)\\\\s*,\\\\s*$');\n  var lines = text.split('\\n');\n  var lineIndex = lines.findIndex(function (line) {\n    return line.includes(propertyName);\n  });\n  var line = lines[lineIndex].replace('\\t', ' '.repeat(tabSize));\n  var matches = line.match(pattern);\n  var fromChar = matches[1].length - 1;\n  var toChar = fromChar + matches[2].length;\n\n  return {\n    from: {\n      line: lineIndex,\n      char: fromChar\n    },\n    to: {\n      line: lineIndex,\n      char: toChar\n    }\n  };\n}\n\nfunction removePrefix(str) {\n  return str.replace(prefix, '');\n}\n\n/***/ }),\n\n/***/ \"YeLu\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar helpers = __webpack_require__(\"k8+T\");\n\n/** @type ValidatorResult */\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\nvar SchemaError = helpers.SchemaError;\n\nvar attribute = {};\n\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'exclusiveMinimum': true,\n  'exclusiveMaximum': true,\n  'additionalItems': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true\n};\n\n/**\n * @name validators\n */\nvar validators = attribute.validators = {};\n\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.type = function validateType (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      return v.id && ('<' + v.id + '>') || (v+'');\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list,\n    });\n  }\n  return result;\n};\n\nfunction testSchema(instance, options, ctx, callback, schema){\n  var res = this.validateSchema(instance, schema, options, ctx);\n  if (! res.valid && callback instanceof Function) {\n    callback(res);\n  }\n  return res.valid;\n}\n\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.anyOf = function validateAnyOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(schema.anyOf)){\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n  if (!schema.anyOf.some(\n    testSchema.bind(\n      this, instance, options, ctx, function(res){inner.importErrors(res);}\n      ))) {\n    var list = schema.anyOf.map(function (v, i) {\n      return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n    });\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.allOf = function validateAllOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.allOf)){\n    throw new SchemaError(\"allOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function(v, i){\n    var valid = self.validateSchema(instance, v, options, ctx);\n    if(!valid.valid){\n      var msg = (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n      result.addError({\n        name: 'allOf',\n        argument: { id: msg, length: valid.errors.length, valid: valid },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.oneOf = function validateOneOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.oneOf)){\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(\n    testSchema.bind(\n      this, instance, options, ctx, function(res) {inner.importErrors(res);}\n      ) ).length;\n  var list = schema.oneOf.map(function (v, i) {\n    return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n  });\n  if (count!==1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.properties = function validateProperties (instance, schema, options, ctx) {\n  if(instance === undefined || !(instance instanceof Object)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n  for (var property in properties) {\n    var prop = (instance || undefined) && instance[property];\n    var res = this.validateSchema(prop, properties[property], options, ctx.makeChild(properties[property], property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n  return result;\n};\n\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existance tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\nfunction testAdditionalProperty (instance, schema, options, ctx, property, result) {\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"additionalProperty \" + JSON.stringify(property) + \" exists in instance when not allowed\",\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {\n  if(instance === undefined) return;\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n    for (var pattern in patternProperties) {\n      var expr = new RegExp(pattern);\n      if (!expr.test(property)) {\n        continue;\n      }\n      test = false;\n      var res = this.validateSchema(instance[property], patternProperties[pattern], options, ctx.makeChild(patternProperties[pattern], property));\n      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {\n  if(instance === undefined) return;\n  if(!this.types.object(instance)) return;\n  // if patternProperties is defined then we'll test when that one is called instead\n  if (schema.patternProperties) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minProperties = function validateMinProperties (instance, schema, options, ctx) {\n  if (!instance || typeof instance !== 'object') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties,\n    })\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {\n  if (!instance || typeof instance !== 'object') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.items = function validateItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var self = this;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined || !schema.items) {\n    return result;\n  }\n  instance.every(function (value, i) {\n    var items = Array.isArray(schema.items) ? (schema.items[i] || schema.additionalItems) : schema.items;\n    if (items === undefined) {\n      return true;\n    }\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\",\n      });\n      return false;\n    }\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minimum = function validateMinimum (instance, schema, options, ctx) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = true;\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    valid = instance > schema.minimum;\n  } else {\n    valid = instance >= schema.minimum;\n  }\n  if (!valid) {\n    result.addError({\n      name: 'minimum',\n      argument: schema.minimum,\n      message: \"must have a minimum value of \" + schema.minimum,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maximum = function validateMaximum (instance, schema, options, ctx) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid;\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    valid = instance < schema.maximum;\n  } else {\n    valid = instance <= schema.maximum;\n  }\n  if (!valid) {\n    result.addError({\n      name: 'maximum',\n      argument: schema.maximum,\n      message: \"must have a maximum value of \" + schema.maximum,\n    });\n  }\n  return result;\n};\n\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy (instance, schema, options, ctx, validationType, errorMessage) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n\n  var validationArgument = schema[validationType];\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n\n  var maxDecimals = Math.max(instanceDecimals , divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument:  validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument)\n    });\n  }\n\n  return result;\n};\n\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {\n return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.required = function validateRequired (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatability with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\"\n    });\n  } else if (instance && typeof instance==='object' && Array.isArray(schema.required)) {\n    schema.required.forEach(function(n){\n      if(instance[n]===undefined){\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n),\n        });\n      }\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.pattern = function validatePattern (instance, schema, options, ctx) {\n  if (typeof instance !== 'string') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.match(schema.pattern)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\nvalidators.format = function validateFormat (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minLength = function validateMinLength (instance, schema, options, ctx) {\n  if (!(typeof instance === 'string')) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxLength = function validateMaxLength (instance, schema, options, ctx) {\n  if (!(typeof instance === 'string')) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minItems = function validateMinItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxItems = function validateMaxItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates that every item in an instance array is unique, when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(instance)) {\n    return result;\n  }\n  function testArrays (v, i, a) {\n    for (var j = i + 1; j < a.length; j++) if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n    return true;\n  }\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\nfunction testArrays (v, i, a) {\n  var j, len = a.length;\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.dependencies = function validateDependencies (instance, schema, options, ctx) {\n  if (!instance || typeof instance != 'object') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath,\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if(result.instance !== res.instance) result.instance = res.instance;\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath,\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['enum'] = function validateEnum (instance, schema, options, ctx) {\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['const'] = function validateEnum (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const'],\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {\n  var self = this;\n  if(instance===undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if(!notTypes) return null;\n  if(!Array.isArray(notTypes)) notTypes=[notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var schemaId = type && type.id && ('<' + type.id + '>') || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId,\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;\n\n\n/***/ }),\n\n/***/ \"ZbcI\":\n/***/ (function(module, exports, __webpack_require__) {\n\n(function( glob, undefined ) {\n\nvar rnumber = /[0-9]/,\n\trnewline = /(\\r\\n|\\r|\\n)/,\n\trevidence = /\\r\\n|\\r|\\n/,\n\trwhitespace = /(\\s|\\t)/,\n\trvalidsolidus = /\\\\(\"|\\\\|\\/|b|f|n|r|t|u[0-9]{4})/,\n\trE = /^(\\-|\\+)?[0-9]/;\n\n\n// Leeeeeeerrrrroooyy Jennkkkiiinnnss\nfunction JSONLint( json, options ) {\n\tvar self = this;\n\n\tif ( ! ( self instanceof JSONLint ) ) {\n\t\treturn new JSONLint( json, options );\n\t}\n\n\t// Argument handling\n\tself.json = json || '';\n\tself.options = options || {};\n\tself.lower = self.json.toLowerCase();\n\n\t// Allow comments by default\n\tif ( ! self.options.hasOwnProperty( 'comments' ) ) {\n\t\tself.options.comments = true;\n\t}\n\n\t// Internals\n\tself.c = '';\n\tself.i = -1;\n\tself.length = self.json.length;\n\tself.line = 1;\n\tself.character = 0;\n\tself._evidence = self.json.split( revidence );\n\tself.endblock = '';\n\tself.commabreak = false;\n\n\ttry {\n\t\tself.render();\n\t} catch ( e ) {\n\t\tif ( typeof e != 'string' ) {\n\t\t\tthrow e;\n\t\t}\n\t\tself.error = e;\n\t\tself.setEvidence();\n\t}\n}\n\n\n// Meta (Please change contact info for republishing with changes)\nJSONLint.contact = \"Corey Hart (corey@codenothing.com)\";\nJSONLint.version = '[VERSION]';\nJSONLint.date = '[DATE]';\n\n\n// Methods\nJSONLint.prototype = {\n\n\t// Rendering Start\n\trender: function(){\n\t\tvar self = this, peek = '', content = false;\n\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( self.options.comments && self.c == '/' ) {\n\t\t\t\tpeek = self.json[ self.i + 1 ];\n\t\t\t\tif ( peek == '*' ) {\n\t\t\t\t\tself.multicomment();\n\t\t\t\t}\n\t\t\t\telse if ( peek == '/' ) {\n\t\t\t\t\tself.comment();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow \"Unknown character '/', maybe a comment?\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t}\n\t\t\telse if ( rwhitespace.exec( self.c ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if ( content ) {\n\t\t\t\tthrow \"Unknown character '\" + self.c + \"', expecting end of file.\";\n\t\t\t}\n\t\t\telse if ( self.c == '[' ) {\n\t\t\t\tcontent = true;\n\t\t\t\tself.array();\n\t\t\t}\n\t\t\telse if ( self.c == '{' ) {\n\t\t\t\tcontent = true;\n\t\t\t\tself.object();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow \"Unknown character '\" + self.c + \"', expecting opening block '{' or '[', or maybe a comment\";\n\t\t\t}\n\t\t}\n\n\t\t// Check for pure whitespace\n\t\tif ( ! content ) {\n\t\t\tthrow \"Invalid JSON, no content.\";\n\t\t}\n\t},\n\n\t// Multi line comment\n\tmulticomment: function(){\n\t\tvar self = this;\n\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( self.c == \"*\" && self.json[ self.i + 1 ] == \"/\" ) {\n\t\t\t\tself.i++;\n\t\t\t\tself.character++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t}\n\t\t}\n\t},\n\n\t// Single line comment\n\tcomment: function(){\n\t\tvar self = this;\n\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t},\n\n\t// Array Block\n\tarray: function(){\n\t\t// Keep reference of current endblock\n\t\tvar self = this,\n\t\t\t_endblock = self.endblock,\n\t\t\t_commabreak = self.commabreak,\n\t\t\tended = false;\n\n\t\tself.endblock = ']';\n\t\tself.commabreak = false;\n\t\twhile ( ( ended = self.value() ) !== true && self.i < self.length ) {\n\t\t\t// Do nothing, just wait for array values to finish\n\t\t}\n\n\t\tif ( ! ended ) {\n\t\t\tthrow \"EOF Error. Expecting closing ']'\";\n\t\t}\n\n\t\t// Reset previous endblock\n\t\tself.endblock = _endblock;\n\t\tself.commabreak = _commabreak;\n\t},\n\n\t// Object Block\n\tobject: function(){\n\t\t// Keep reference of current endblock\n\t\tvar self = this,\n\t\t\t_endblock = self.endblock,\n\t\t\t_commabreak = self.commabreak,\n\t\t\tfound = false, peek = '', empty = true;\n\n\t\tself.endblock = '}';\n\t\tself.commabreak = false;\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( self.options.comments && self.c == '/' ) {\n\t\t\t\tpeek = self.json[ self.i + 1 ];\n\t\t\t\tif ( peek == '*' ) {\n\t\t\t\t\tself.multicomment();\n\t\t\t\t}\n\t\t\t\telse if ( peek == '/' ) {\n\t\t\t\t\tself.comment();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow \"Unknown character '/', maybe a comment?\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t}\n\t\t\telse if ( rwhitespace.exec( self.c ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if ( self.c == '\"' ) {\n\t\t\t\tempty = false;\n\t\t\t\tif ( self.key() === true ) {\n\t\t\t\t\t// Reset old endblock\n\t\t\t\t\tself.endblock = _endblock;\n\t\t\t\t\tself.commabreak = _commabreak;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( empty && self.c == '}' ) {\n\t\t\t\tself.endblock = _endblock;\n\t\t\t\tself.commabreak = _commabreak;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow \"Unknown Character '\" + self.c + \"', expecting a string for key statement.\";\n\t\t\t}\n\t\t}\n\n\t\tif ( ! found ) {\n\t\t\tthrow \"EOF Error, expecting closing '}'.\";\n\t\t}\n\t},\n\n\t// Key Statement\n\tkey: function(){\n\t\tvar self = this;\n\t\tself.string();\n\n\t\tfor ( var peek = ''; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( self.options.comments && self.c == '/' ) {\n\t\t\t\tpeek = self.json[ self.i + 1 ];\n\t\t\t\tif ( peek == '*' ) {\n\t\t\t\t\tself.multicomment();\n\t\t\t\t}\n\t\t\t\telse if ( peek == '/' ) {\n\t\t\t\t\tself.comment();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow \"Unknown character '/', maybe a comment?\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t}\n\t\t\telse if ( rwhitespace.exec( self.c ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if ( self.c == \":\" ) {\n\t\t\t\treturn self.value();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow \"Unknown Character '\" + self.c + \"', expecting a semicolon.\";\n\t\t\t}\n\t\t}\n\t},\n\n\t// Value statement\n\tvalue: function(){\n\t\tvar self = this, peek = '';\n\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( self.options.comments && self.c == '/' ) {\n\t\t\t\tpeek = self.json[ self.i + 1 ];\n\t\t\t\tif ( peek == '*' ) {\n\t\t\t\t\tself.multicomment();\n\t\t\t\t}\n\t\t\t\telse if ( peek == '/' ) {\n\t\t\t\t\tself.comment();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow \"Unknown character '/', maybe a comment?\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t}\n\t\t\telse if ( rwhitespace.exec( self.c ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if ( self.c == '{' ) {\n\t\t\t\tself.object();\n\t\t\t\treturn self.endval();\n\t\t\t}\n\t\t\telse if ( self.c == '[' ) {\n\t\t\t\tself.array();\n\t\t\t\treturn self.endval();\n\t\t\t}\n\t\t\telse if ( self.c == '\"' ) {\n\t\t\t\tself.string();\n\t\t\t\treturn self.endval();\n\t\t\t}\n\t\t\telse if ( self.json.indexOf( 'true', self.i ) === self.i ) {\n\t\t\t\tself.i += 3;\n\t\t\t\tself.character += 3;\n\t\t\t\treturn self.endval();\n\t\t\t}\n\t\t\telse if ( self.json.indexOf( 'false', self.i ) === self.i ) {\n\t\t\t\tself.i += 4;\n\t\t\t\tself.character += 4;\n\t\t\t\treturn self.endval();\n\t\t\t}\n\t\t\telse if ( self.json.indexOf( 'null', self.i ) === self.i ) {\n\t\t\t\tself.i += 3;\n\t\t\t\tself.character += 3;\n\t\t\t\treturn self.endval();\n\t\t\t}\n\t\t\telse if ( self.c == '-' || rnumber.exec( self.c ) ) {\n\t\t\t\treturn self.numeric();\n\t\t\t}\n\t\t\telse if ( self.c == ']' && self.endblock == ']' ) {\n\t\t\t\tif ( self.commabreak ) {\n\t\t\t\t\tthrow \"Unexpected End Of Array Error. Expecting a value statement.\";\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow \"Unknown Character '\" + self.c + \"', expecting a value.\";\n\t\t\t}\n\t\t}\n\t},\n\n\t// String statement\n\tstring: function(){\n\t\tvar self = this, found = false, m;\n\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( self.c == \"\\\\\" ) {\n\t\t\t\tif ( ( m = rvalidsolidus.exec( self.json.substr( self.i ) ) ) && m.index === 0 ) {\n\t\t\t\t\tself.i += m[ 1 ].length;\n\t\t\t\t\tself.character += m[ 1 ].length;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow \"Invalid Reverse Solidus '\\\\' declaration.\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t}\n\t\t\telse if ( self.c == '\"' ) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Make sure close string is found\n\t\tif ( ! found ) {\n\t\t\tthrow \"EOF: No close string '\\\"' found.\";\n\t\t}\n\t},\n\n\t// Numeric Value\n\tnumeric: function(){\n\t\tvar self = this,\n\t\t\tnegative = true,\n\t\t\tdecimal = null,\n\t\t\te = null,\n\t\t\tpeek = '';\n\n\t\t// We need to jump back a character to catch the whole number\n\t\tself.i--;\n\t\tself.character--;\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\t// Handle initial negative sign\n\t\t\tif ( negative ) {\n\t\t\t\tnegative = false;\n\t\t\t\tif ( self.c == '-' ) {\n\t\t\t\t\tif ( ! rnumber.exec( self.json[ self.i + 1 ] ) ) {\n\t\t\t\t\t\tthrow \"Unknown Character '\" + self.c + \"' following a negative, expecting a numeric value.\";\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Only a single decimal is allowed in a numeric value\n\t\t\tif ( decimal && self.c == '.' ) {\n\t\t\t\tdecimal = false;\n\t\t\t\te = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Only a single e notation is allowed in a numeric value\n\t\t\telse if ( e && self.c.toLowerCase() == 'e' ) {\n\t\t\t\te = false;\n\t\t\t\tnegative = true;\n\t\t\t\tif ( rE.exec( self.json.substr( self.i + 1, 2 ) ) ) {\n\t\t\t\t\tself.character++;\n\t\t\t\t\tself.i++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tself.character++;\n\t\t\t\t\tthrow \"Unknown Character '\" + self.json[ self.i + 1 ] + \"' following e notation, expecting a numeric value.\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Normal Digit\n\t\t\telse if ( rnumber.exec( self.c ) ) {\n\t\t\t\tif ( decimal === null ) {\n\t\t\t\t\tdecimal = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Assume end of number, and allow endval to handle it\n\t\t\telse {\n\t\t\t\t// Jump back a character to include the current one\n\t\t\t\tself.i--;\n\t\t\t\tself.character--;\n\t\t\t\treturn self.endval();\n\t\t\t}\n\t\t}\n\t},\n\n\t// Ending a value statement\n\tendval: function(){\n\t\tvar self = this, peek = '';\n\t\tself.commabreak = false;\n\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( self.options.comments && self.c == '/' ) {\n\t\t\t\tpeek = self.json[ self.i + 1 ];\n\t\t\t\tif ( peek == '*' ) {\n\t\t\t\t\tself.multicomment();\n\t\t\t\t}\n\t\t\t\telse if ( peek == '/' ) {\n\t\t\t\t\tself.comment();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow \"Unknown character '/', maybe a comment?\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t}\n\t\t\telse if ( rwhitespace.exec( self.c ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if ( self.c == ',' ) {\n\t\t\t\tself.commabreak = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ( self.c == self.endblock ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow \"Unknown Character '\" + self.c + \"', expecting a comma or a closing '\" + self.endblock + \"'\";\n\t\t\t}\n\t\t}\n\t},\n\n\t// Expose line of the error\n\tsetEvidence: function(){\n\t\tvar self = this, start = self.line - 5, end = start + 8, evidence = '';\n\n\t\t// Min start\n\t\tif ( start < 0 ) {\n\t\t\tstart = 0;\n\t\t\tend = 8;\n\t\t}\n\n\t\t// Max end\n\t\tif ( end >= self._evidence.length ) {\n\t\t\tend = self._evidence.length;\n\t\t}\n\n\t\t// Evidence display\n\t\tfor ( ; start < end; start++ ) {\n\t\t\tevidence += ( start === ( self.line - 1 ) ? \"-> \" : \"   \" ) +\n\t\t\t\t( start + 1 ) + '| ' +\n\t\t\t\tself._evidence[ start ] + \"\\n\";\n\t\t}\n\n\t\t// Set the evidence display\n\t\tself.evidence = evidence;\n\t}\n};\n\n\n// Check for nodejs module system\nif ( true ) {\n\tmodule.exports = JSONLint;\n}\n// In a browser\nelse {\n\tglob.JSONLint = JSONLint;\n}\n\n})( this );\n\n\n/***/ }),\n\n/***/ \"aSS6\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".CodeMirror-lint-markers{width:16px}.CodeMirror-lint-tooltip{background-color:#ffd;border:1px solid #000;border-radius:4px 4px 4px 4px;color:#000;font-family:monospace;font-size:10pt;overflow:hidden;padding:2px 5px;position:fixed;white-space:pre;white-space:pre-wrap;z-index:100;max-width:600px;opacity:0;transition:opacity .4s;-moz-transition:opacity .4s;-webkit-transition:opacity .4s;-o-transition:opacity .4s;-ms-transition:opacity .4s}.CodeMirror-lint-mark-error,.CodeMirror-lint-mark-warning{background-position:0 100%;background-repeat:repeat-x}.CodeMirror-lint-mark-error{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==\\\")}.CodeMirror-lint-mark-warning{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=\\\")}.CodeMirror-lint-marker-error,.CodeMirror-lint-marker-warning{background-position:50%;background-repeat:no-repeat;cursor:pointer;display:inline-block;height:16px;width:16px;vertical-align:middle;position:relative}.CodeMirror-lint-message-error,.CodeMirror-lint-message-warning{padding-left:18px;background-position:0 0;background-repeat:no-repeat}.CodeMirror-lint-marker-error,.CodeMirror-lint-message-error{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=\\\")}.CodeMirror-lint-marker-warning,.CodeMirror-lint-message-warning{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=\\\")}.CodeMirror-lint-marker-multiple{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC\\\");background-repeat:no-repeat;background-position:100% 100%;width:100%;height:100%}\", \"\", {\"version\":3,\"sources\":[\"/home/travis/build/voorhoede/manifiesta/node_modules/codemirror/addon/lint/lint.css\"],\"names\":[],\"mappings\":\"AACA,yBACE,UAAY,CACb,AAED,yBACE,sBAAuB,AACvB,sBAAwB,AACxB,8BAA+B,AAC/B,WAAa,AACb,sBAAuB,AACvB,eAAgB,AAChB,gBAAiB,AACjB,gBAAiB,AACjB,eAAgB,AAChB,gBAAiB,AACjB,qBAAsB,AACtB,YAAa,AACb,gBAAiB,AACjB,UAAW,AACX,uBAAwB,AACxB,4BAA6B,AAC7B,+BAAgC,AAChC,0BAA2B,AAC3B,0BAA4B,CAC7B,AAED,0DACE,2BAAiC,AACjC,0BAA4B,CAC7B,AAED,4BACE,kTAEC,CACF,AAED,8BACE,8UAAgV,CACjV,AAED,8DACE,wBAAmC,AACnC,4BAA6B,AAC7B,eAAgB,AAChB,qBAAsB,AACtB,YAAa,AACb,WAAY,AACZ,sBAAuB,AACvB,iBAAmB,CACpB,AAED,gEACE,kBAAmB,AACnB,wBAA8B,AAC9B,2BAA6B,CAC9B,AAED,6DACE,kTAAoT,CACrT,AAED,iEACE,sWAAwW,CACzW,AAED,iCACE,uNAAwN,AACxN,4BAA6B,AAC7B,8BAAkC,AAClC,WAAY,AAAC,WAAa,CAC3B\",\"file\":\"lint.css\",\"sourcesContent\":[\"/* The lint marker gutter */\\n.CodeMirror-lint-markers {\\n  width: 16px;\\n}\\n\\n.CodeMirror-lint-tooltip {\\n  background-color: #ffd;\\n  border: 1px solid black;\\n  border-radius: 4px 4px 4px 4px;\\n  color: black;\\n  font-family: monospace;\\n  font-size: 10pt;\\n  overflow: hidden;\\n  padding: 2px 5px;\\n  position: fixed;\\n  white-space: pre;\\n  white-space: pre-wrap;\\n  z-index: 100;\\n  max-width: 600px;\\n  opacity: 0;\\n  transition: opacity .4s;\\n  -moz-transition: opacity .4s;\\n  -webkit-transition: opacity .4s;\\n  -o-transition: opacity .4s;\\n  -ms-transition: opacity .4s;\\n}\\n\\n.CodeMirror-lint-mark-error, .CodeMirror-lint-mark-warning {\\n  background-position: left bottom;\\n  background-repeat: repeat-x;\\n}\\n\\n.CodeMirror-lint-mark-error {\\n  background-image:\\n  url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==\\\")\\n  ;\\n}\\n\\n.CodeMirror-lint-mark-warning {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=\\\");\\n}\\n\\n.CodeMirror-lint-marker-error, .CodeMirror-lint-marker-warning {\\n  background-position: center center;\\n  background-repeat: no-repeat;\\n  cursor: pointer;\\n  display: inline-block;\\n  height: 16px;\\n  width: 16px;\\n  vertical-align: middle;\\n  position: relative;\\n}\\n\\n.CodeMirror-lint-message-error, .CodeMirror-lint-message-warning {\\n  padding-left: 18px;\\n  background-position: top left;\\n  background-repeat: no-repeat;\\n}\\n\\n.CodeMirror-lint-marker-error, .CodeMirror-lint-message-error {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=\\\");\\n}\\n\\n.CodeMirror-lint-marker-warning, .CodeMirror-lint-message-warning {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=\\\");\\n}\\n\\n.CodeMirror-lint-marker-multiple {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC\\\");\\n  background-repeat: no-repeat;\\n  background-position: right bottom;\\n  width: 100%; height: 100%;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"d6Mc\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__ = __webpack_require__(\"fZjL\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__language_tags__ = __webpack_require__(\"OlnX\");\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  type: 'object',\n  properties: {\n    // https://www.w3.org/TR/appmanifest/#name-member\n    name: {\n      required: true,\n      type: 'string'\n    },\n    // https://www.w3.org/TR/appmanifest/#short_name-member\n    short_name: {\n      required: true,\n      type: 'string'\n    },\n    // https://www.w3.org/TR/appmanifest/#start_url-member\n    start_url: {\n      required: true,\n      type: 'string'\n    },\n    // https://www.w3.org/TR/appmanifest/#icons-member\n    icons: {\n      required: true,\n      type: 'array'\n    },\n    // https://www.w3.org/TR/appmanifest/#dir-member\n    dir: {\n      type: 'string',\n      enum: ['auto', 'ltr', 'rtl']\n    },\n    // https://www.w3.org/TR/appmanifest/#lang-member\n    lang: {\n      type: 'string',\n      enum: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default()(__WEBPACK_IMPORTED_MODULE_1__language_tags__[\"a\" /* default */])\n    },\n    // https://www.w3.org/TR/appmanifest/#description-member\n    description: {\n      type: 'string'\n    },\n    // https://www.w3.org/TR/appmanifest/#scope-member\n    scope: {\n      type: 'string'\n    },\n    // https://www.w3.org/TR/appmanifest/#display-member\n    display: {\n      type: 'string',\n      enum: ['fullscreen', 'standalone', 'minimal-ui', 'browser']\n    },\n    // https://www.w3.org/TR/appmanifest/#orientation-member\n    orientation: {\n      type: 'string',\n      enum: ['any', 'natural', 'landscape', 'landscape-primary', 'landscape-secondary', 'portrait', 'portrait-primary', 'portrait-secondary']\n    },\n    // https://www.w3.org/TR/appmanifest/#serviceworker-member\n    serviceworker: {\n      type: 'object'\n    },\n    // https://www.w3.org/TR/appmanifest/#theme_color-member\n    theme_color: {\n      type: 'string'\n    },\n    // https://www.w3.org/TR/appmanifest/#related_applications-member\n    related_applications: {\n      type: 'array'\n    },\n    // https://www.w3.org/TR/appmanifest/#prefer_related_applications-member\n    prefer_related_applications: {\n      type: 'boolean'\n    },\n    // https://www.w3.org/TR/appmanifest/#background_color-member\n    background_color: {\n      type: 'string'\n    },\n    // https://www.w3.org/TR/appmanifest/#categories-member\n    categories: {\n      type: 'array'\n    },\n    // https://www.w3.org/TR/appmanifest/#screenshots-member\n    screenshots: {\n      type: 'array'\n    },\n    // https://www.w3.org/TR/appmanifest/#iarc_rating_id-member\n    iarc_rating_id: {\n      type: 'object'\n    }\n  }\n});\n\n/***/ }),\n\n/***/ \"gC+Y\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__ = __webpack_require__(\"pFYg\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__);\n\n//\n//\n//\n//\n\nvar CodeMirror = __webpack_require__(\"8U58\");\n__webpack_require__(\"4/hK\");\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  props: {\n    value: {\n      type: String,\n      default: ''\n    },\n    options: {\n      type: Object,\n      default: function _default() {\n        return {\n          mode: 'text/javascript',\n          lineNumbers: true,\n          lineWrapping: true\n        };\n      }\n    }\n  },\n  data: function data() {\n    return {\n      skipNextChangeEvent: false\n    };\n  },\n  ready: function ready() {\n    var _this = this;\n    this.editor = CodeMirror.fromTextArea(this.$el, this.options);\n    this.editor.setValue(this.value);\n    this.editor.on('change', function (cm) {\n      if (_this.skipNextChangeEvent) {\n        _this.skipNextChangeEvent = false;\n        return;\n      }\n      _this.value = cm.getValue();\n      if (!!_this.$emit) {\n        _this.$emit('change', cm.getValue());\n      }\n    });\n  },\n  mounted: function mounted() {\n    var _this = this;\n    this.editor = CodeMirror.fromTextArea(this.$el, this.options);\n    this.editor.setValue(this.value);\n    this.editor.on('change', function (cm) {\n      if (_this.skipNextChangeEvent) {\n        _this.skipNextChangeEvent = false;\n        return;\n      }\n      if (!!_this.$emit) {\n        _this.$emit('change', cm.getValue());\n        _this.$emit('input', cm.getValue());\n      }\n    });\n  },\n  watch: {\n    'value': function value(newVal, oldVal) {\n      var editorValue = this.editor.getValue();\n      if (newVal !== editorValue) {\n        this.skipNextChangeEvent = true;\n        var scrollInfo = this.editor.getScrollInfo();\n        this.editor.setValue(newVal);\n        this.editor.scrollTo(scrollInfo.left, scrollInfo.top);\n      }\n    },\n    'options': function options(newOptions, oldVal) {\n      if ((typeof newOptions === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(newOptions)) === 'object') {\n        for (var optionName in newOptions) {\n          if (newOptions.hasOwnProperty(optionName)) {\n            this.editor.setOption(optionName, newOptions[optionName]);\n          }\n        }\n      }\n    }\n  },\n  beforeDestroy: function beforeDestroy() {\n    if (this.editor) {\n      this.editor.toTextArea();\n    }\n  }\n});\n\n/***/ }),\n\n/***/ \"gZhU\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar CodeMirror = __webpack_require__(\"8U58\")\nvar CmComponent = __webpack_require__(\"Lgoy\")\n\nconsole.log(CmComponent)\nCmComponent = CmComponent.default || CmComponent\n\nmodule.exports = {\n CodeMirror: CodeMirror,\n codemirror: CmComponent,\n install: function (Vue) {\n   Vue.component('codemirror', CmComponent)\n }\n}\n\n\n/***/ }),\n\n/***/ \"k8+T\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar uri = __webpack_require__(\"UZ5h\");\n\nvar ValidationError = exports.ValidationError = function ValidationError (message, instance, schema, propertyPath, name, argument) {\n  if (propertyPath) {\n    this.property = propertyPath;\n  }\n  if (message) {\n    this.message = message;\n  }\n  if (schema) {\n    if (schema.id) {\n      this.schema = schema.id;\n    } else {\n      this.schema = schema;\n    }\n  }\n  if (instance) {\n    this.instance = instance;\n  }\n  this.name = name;\n  this.argument = argument;\n  this.stack = this.toString();\n};\n\nValidationError.prototype.toString = function toString() {\n  return this.property + ' ' + this.message;\n};\n\nvar ValidatorResult = exports.ValidatorResult = function ValidatorResult(instance, schema, options, ctx) {\n  this.instance = instance;\n  this.schema = schema;\n  this.propertyPath = ctx.propertyPath;\n  this.errors = [];\n  this.throwError = options && options.throwError;\n  this.disableFormat = options && options.disableFormat === true;\n};\n\nValidatorResult.prototype.addError = function addError(detail) {\n  var err;\n  if (typeof detail == 'string') {\n    err = new ValidationError(detail, this.instance, this.schema, this.propertyPath);\n  } else {\n    if (!detail) throw new Error('Missing error detail');\n    if (!detail.message) throw new Error('Missing error message');\n    if (!detail.name) throw new Error('Missing validator type');\n    err = new ValidationError(detail.message, this.instance, this.schema, this.propertyPath, detail.name, detail.argument);\n  }\n\n  if (this.throwError) {\n    throw err;\n  }\n  this.errors.push(err);\n  return err;\n};\n\nValidatorResult.prototype.importErrors = function importErrors(res) {\n  if (typeof res == 'string' || (res && res.validatorType)) {\n    this.addError(res);\n  } else if (res && res.errors) {\n    Array.prototype.push.apply(this.errors, res.errors);\n  }\n};\n\nfunction stringizer (v,i){\n  return i+': '+v.toString()+'\\n';\n}\nValidatorResult.prototype.toString = function toString(res) {\n  return this.errors.map(stringizer).join('');\n};\n\nObject.defineProperty(ValidatorResult.prototype, \"valid\", { get: function() {\n  return !this.errors.length;\n} });\n\n/**\n * Describes a problem with a Schema which prevents validation of an instance\n * @name SchemaError\n * @constructor\n */\nvar SchemaError = exports.SchemaError = function SchemaError (msg, schema) {\n  this.message = msg;\n  this.schema = schema;\n  Error.call(this, msg);\n  Error.captureStackTrace(this, SchemaError);\n};\nSchemaError.prototype = Object.create(Error.prototype,\n  { constructor: {value: SchemaError, enumerable: false}\n  , name: {value: 'SchemaError', enumerable: false}\n  });\n\nvar SchemaContext = exports.SchemaContext = function SchemaContext (schema, options, propertyPath, base, schemas) {\n  this.schema = schema;\n  this.options = options;\n  this.propertyPath = propertyPath;\n  this.base = base;\n  this.schemas = schemas;\n};\n\nSchemaContext.prototype.resolve = function resolve (target) {\n  return uri.resolve(this.base, target);\n};\n\nSchemaContext.prototype.makeChild = function makeChild(schema, propertyName){\n  var propertyPath = (propertyName===undefined) ? this.propertyPath : this.propertyPath+makeSuffix(propertyName);\n  var base = uri.resolve(this.base, schema.id||'');\n  var ctx = new SchemaContext(schema, this.options, propertyPath, base, Object.create(this.schemas));\n  if(schema.id && !ctx.schemas[base]){\n    ctx.schemas[base] = schema;\n  }\n  return ctx;\n}\n\nvar FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {\n  'date-time': /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\\.\\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,\n  'date': /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,\n  'time': /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,\n\n  'email': /^(?:[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+\\.)*[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!\\.)){0,61}[a-zA-Z0-9]?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\\[(?:(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\]))$/,\n  'ip-address': /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,\n  'ipv6': /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/,\n  'uri': /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\\s]*$/,\n\n  'color': /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/,\n\n  // hostname regex from: http://stackoverflow.com/a/1420225/5628\n  'hostname': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n  'host-name': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n\n  'alpha': /^[a-zA-Z]+$/,\n  'alphanumeric': /^[a-zA-Z0-9]+$/,\n  'utc-millisec': function (input) {\n    return (typeof input === 'string') && parseFloat(input) === parseInt(input, 10) && !isNaN(input);\n  },\n  'regex': function (input) {\n    var result = true;\n    try {\n      new RegExp(input);\n    } catch (e) {\n      result = false;\n    }\n    return result;\n  },\n  'style': /\\s*(.+?):\\s*([^;]+);?/g,\n  'phone': /^\\+(?:[0-9] ?){6,14}[0-9]$/\n};\n\nFORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;\nFORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;\nFORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS['ip-address'];\n\nexports.isFormat = function isFormat (input, format, validator) {\n  if (typeof input === 'string' && FORMAT_REGEXPS[format] !== undefined) {\n    if (FORMAT_REGEXPS[format] instanceof RegExp) {\n      return FORMAT_REGEXPS[format].test(input);\n    }\n    if (typeof FORMAT_REGEXPS[format] === 'function') {\n      return FORMAT_REGEXPS[format](input);\n    }\n  } else if (validator && validator.customFormats &&\n      typeof validator.customFormats[format] === 'function') {\n    return validator.customFormats[format](input);\n  }\n  return true;\n};\n\nvar makeSuffix = exports.makeSuffix = function makeSuffix (key) {\n  key = key.toString();\n  // This function could be capable of outputting valid a ECMAScript string, but the\n  // resulting code for testing which form to use would be tens of thousands of characters long\n  // That means this will use the name form for some illegal forms\n  if (!key.match(/[.\\s\\[\\]]/) && !key.match(/^[\\d]/)) {\n    return '.' + key;\n  }\n  if (key.match(/^\\d+$/)) {\n    return '[' + key + ']';\n  }\n  return '[' + JSON.stringify(key) + ']';\n};\n\nexports.deepCompareStrict = function deepCompareStrict (a, b) {\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a instanceof Array) {\n    if (!(b instanceof Array)) {\n      return false;\n    }\n    if (a.length !== b.length) {\n      return false;\n    }\n    return a.every(function (v, i) {\n      return deepCompareStrict(a[i], b[i]);\n    });\n  }\n  if (typeof a === 'object') {\n    if (!a || !b) {\n      return a === b;\n    }\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n    return aKeys.every(function (v) {\n      return deepCompareStrict(a[v], b[v]);\n    });\n  }\n  return a === b;\n};\n\nfunction deepMerger (target, dst, e, i) {\n  if (typeof e === 'object') {\n    dst[i] = deepMerge(target[i], e)\n  } else {\n    if (target.indexOf(e) === -1) {\n      dst.push(e)\n    }\n  }\n}\n\nfunction copyist (src, dst, key) {\n  dst[key] = src[key];\n}\n\nfunction copyistWithDeepMerge (target, src, dst, key) {\n  if (typeof src[key] !== 'object' || !src[key]) {\n    dst[key] = src[key];\n  }\n  else {\n    if (!target[key]) {\n      dst[key] = src[key];\n    } else {\n      dst[key] = deepMerge(target[key], src[key])\n    }\n  }\n}\n\nfunction deepMerge (target, src) {\n  var array = Array.isArray(src);\n  var dst = array && [] || {};\n\n  if (array) {\n    target = target || [];\n    dst = dst.concat(target);\n    src.forEach(deepMerger.bind(null, target, dst));\n  } else {\n    if (target && typeof target === 'object') {\n      Object.keys(target).forEach(copyist.bind(null, target, dst));\n    }\n    Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));\n  }\n\n  return dst;\n};\n\nmodule.exports.deepMerge = deepMerge;\n\n/**\n * Validates instance against the provided schema\n * Implements URI+JSON Pointer encoding, e.g. \"%7e\"=\"~0\"=>\"~\", \"~1\"=\"%2f\"=>\"/\"\n * @param o\n * @param s The path to walk o along\n * @return any\n */\nexports.objectGetPath = function objectGetPath(o, s) {\n  var parts = s.split('/').slice(1);\n  var k;\n  while (typeof (k=parts.shift()) == 'string') {\n    var n = decodeURIComponent(k.replace(/~0/,'~').replace(/~1/g,'/'));\n    if (!(n in o)) return;\n    o = o[n];\n  }\n  return o;\n};\n\nfunction pathEncoder (v) {\n  return '/'+encodeURIComponent(v).replace(/~/g,'%7E');\n}\n/**\n * Accept an Array of property names and return a JSON Pointer URI fragment\n * @param Array a\n * @return {String}\n */\nexports.encodePath = function encodePointer(a){\n\t// ~ must be encoded explicitly because hacks\n\t// the slash is encoded by encodeURIComponent\n\treturn a.map(pathEncoder).join('');\n};\n\n\n/**\n * Calculate the number of decimal places a number uses\n * We need this to get correct results out of multipleOf and divisibleBy\n * when either figure is has decimal places, due to IEEE-754 float issues.\n * @param number\n * @returns {number}\n */\nexports.getDecimalPlaces = function getDecimalPlaces(number) {\n\n  var decimalPlaces = 0;\n  if (isNaN(number)) return decimalPlaces;\n\n  if (typeof number !== 'number') {\n    number = Number(number);\n  }\n\n  var parts = number.toString().split('e');\n  if (parts.length === 2) {\n    if (parts[1][0] !== '-') {\n      return decimalPlaces;\n    } else {\n      decimalPlaces = Number(parts[1].slice(1));\n    }\n  }\n\n  var decimalParts = parts[0].split('.');\n  if (decimalParts.length === 2) {\n    decimalPlaces += decimalParts[1].length;\n  }\n\n  return decimalPlaces;\n};\n\n\n\n/***/ }),\n\n/***/ \"kMPS\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n/***/ }),\n\n/***/ \"mvHQ\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(\"qkKv\"), __esModule: true };\n\n/***/ }),\n\n/***/ \"qOJP\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n\n\n/***/ }),\n\n/***/ \"qkKv\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar core = __webpack_require__(\"FeBl\");\nvar $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });\nmodule.exports = function stringify(it) { // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n\n\n/***/ }),\n\n/***/ \"ryyk\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var GUTTER_ID = \"CodeMirror-lint-markers\";\n\n  function showTooltip(e, content) {\n    var tt = document.createElement(\"div\");\n    tt.className = \"CodeMirror-lint-tooltip\";\n    tt.appendChild(content.cloneNode(true));\n    document.body.appendChild(tt);\n\n    function position(e) {\n      if (!tt.parentNode) return CodeMirror.off(document, \"mousemove\", position);\n      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + \"px\";\n      tt.style.left = (e.clientX + 5) + \"px\";\n    }\n    CodeMirror.on(document, \"mousemove\", position);\n    position(e);\n    if (tt.style.opacity != null) tt.style.opacity = 1;\n    return tt;\n  }\n  function rm(elt) {\n    if (elt.parentNode) elt.parentNode.removeChild(elt);\n  }\n  function hideTooltip(tt) {\n    if (!tt.parentNode) return;\n    if (tt.style.opacity == null) rm(tt);\n    tt.style.opacity = 0;\n    setTimeout(function() { rm(tt); }, 600);\n  }\n\n  function showTooltipFor(e, content, node) {\n    var tooltip = showTooltip(e, content);\n    function hide() {\n      CodeMirror.off(node, \"mouseout\", hide);\n      if (tooltip) { hideTooltip(tooltip); tooltip = null; }\n    }\n    var poll = setInterval(function() {\n      if (tooltip) for (var n = node;; n = n.parentNode) {\n        if (n && n.nodeType == 11) n = n.host;\n        if (n == document.body) return;\n        if (!n) { hide(); break; }\n      }\n      if (!tooltip) return clearInterval(poll);\n    }, 400);\n    CodeMirror.on(node, \"mouseout\", hide);\n  }\n\n  function LintState(cm, options, hasGutter) {\n    this.marked = [];\n    this.options = options;\n    this.timeout = null;\n    this.hasGutter = hasGutter;\n    this.onMouseOver = function(e) { onMouseOver(cm, e); };\n    this.waitingFor = 0\n  }\n\n  function parseOptions(_cm, options) {\n    if (options instanceof Function) return {getAnnotations: options};\n    if (!options || options === true) options = {};\n    return options;\n  }\n\n  function clearMarks(cm) {\n    var state = cm.state.lint;\n    if (state.hasGutter) cm.clearGutter(GUTTER_ID);\n    for (var i = 0; i < state.marked.length; ++i)\n      state.marked[i].clear();\n    state.marked.length = 0;\n  }\n\n  function makeMarker(labels, severity, multiple, tooltips) {\n    var marker = document.createElement(\"div\"), inner = marker;\n    marker.className = \"CodeMirror-lint-marker-\" + severity;\n    if (multiple) {\n      inner = marker.appendChild(document.createElement(\"div\"));\n      inner.className = \"CodeMirror-lint-marker-multiple\";\n    }\n\n    if (tooltips != false) CodeMirror.on(inner, \"mouseover\", function(e) {\n      showTooltipFor(e, labels, inner);\n    });\n\n    return marker;\n  }\n\n  function getMaxSeverity(a, b) {\n    if (a == \"error\") return a;\n    else return b;\n  }\n\n  function groupByLine(annotations) {\n    var lines = [];\n    for (var i = 0; i < annotations.length; ++i) {\n      var ann = annotations[i], line = ann.from.line;\n      (lines[line] || (lines[line] = [])).push(ann);\n    }\n    return lines;\n  }\n\n  function annotationTooltip(ann) {\n    var severity = ann.severity;\n    if (!severity) severity = \"error\";\n    var tip = document.createElement(\"div\");\n    tip.className = \"CodeMirror-lint-message-\" + severity;\n    if (typeof ann.messageHTML != 'undefined') {\n        tip.innerHTML = ann.messageHTML;\n    } else {\n        tip.appendChild(document.createTextNode(ann.message));\n    }\n    return tip;\n  }\n\n  function lintAsync(cm, getAnnotations, passOptions) {\n    var state = cm.state.lint\n    var id = ++state.waitingFor\n    function abort() {\n      id = -1\n      cm.off(\"change\", abort)\n    }\n    cm.on(\"change\", abort)\n    getAnnotations(cm.getValue(), function(annotations, arg2) {\n      cm.off(\"change\", abort)\n      if (state.waitingFor != id) return\n      if (arg2 && annotations instanceof CodeMirror) annotations = arg2\n      updateLinting(cm, annotations)\n    }, passOptions, cm);\n  }\n\n  function startLinting(cm) {\n    var state = cm.state.lint, options = state.options;\n    /*\n     * Passing rules in `options` property prevents JSHint (and other linters) from complaining\n     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.\n     */\n    var passOptions = options.options || options;\n    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\n    if (!getAnnotations) return;\n    if (options.async || getAnnotations.async) {\n      lintAsync(cm, getAnnotations, passOptions)\n    } else {\n      var annotations = getAnnotations(cm.getValue(), passOptions, cm);\n      if (!annotations) return;\n      if (annotations.then) annotations.then(function(issues) {\n        updateLinting(cm, issues);\n      });\n      else updateLinting(cm, annotations);\n    }\n  }\n\n  function updateLinting(cm, annotationsNotSorted) {\n    clearMarks(cm);\n    var state = cm.state.lint, options = state.options;\n\n    var annotations = groupByLine(annotationsNotSorted);\n\n    for (var line = 0; line < annotations.length; ++line) {\n      var anns = annotations[line];\n      if (!anns) continue;\n\n      var maxSeverity = null;\n      var tipLabel = state.hasGutter && document.createDocumentFragment();\n\n      for (var i = 0; i < anns.length; ++i) {\n        var ann = anns[i];\n        var severity = ann.severity;\n        if (!severity) severity = \"error\";\n        maxSeverity = getMaxSeverity(maxSeverity, severity);\n\n        if (options.formatAnnotation) ann = options.formatAnnotation(ann);\n        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));\n\n        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {\n          className: \"CodeMirror-lint-mark-\" + severity,\n          __annotation: ann\n        }));\n      }\n\n      if (state.hasGutter)\n        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,\n                                                       state.options.tooltips));\n    }\n    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.lint;\n    if (!state) return;\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);\n  }\n\n  function popupTooltips(annotations, e) {\n    var target = e.target || e.srcElement;\n    var tooltip = document.createDocumentFragment();\n    for (var i = 0; i < annotations.length; i++) {\n      var ann = annotations[i];\n      tooltip.appendChild(annotationTooltip(ann));\n    }\n    showTooltipFor(e, tooltip, target);\n  }\n\n  function onMouseOver(cm, e) {\n    var target = e.target || e.srcElement;\n    if (!/\\bCodeMirror-lint-mark-/.test(target.className)) return;\n    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;\n    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, \"client\"));\n\n    var annotations = [];\n    for (var i = 0; i < spans.length; ++i) {\n      var ann = spans[i].__annotation;\n      if (ann) annotations.push(ann);\n    }\n    if (annotations.length) popupTooltips(annotations, e);\n  }\n\n  CodeMirror.defineOption(\"lint\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      clearMarks(cm);\n      if (cm.state.lint.options.lintOnChange !== false)\n        cm.off(\"change\", onChange);\n      CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\n      clearTimeout(cm.state.lint.timeout);\n      delete cm.state.lint;\n    }\n\n    if (val) {\n      var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\n      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;\n      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);\n      if (state.options.lintOnChange !== false)\n        cm.on(\"change\", onChange);\n      if (state.options.tooltips != false && state.options.tooltips != \"gutter\")\n        CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n\n      startLinting(cm);\n    }\n  });\n\n  CodeMirror.defineExtension(\"performLint\", function() {\n    if (this.state.lint) startLinting(this);\n  });\n});\n\n\n/***/ }),\n\n/***/ \"xaZU\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/0.2775868eef29d18b513f.js","<template>\n  <div class=\"manifest-editor\">\n    <codemirror v-model=\"code\" :options=\"options\"></codemirror>\n  </div>\n</template>\n\n<script>\n  import VueTypes from 'vue-types'\n  import debounce from '../../lib/debounce'\n  import { codemirror } from 'vue-codemirror-lite'\n  require('../../lib/codemirror-lint-manifest')\n\n  export default {\n    components: {\n      codemirror\n    },\n    props: {\n      manifest: VueTypes.object.isRequired,\n      setManifest: VueTypes.func.isRequired\n    },\n    data () {\n      return {\n        options: {\n          mode: {\n            name: 'javascript',\n            json: true\n          },\n          theme: 'eclipse',\n          lineNumbers: false,\n          tabSize: 2,\n          lint: true,\n          gutters: ['CodeMirror-lint-markers']\n        }\n      }\n    },\n    computed: {\n      code: {\n        get () {\n          return JSON.stringify(this.manifest, null, '\\t')\n        },\n        set: debounce(function (value) {\n          this.setManifest(value)\n        }, 250)\n      }\n    }\n  }\n</script>\n\n<style src=\"./manifest-editor.scss\" lang=\"scss\"></style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/manifest-editor/manifest-editor.vue","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/querystring-es3/index.js\n// module id = 1nuA\n// module chunks = 0","'use strict';\n\nvar urilib = require('url');\n\nvar attribute = require('./attribute');\nvar helpers = require('./helpers');\nvar ValidatorResult = helpers.ValidatorResult;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext;\n\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */\nvar Validator = function Validator () {\n  // Allow a validator instance to override global custom formats or to have their\n  // own custom formats.\n  this.customFormats = Object.create(Validator.prototype.customFormats);\n  this.schemas = {};\n  this.unresolvedRefs = [];\n\n  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n  this.types = Object.create(types);\n  this.attributes = Object.create(attribute.validators);\n};\n\n// Allow formats to be registered globally.\nValidator.prototype.customFormats = {};\n\n// Hint at the presence of a property\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */\nValidator.prototype.addSchema = function addSchema (schema, uri) {\n  if (!schema) {\n    return null;\n  }\n  var ourUri = uri || schema.id;\n  this.addSubSchema(ourUri, schema);\n  if (ourUri) {\n    this.schemas[ourUri] = schema;\n  }\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchema = function addSubSchema(baseuri, schema) {\n  if(!schema || typeof schema!='object') return;\n  // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined\n  if(schema.$ref){\n    var resolvedUri = urilib.resolve(baseuri, schema.$ref);\n    // Only mark unknown schemas as unresolved\n    if (this.schemas[resolvedUri] === undefined) {\n      this.schemas[resolvedUri] = null;\n      this.unresolvedRefs.push(resolvedUri);\n    }\n    return;\n  }\n  var ourUri = schema.id && urilib.resolve(baseuri, schema.id);\n  var ourBase = ourUri || baseuri;\n  if (ourUri) {\n    if(this.schemas[ourUri]){\n      if(!helpers.deepCompareStrict(this.schemas[ourUri], schema)){\n        throw new Error('Schema <'+schema+'> already exists with different definition');\n      }\n      return this.schemas[ourUri];\n    }\n    this.schemas[ourUri] = schema;\n    var documentUri = ourUri.replace(/^([^#]*)#$/, '$1');\n    this.schemas[documentUri] = schema;\n  }\n  this.addSubSchemaArray(ourBase, ((schema.items instanceof Array)?schema.items:[schema.items]));\n  this.addSubSchemaArray(ourBase, ((schema.extends instanceof Array)?schema.extends:[schema.extends]));\n  this.addSubSchema(ourBase, schema.additionalItems);\n  this.addSubSchemaObject(ourBase, schema.properties);\n  this.addSubSchema(ourBase, schema.additionalProperties);\n  this.addSubSchemaObject(ourBase, schema.definitions);\n  this.addSubSchemaObject(ourBase, schema.patternProperties);\n  this.addSubSchemaObject(ourBase, schema.dependencies);\n  this.addSubSchemaArray(ourBase, schema.disallow);\n  this.addSubSchemaArray(ourBase, schema.allOf);\n  this.addSubSchemaArray(ourBase, schema.anyOf);\n  this.addSubSchemaArray(ourBase, schema.oneOf);\n  this.addSubSchema(ourBase, schema.not);\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n  if(!(schemas instanceof Array)) return;\n  for(var i=0; i<schemas.length; i++){\n    this.addSubSchema(baseuri, schemas[i]);\n  }\n};\n\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n  if(!schemas || typeof schemas!='object') return;\n  for(var p in schemas){\n    this.addSubSchema(baseuri, schemas[p]);\n  }\n};\n\n\n\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */\nValidator.prototype.setSchemas = function setSchemas (schemas) {\n  this.schemas = schemas;\n};\n\n/**\n * Returns the schema of a certain urn\n * @param urn\n */\nValidator.prototype.getSchema = function getSchema (urn) {\n  return this.schemas[urn];\n};\n\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */\nValidator.prototype.validate = function validate (instance, schema, options, ctx) {\n  if (!options) {\n    options = {};\n  }\n  var propertyName = options.propertyName || 'instance';\n  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n  var base = urilib.resolve(options.base||'/', schema.id||'');\n  if(!ctx){\n    ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));\n    if (!ctx.schemas[base]) {\n      ctx.schemas[base] = schema;\n    }\n  }\n  if (schema) {\n    var result = this.validateSchema(instance, schema, options, ctx);\n    if (!result) {\n      throw new Error('Result undefined');\n    }\n    return result;\n  }\n  throw new SchemaError('no schema specified', schema);\n};\n\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/\nfunction shouldResolve(schema) {\n  var ref = (typeof schema === 'string') ? schema : schema.$ref;\n  if (typeof ref=='string') return ref;\n  return false;\n}\n\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */\nValidator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema) {\n    throw new Error(\"schema is undefined\");\n  }\n\n  if (schema['extends']) {\n    if (schema['extends'] instanceof Array) {\n      var schemaobj = {schema: schema, ctx: ctx};\n      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));\n      schema = schemaobj.schema;\n      schemaobj.schema = null;\n      schemaobj.ctx = null;\n      schemaobj = null;\n    } else {\n      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));\n    }\n  }\n\n  var switchSchema;\n  if (switchSchema = shouldResolve(schema)) {\n    var resolved = this.resolve(schema, switchSchema, ctx);\n    var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);\n    return this.validateSchema(instance, resolved.subschema, options, subctx);\n  }\n\n  var skipAttributes = options && options.skipAttributes || [];\n  // Validate each schema attribute against the instance\n  for (var key in schema) {\n    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n      var validatorErr = null;\n      var validator = this.attributes[key];\n      if (validator) {\n        validatorErr = validator.call(this, instance, schema, options, ctx);\n      } else if (options.allowUnknownAttributes === false) {\n        // This represents an error with the schema itself, not an invalid instance\n        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n      }\n      if (validatorErr) {\n        result.importErrors(validatorErr);\n      }\n    }\n  }\n\n  if (typeof options.rewrite == 'function') {\n    var value = options.rewrite.call(this, instance, schema, options, ctx);\n    result.instance = value;\n  }\n  return result;\n};\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.schemaTraverser = function schemaTraverser (schemaobj, s) {\n  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n}\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.superResolve = function superResolve (schema, ctx) {\n  var ref;\n  if(ref = shouldResolve(schema)) {\n    return this.resolve(schema, ref, ctx).subschema;\n  }\n  return schema;\n}\n\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/\nValidator.prototype.resolve = function resolve (schema, switchSchema, ctx) {\n  switchSchema = ctx.resolve(switchSchema);\n  // First see if the schema exists under the provided URI\n  if (ctx.schemas[switchSchema]) {\n    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};\n  }\n  // Else try walking the property pointer\n  var parsed = urilib.parse(switchSchema);\n  var fragment = parsed && parsed.hash;\n  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n  if (!document || !ctx.schemas[document]) {\n    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n  }\n  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n  if(subschema===undefined){\n    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n  }\n  return {subschema: subschema, switchSchema: switchSchema};\n};\n\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */\nValidator.prototype.testType = function validateType (instance, schema, options, ctx, type) {\n  if (typeof this.types[type] == 'function') {\n    return this.types[type].call(this, instance);\n  }\n  if (type && typeof type == 'object') {\n    var res = this.validateSchema(instance, type, options, ctx);\n    return res === undefined || !(res && res.errors.length);\n  }\n  // Undefined or properties not on the list are acceptable, same as not being defined\n  return true;\n};\n\nvar types = Validator.prototype.types = {};\ntypes.string = function testString (instance) {\n  return typeof instance == 'string';\n};\ntypes.number = function testNumber (instance) {\n  // isFinite returns false for NaN, Infinity, and -Infinity\n  return typeof instance == 'number' && isFinite(instance);\n};\ntypes.integer = function testInteger (instance) {\n  return (typeof instance == 'number') && instance % 1 === 0;\n};\ntypes.boolean = function testBoolean (instance) {\n  return typeof instance == 'boolean';\n};\ntypes.array = function testArray (instance) {\n  return Array.isArray(instance);\n};\ntypes['null'] = function testNull (instance) {\n  return instance === null;\n};\ntypes.date = function testDate (instance) {\n  return instance instanceof Date;\n};\ntypes.any = function testAny (instance) {\n  return true;\n};\ntypes.object = function testObject (instance) {\n  // TODO: fix this - see #15\n  return instance && (typeof instance) === 'object' && !(instance instanceof Array) && !(instance instanceof Date);\n};\n\nmodule.exports = Validator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsonschema/lib/validator.js\n// module id = 1tE4\n// module chunks = 0","module.exports = function(module) {\n\tif(!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif(!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 3IRH\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../css-loader/index.js??ref--6-2!./codemirror.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../vue-style-loader/lib/addStylesClient.js\")(\"5e9a0932\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/codemirror/lib/codemirror.css\n// module id = 4/hK\n// module chunks = 0","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-66e75edd\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!sass-loader?{\\\"sourceMap\\\":true}!./manifest-editor.scss\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./manifest-editor.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-66e75edd\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./manifest-editor.vue\"\n/* template functional */\n  var __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/manifest-editor/manifest-editor.vue\n// module id = 41tG\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    var jsKeywords = {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: \"variable\", style: \"type\"};\n      var tsKeywords = {\n        // object-like things\n        \"interface\": kw(\"class\"),\n        \"implements\": C,\n        \"namespace\": C,\n        \"module\": kw(\"module\"),\n        \"enum\": kw(\"module\"),\n\n        // scope modifiers\n        \"public\": kw(\"modifier\"),\n        \"private\": kw(\"modifier\"),\n        \"protected\": kw(\"modifier\"),\n        \"abstract\": kw(\"modifier\"),\n        \"readonly\": kw(\"modifier\"),\n\n        // types\n        \"string\": type, \"number\": type, \"boolean\": type, \"any\": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"0\" && stream.eat(/o/i)) {\n      stream.eatWhile(/[0-7]/i);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"0\" && stream.eat(/b/i)) {\n      stream.eatWhile(/[01]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyu])(?![gimyu]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^\\s*[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/]/.test(ch)) {\n        return;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (state.context) {\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      if (parserConfig.globalVars)\n        state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value.length), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"variable\") {\n      if (isTS && value == \"type\") {\n        cx.marked = \"keyword\"\n        return cont(typeexpr, expect(\"operator\"), typeexpr, expect(\";\"));\n      } if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"class\") return cont(pushlex(\"form\"), className, poplex);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"module\") return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), expression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\") return cont(pushlex(\"form\"), classExpression, poplex);\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (type == \"modifier\") {\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function typeexpr(type, value) {\n    if (type == \"variable\" || value == \"void\") {\n      if (value == \"keyof\") {\n        cx.marked = \"keyword\"\n        return cont(typeexpr)\n      } else {\n        cx.marked = \"type\"\n        return cont(afterType)\n      }\n    }\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\", \",;\"), poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType)\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), typeprop)\n    }\n  }\n  function typearg(type) {\n    if (type == \"variable\") return cont(typearg)\n    else if (type == \":\") return cont(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\") return cont(typeexpr)\n    if (type == \"[\") return cont(expect(\"]\"), afterType)\n    if (value == \"extends\") return cont(typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function vardef() {\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (type == \"modifier\") return cont(pattern)\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(pattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type) {\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\n    if (type == \";\") return cont(forspec2);\n    if (type == \"variable\") return cont(formaybeinof);\n    return pass(expression, expect(\";\"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return pass(expression, expect(\";\"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, maybetype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, functiondef)\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\" || type == \"modifier\") return cont(funarg);\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\"))\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"modifier\" || type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\") &&\n         cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(isTS ? classfield : functiondef, classBody);\n    }\n    if (type == \"[\")\n      return cont(expression, expect(\"]\"), isTS ? classfield : functiondef, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \";\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    return pass(functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      var top = state.cc[state.cc.length - 1]\n      if (top == expression || top == expressionNoComma) state.cc.pop()\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/codemirror/mode/javascript/javascript.js\n// module id = 5IAE\n// module chunks = 0","'use strict';\n\nvar Validator = module.exports.Validator = require('./validator');\n\nmodule.exports.ValidatorResult = require('./helpers').ValidatorResult;\nmodule.exports.ValidationError = require('./helpers').ValidationError;\nmodule.exports.SchemaError = require('./helpers').SchemaError;\n\nmodule.exports.validate = function (instance, schema, options) {\n  var v = new Validator();\n  return v.validate(instance, schema, options);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsonschema/lib/index.js\n// module id = 7HRn\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-5c584404\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../vue-loader/lib/selector.js?type=styles&index=0!./codemirror.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../vue-style-loader/lib/addStylesClient.js\")(\"bc5e0228\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/extract-text-webpack-plugin/dist/loader.js?{\"omit\":1,\"remove\":true}!./node_modules/vue-style-loader!./node_modules/css-loader?{\"minimize\":true,\"sourceMap\":true}!./node_modules/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-5c584404\",\"scoped\":false,\"hasInlineConfig\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./node_modules/vue-codemirror-lite/codemirror.vue\n// module id = 7xRv\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n// Kludges for bugs and behavior differences that can't be feature\n// detected are enabled based on userAgent etc sniffing.\nvar userAgent = navigator.userAgent;\nvar platform = navigator.platform;\n\nvar gecko = /gecko\\/\\d/i.test(userAgent);\nvar ie_upto10 = /MSIE \\d/.test(userAgent);\nvar ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\nvar edge = /Edge\\/(\\d+)/.exec(userAgent);\nvar ie = ie_upto10 || ie_11up || edge;\nvar ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\nvar webkit = !edge && /WebKit\\//.test(userAgent);\nvar qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\nvar chrome = !edge && /Chrome\\//.test(userAgent);\nvar presto = /Opera\\//.test(userAgent);\nvar safari = /Apple Computer/.test(navigator.vendor);\nvar mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\nvar phantom = /PhantomJS/.test(userAgent);\n\nvar ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\nvar android = /Android/.test(userAgent);\n// This is woefully incomplete. Suggestions for alternative methods welcome.\nvar mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\nvar mac = ios || /Mac/.test(platform);\nvar chromeOS = /\\bCrOS\\b/.test(userAgent);\nvar windows = /win/i.test(platform);\n\nvar presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\nif (presto_version) { presto_version = Number(presto_version[1]); }\nif (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n// Some browsers use the wrong event properties to signal cmd/ctrl on OS X\nvar flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\nvar captureRightClick = gecko || (ie && ie_version >= 9);\n\nfunction classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\nvar rmClass = function(node, cls) {\n  var current = node.className;\n  var match = classTest(cls).exec(current);\n  if (match) {\n    var after = current.slice(match.index + match[0].length);\n    node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n  }\n};\n\nfunction removeChildren(e) {\n  for (var count = e.childNodes.length; count > 0; --count)\n    { e.removeChild(e.firstChild); }\n  return e\n}\n\nfunction removeChildrenAndAdd(parent, e) {\n  return removeChildren(parent).appendChild(e)\n}\n\nfunction elt(tag, content, className, style) {\n  var e = document.createElement(tag);\n  if (className) { e.className = className; }\n  if (style) { e.style.cssText = style; }\n  if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n  return e\n}\n// wrapper for elt, which removes the elt from the accessibility tree\nfunction eltP(tag, content, className, style) {\n  var e = elt(tag, content, className, style);\n  e.setAttribute(\"role\", \"presentation\");\n  return e\n}\n\nvar range;\nif (document.createRange) { range = function(node, start, end, endNode) {\n  var r = document.createRange();\n  r.setEnd(endNode || node, end);\n  r.setStart(node, start);\n  return r\n}; }\nelse { range = function(node, start, end) {\n  var r = document.body.createTextRange();\n  try { r.moveToElementText(node.parentNode); }\n  catch(e) { return r }\n  r.collapse(true);\n  r.moveEnd(\"character\", end);\n  r.moveStart(\"character\", start);\n  return r\n}; }\n\nfunction contains(parent, child) {\n  if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n    { child = child.parentNode; }\n  if (parent.contains)\n    { return parent.contains(child) }\n  do {\n    if (child.nodeType == 11) { child = child.host; }\n    if (child == parent) { return true }\n  } while (child = child.parentNode)\n}\n\nfunction activeElt() {\n  // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n  // IE < 10 will throw when accessed while the page is loading or in an iframe.\n  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n  var activeElement;\n  try {\n    activeElement = document.activeElement;\n  } catch(e) {\n    activeElement = document.body || null;\n  }\n  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n    { activeElement = activeElement.shadowRoot.activeElement; }\n  return activeElement\n}\n\nfunction addClass(node, cls) {\n  var current = node.className;\n  if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n}\nfunction joinClasses(a, b) {\n  var as = a.split(\" \");\n  for (var i = 0; i < as.length; i++)\n    { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n  return b\n}\n\nvar selectInput = function(node) { node.select(); };\nif (ios) // Mobile Safari apparently has a bug where select() is broken.\n  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\nelse if (ie) // Suppress mysterious IE10 errors\n  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\nfunction bind(f) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function(){return f.apply(null, args)}\n}\n\nfunction copyObj(obj, target, overwrite) {\n  if (!target) { target = {}; }\n  for (var prop in obj)\n    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n      { target[prop] = obj[prop]; } }\n  return target\n}\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countColumn(string, end, tabSize, startIndex, startValue) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) { end = string.length; }\n  }\n  for (var i = startIndex || 0, n = startValue || 0;;) {\n    var nextTab = string.indexOf(\"\\t\", i);\n    if (nextTab < 0 || nextTab >= end)\n      { return n + (end - i) }\n    n += nextTab - i;\n    n += tabSize - (n % tabSize);\n    i = nextTab + 1;\n  }\n}\n\nvar Delayed = function() {this.id = null;};\nDelayed.prototype.set = function (ms, f) {\n  clearTimeout(this.id);\n  this.id = setTimeout(f, ms);\n};\n\nfunction indexOf(array, elt) {\n  for (var i = 0; i < array.length; ++i)\n    { if (array[i] == elt) { return i } }\n  return -1\n}\n\n// Number of pixels added to scroller and sizer to hide scrollbar\nvar scrollerGap = 30;\n\n// Returned or thrown by various protocols to signal 'I'm not\n// handling this'.\nvar Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n// Reused option objects for setSelection & friends\nvar sel_dontScroll = {scroll: false};\nvar sel_mouse = {origin: \"*mouse\"};\nvar sel_move = {origin: \"+move\"};\n\n// The inverse of countColumn -- find the offset that corresponds to\n// a particular column.\nfunction findColumn(string, goal, tabSize) {\n  for (var pos = 0, col = 0;;) {\n    var nextTab = string.indexOf(\"\\t\", pos);\n    if (nextTab == -1) { nextTab = string.length; }\n    var skipped = nextTab - pos;\n    if (nextTab == string.length || col + skipped >= goal)\n      { return pos + Math.min(skipped, goal - col) }\n    col += nextTab - pos;\n    col += tabSize - (col % tabSize);\n    pos = nextTab + 1;\n    if (col >= goal) { return pos }\n  }\n}\n\nvar spaceStrs = [\"\"];\nfunction spaceStr(n) {\n  while (spaceStrs.length <= n)\n    { spaceStrs.push(lst(spaceStrs) + \" \"); }\n  return spaceStrs[n]\n}\n\nfunction lst(arr) { return arr[arr.length-1] }\n\nfunction map(array, f) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n  return out\n}\n\nfunction insertSorted(array, value, score) {\n  var pos = 0, priority = score(value);\n  while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n  array.splice(pos, 0, value);\n}\n\nfunction nothing() {}\n\nfunction createObj(base, props) {\n  var inst;\n  if (Object.create) {\n    inst = Object.create(base);\n  } else {\n    nothing.prototype = base;\n    inst = new nothing();\n  }\n  if (props) { copyObj(props, inst); }\n  return inst\n}\n\nvar nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nfunction isWordCharBasic(ch) {\n  return /\\w/.test(ch) || ch > \"\\x80\" &&\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n}\nfunction isWordChar(ch, helper) {\n  if (!helper) { return isWordCharBasic(ch) }\n  if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n  return helper.test(ch)\n}\n\nfunction isEmpty(obj) {\n  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n  return true\n}\n\n// Extending unicode characters. A series of a non-extending char +\n// any number of extending chars is treated as a single unit as far\n// as editing and measuring is concerned. This is not fully correct,\n// since some scripts/fonts/browsers also treat other configurations\n// of code points as a group.\nvar extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\nfunction isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\nfunction skipExtendingChars(str, pos, dir) {\n  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n  return pos\n}\n\n// Returns the value from the range [`from`; `to`] that satisfies\n// `pred` and is closest to `from`. Assumes that at least `to`\n// satisfies `pred`. Supports `from` being greater than `to`.\nfunction findFirst(pred, from, to) {\n  // At any point we are certain `to` satisfies `pred`, don't know\n  // whether `from` does.\n  var dir = from > to ? -1 : 1;\n  for (;;) {\n    if (from == to) { return from }\n    var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n    if (mid == from) { return pred(mid) ? from : to }\n    if (pred(mid)) { to = mid; }\n    else { from = mid + dir; }\n  }\n}\n\n// The display handles the DOM integration, both for input reading\n// and content drawing. It holds references to DOM nodes and\n// display-related state.\n\nfunction Display(place, doc, input) {\n  var d = this;\n  this.input = input;\n\n  // Covers bottom-right square when both scrollbars are present.\n  d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n  d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Covers bottom of gutter when coverGutterNextToScrollbar is on\n  // and h scrollbar is present.\n  d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n  d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Will contain the actual code, positioned to cover the viewport.\n  d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n  // Elements are added to these to represent selection and cursors.\n  d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n  d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n  // A visibility: hidden element used to find the size of things.\n  d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n  // When lines outside of the viewport are measured, they are drawn in this.\n  d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n  // Wraps everything that needs to exist inside the vertically-padded coordinate system\n  d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                    null, \"position: relative; outline: none\");\n  var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n  // Moved around its parent to cover visible view.\n  d.mover = elt(\"div\", [lines], null, \"position: relative\");\n  // Set to the height of the document, allowing scrolling.\n  d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n  d.sizerWidth = null;\n  // Behavior of elts with overflow: auto and padding is\n  // inconsistent across browsers. This is used to ensure the\n  // scrollable area is big enough.\n  d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n  // Will contain the gutters, if any.\n  d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n  d.lineGutter = null;\n  // Actual scrollable element.\n  d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n  d.scroller.setAttribute(\"tabIndex\", \"-1\");\n  // The element in which the editor lives.\n  d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n  if (place) {\n    if (place.appendChild) { place.appendChild(d.wrapper); }\n    else { place(d.wrapper); }\n  }\n\n  // Current rendered range (may be bigger than the view window).\n  d.viewFrom = d.viewTo = doc.first;\n  d.reportedViewFrom = d.reportedViewTo = doc.first;\n  // Information about the rendered lines.\n  d.view = [];\n  d.renderedView = null;\n  // Holds info about a single rendered line when it was rendered\n  // for measurement, while not in view.\n  d.externalMeasured = null;\n  // Empty space (in pixels) above the view\n  d.viewOffset = 0;\n  d.lastWrapHeight = d.lastWrapWidth = 0;\n  d.updateLineNumbers = null;\n\n  d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n  d.scrollbarsClipped = false;\n\n  // Used to only resize the line number gutter when necessary (when\n  // the amount of lines crosses a boundary that makes its width change)\n  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n  // Set to true when a non-horizontal-scrolling line widget is\n  // added. As an optimization, line widget aligning is skipped when\n  // this is false.\n  d.alignWidgets = false;\n\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n  // Tracks the maximum line length so that the horizontal scrollbar\n  // can be kept static when scrolling.\n  d.maxLine = null;\n  d.maxLineLength = 0;\n  d.maxLineChanged = false;\n\n  // Used for measuring wheel scrolling granularity\n  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n  // True when shift is held down.\n  d.shift = false;\n\n  // Used to track whether anything happened since the context menu\n  // was opened.\n  d.selForContextMenu = null;\n\n  d.activeTouch = null;\n\n  input.init(d);\n}\n\n// Find the line object corresponding to the given line number.\nfunction getLine(doc, n) {\n  n -= doc.first;\n  if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n  var chunk = doc;\n  while (!chunk.lines) {\n    for (var i = 0;; ++i) {\n      var child = chunk.children[i], sz = child.chunkSize();\n      if (n < sz) { chunk = child; break }\n      n -= sz;\n    }\n  }\n  return chunk.lines[n]\n}\n\n// Get the part of a document between two positions, as an array of\n// strings.\nfunction getBetween(doc, start, end) {\n  var out = [], n = start.line;\n  doc.iter(start.line, end.line + 1, function (line) {\n    var text = line.text;\n    if (n == end.line) { text = text.slice(0, end.ch); }\n    if (n == start.line) { text = text.slice(start.ch); }\n    out.push(text);\n    ++n;\n  });\n  return out\n}\n// Get the lines between from and to, as array of strings.\nfunction getLines(doc, from, to) {\n  var out = [];\n  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n  return out\n}\n\n// Update the height of a line, propagating the height change\n// upwards to parent nodes.\nfunction updateLineHeight(line, height) {\n  var diff = height - line.height;\n  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n}\n\n// Given a line object, find its line number by walking up through\n// its parent links.\nfunction lineNo(line) {\n  if (line.parent == null) { return null }\n  var cur = line.parent, no = indexOf(cur.lines, line);\n  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n    for (var i = 0;; ++i) {\n      if (chunk.children[i] == cur) { break }\n      no += chunk.children[i].chunkSize();\n    }\n  }\n  return no + cur.first\n}\n\n// Find the line at the given vertical position, using the height\n// information in the document tree.\nfunction lineAtHeight(chunk, h) {\n  var n = chunk.first;\n  outer: do {\n    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n      var child = chunk.children[i$1], ch = child.height;\n      if (h < ch) { chunk = child; continue outer }\n      h -= ch;\n      n += child.chunkSize();\n    }\n    return n\n  } while (!chunk.lines)\n  var i = 0;\n  for (; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i], lh = line.height;\n    if (h < lh) { break }\n    h -= lh;\n  }\n  return n + i\n}\n\nfunction isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\nfunction lineNumberFor(options, i) {\n  return String(options.lineNumberFormatter(i + options.firstLineNumber))\n}\n\n// A Pos instance represents a position within the text.\nfunction Pos(line, ch, sticky) {\n  if ( sticky === void 0 ) sticky = null;\n\n  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n  this.line = line;\n  this.ch = ch;\n  this.sticky = sticky;\n}\n\n// Compare two positions, return 0 if they are the same, a negative\n// number when a is less, and a positive number otherwise.\nfunction cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\nfunction equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\nfunction copyPos(x) {return Pos(x.line, x.ch)}\nfunction maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\nfunction minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n// Most of the external API clips given positions to make sure they\n// actually exist within the document.\nfunction clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\nfunction clipPos(doc, pos) {\n  if (pos.line < doc.first) { return Pos(doc.first, 0) }\n  var last = doc.first + doc.size - 1;\n  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n  return clipToLen(pos, getLine(doc, pos.line).text.length)\n}\nfunction clipToLen(pos, linelen) {\n  var ch = pos.ch;\n  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n  else if (ch < 0) { return Pos(pos.line, 0) }\n  else { return pos }\n}\nfunction clipPosArray(doc, array) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n  return out\n}\n\n// Optimize some code when these features are not used.\nvar sawReadOnlySpans = false;\nvar sawCollapsedSpans = false;\n\nfunction seeReadOnlySpans() {\n  sawReadOnlySpans = true;\n}\n\nfunction seeCollapsedSpans() {\n  sawCollapsedSpans = true;\n}\n\n// TEXTMARKER SPANS\n\nfunction MarkedSpan(marker, from, to) {\n  this.marker = marker;\n  this.from = from; this.to = to;\n}\n\n// Search an array of spans for a span matching the given marker.\nfunction getMarkedSpanFor(spans, marker) {\n  if (spans) { for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.marker == marker) { return span }\n  } }\n}\n// Remove a span from an array, returning undefined if no spans are\n// left (we don't store arrays for lines without spans).\nfunction removeMarkedSpan(spans, span) {\n  var r;\n  for (var i = 0; i < spans.length; ++i)\n    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n  return r\n}\n// Add a span to a line.\nfunction addMarkedSpan(line, span) {\n  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n  span.marker.attachLine(line);\n}\n\n// Used for the algorithm that adjusts markers for a change in the\n// document. These functions cut an array of spans at a given\n// character position, returning an array of remaining chunks (or\n// undefined if nothing remains).\nfunction markedSpansBefore(old, startCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n    if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n    }\n  } }\n  return nw\n}\nfunction markedSpansAfter(old, endCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n    if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                            span.to == null ? null : span.to - endCh));\n    }\n  } }\n  return nw\n}\n\n// Given a change object, compute the new set of marker spans that\n// cover the line in which the change took place. Removes spans\n// entirely within the change, reconnects spans belonging to the\n// same marker that appear on both sides of the change, and cuts off\n// spans partially within the change. Returns an array of span\n// arrays with one element for each line in (after) the change.\nfunction stretchSpansOverChange(doc, change) {\n  if (change.full) { return null }\n  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n  if (!oldFirst && !oldLast) { return null }\n\n  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n  // Get the spans that 'stick out' on both sides\n  var first = markedSpansBefore(oldFirst, startCh, isInsert);\n  var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n  // Next, merge those two ends\n  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n  if (first) {\n    // Fix up .to properties of first\n    for (var i = 0; i < first.length; ++i) {\n      var span = first[i];\n      if (span.to == null) {\n        var found = getMarkedSpanFor(last, span.marker);\n        if (!found) { span.to = startCh; }\n        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n      }\n    }\n  }\n  if (last) {\n    // Fix up .from in last (or move them into first in case of sameLine)\n    for (var i$1 = 0; i$1 < last.length; ++i$1) {\n      var span$1 = last[i$1];\n      if (span$1.to != null) { span$1.to += offset; }\n      if (span$1.from == null) {\n        var found$1 = getMarkedSpanFor(first, span$1.marker);\n        if (!found$1) {\n          span$1.from = offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      } else {\n        span$1.from += offset;\n        if (sameLine) { (first || (first = [])).push(span$1); }\n      }\n    }\n  }\n  // Make sure we didn't create any zero-length spans\n  if (first) { first = clearEmptySpans(first); }\n  if (last && last != first) { last = clearEmptySpans(last); }\n\n  var newMarkers = [first];\n  if (!sameLine) {\n    // Fill gap with whole-line-spans\n    var gap = change.text.length - 2, gapMarkers;\n    if (gap > 0 && first)\n      { for (var i$2 = 0; i$2 < first.length; ++i$2)\n        { if (first[i$2].to == null)\n          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n    for (var i$3 = 0; i$3 < gap; ++i$3)\n      { newMarkers.push(gapMarkers); }\n    newMarkers.push(last);\n  }\n  return newMarkers\n}\n\n// Remove spans that are empty and don't have a clearWhenEmpty\n// option of false.\nfunction clearEmptySpans(spans) {\n  for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n      { spans.splice(i--, 1); }\n  }\n  if (!spans.length) { return null }\n  return spans\n}\n\n// Used to 'clip' out readOnly ranges when making a change.\nfunction removeReadOnlyRanges(doc, from, to) {\n  var markers = null;\n  doc.iter(from.line, to.line + 1, function (line) {\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var mark = line.markedSpans[i].marker;\n      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n        { (markers || (markers = [])).push(mark); }\n    } }\n  });\n  if (!markers) { return null }\n  var parts = [{from: from, to: to}];\n  for (var i = 0; i < markers.length; ++i) {\n    var mk = markers[i], m = mk.find(0);\n    for (var j = 0; j < parts.length; ++j) {\n      var p = parts[j];\n      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n        { newParts.push({from: p.from, to: m.from}); }\n      if (dto > 0 || !mk.inclusiveRight && !dto)\n        { newParts.push({from: m.to, to: p.to}); }\n      parts.splice.apply(parts, newParts);\n      j += newParts.length - 3;\n    }\n  }\n  return parts\n}\n\n// Connect or disconnect spans from a line.\nfunction detachMarkedSpans(line) {\n  var spans = line.markedSpans;\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.detachLine(line); }\n  line.markedSpans = null;\n}\nfunction attachMarkedSpans(line, spans) {\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.attachLine(line); }\n  line.markedSpans = spans;\n}\n\n// Helpers used when computing which overlapping collapsed span\n// counts as the larger one.\nfunction extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\nfunction extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n// Returns a number indicating which of two overlapping collapsed\n// spans is larger (and thus includes the other). Falls back to\n// comparing ids when the spans cover exactly the same range.\nfunction compareCollapsedMarkers(a, b) {\n  var lenDiff = a.lines.length - b.lines.length;\n  if (lenDiff != 0) { return lenDiff }\n  var aPos = a.find(), bPos = b.find();\n  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n  if (fromCmp) { return -fromCmp }\n  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n  if (toCmp) { return toCmp }\n  return b.id - a.id\n}\n\n// Find out whether a line ends or starts in a collapsed span. If\n// so, return the marker for that span.\nfunction collapsedSpanAtSide(line, start) {\n  var sps = sawCollapsedSpans && line.markedSpans, found;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n        (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n      { found = sp.marker; }\n  } }\n  return found\n}\nfunction collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\nfunction collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n// Test whether there exists a collapsed span that partially\n// overlaps (covers the start or end, but not both) of a new span.\n// Such overlap is not allowed.\nfunction conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\n  var line = getLine(doc, lineNo$$1);\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var i = 0; i < sps.length; ++i) {\n    var sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    var found = sp.marker.find(0);\n    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n      { return true }\n  } }\n}\n\n// A visual line is a line as drawn on the screen. Folding, for\n// example, can cause multiple logical lines to appear on the same\n// visual line. This finds the start of the visual line that the\n// given line is part of (usually that is the line itself).\nfunction visualLine(line) {\n  var merged;\n  while (merged = collapsedSpanAtStart(line))\n    { line = merged.find(-1, true).line; }\n  return line\n}\n\nfunction visualLineEnd(line) {\n  var merged;\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return line\n}\n\n// Returns an array of logical lines that continue the visual line\n// started by the argument, or undefined if there are no such lines.\nfunction visualLineContinued(line) {\n  var merged, lines;\n  while (merged = collapsedSpanAtEnd(line)) {\n    line = merged.find(1, true).line\n    ;(lines || (lines = [])).push(line);\n  }\n  return lines\n}\n\n// Get the line number of the start of the visual line that the\n// given line number is part of.\nfunction visualLineNo(doc, lineN) {\n  var line = getLine(doc, lineN), vis = visualLine(line);\n  if (line == vis) { return lineN }\n  return lineNo(vis)\n}\n\n// Get the line number of the start of the next visual line after\n// the given line.\nfunction visualLineEndNo(doc, lineN) {\n  if (lineN > doc.lastLine()) { return lineN }\n  var line = getLine(doc, lineN), merged;\n  if (!lineIsHidden(doc, line)) { return lineN }\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return lineNo(line) + 1\n}\n\n// Compute whether a line is hidden. Lines count as hidden when they\n// are part of a visual line that starts with another line, or when\n// they are entirely covered by collapsed, non-widget span.\nfunction lineIsHidden(doc, line) {\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    if (sp.from == null) { return true }\n    if (sp.marker.widgetNode) { continue }\n    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n      { return true }\n  } }\n}\nfunction lineIsHiddenInner(doc, line, span) {\n  if (span.to == null) {\n    var end = span.marker.find(1, true);\n    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n  }\n  if (span.marker.inclusiveRight && span.to == line.text.length)\n    { return true }\n  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n    sp = line.markedSpans[i];\n    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n        (sp.to == null || sp.to != span.from) &&\n        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n        lineIsHiddenInner(doc, line, sp)) { return true }\n  }\n}\n\n// Find the height above the given line.\nfunction heightAtLine(lineObj) {\n  lineObj = visualLine(lineObj);\n\n  var h = 0, chunk = lineObj.parent;\n  for (var i = 0; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i];\n    if (line == lineObj) { break }\n    else { h += line.height; }\n  }\n  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n      var cur = p.children[i$1];\n      if (cur == chunk) { break }\n      else { h += cur.height; }\n    }\n  }\n  return h\n}\n\n// Compute the character length of a line, taking into account\n// collapsed ranges (see markText) that might hide parts, and join\n// other lines onto it.\nfunction lineLength(line) {\n  if (line.height == 0) { return 0 }\n  var len = line.text.length, merged, cur = line;\n  while (merged = collapsedSpanAtStart(cur)) {\n    var found = merged.find(0, true);\n    cur = found.from.line;\n    len += found.from.ch - found.to.ch;\n  }\n  cur = line;\n  while (merged = collapsedSpanAtEnd(cur)) {\n    var found$1 = merged.find(0, true);\n    len -= cur.text.length - found$1.from.ch;\n    cur = found$1.to.line;\n    len += cur.text.length - found$1.to.ch;\n  }\n  return len\n}\n\n// Find the longest line in the document.\nfunction findMaxLine(cm) {\n  var d = cm.display, doc = cm.doc;\n  d.maxLine = getLine(doc, doc.first);\n  d.maxLineLength = lineLength(d.maxLine);\n  d.maxLineChanged = true;\n  doc.iter(function (line) {\n    var len = lineLength(line);\n    if (len > d.maxLineLength) {\n      d.maxLineLength = len;\n      d.maxLine = line;\n    }\n  });\n}\n\n// BIDI HELPERS\n\nfunction iterateBidiSections(order, from, to, f) {\n  if (!order) { return f(from, to, \"ltr\", 0) }\n  var found = false;\n  for (var i = 0; i < order.length; ++i) {\n    var part = order[i];\n    if (part.from < to && part.to > from || from == to && part.to == from) {\n      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n      found = true;\n    }\n  }\n  if (!found) { f(from, to, \"ltr\"); }\n}\n\nvar bidiOther = null;\nfunction getBidiPartAt(order, ch, sticky) {\n  var found;\n  bidiOther = null;\n  for (var i = 0; i < order.length; ++i) {\n    var cur = order[i];\n    if (cur.from < ch && cur.to > ch) { return i }\n    if (cur.to == ch) {\n      if (cur.from != cur.to && sticky == \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n    if (cur.from == ch) {\n      if (cur.from != cur.to && sticky != \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n  }\n  return found != null ? found : bidiOther\n}\n\n// Bidirectional ordering algorithm\n// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n// that this (partially) implements.\n\n// One-char codes used for character types:\n// L (L):   Left-to-Right\n// R (R):   Right-to-Left\n// r (AL):  Right-to-Left Arabic\n// 1 (EN):  European Number\n// + (ES):  European Number Separator\n// % (ET):  European Number Terminator\n// n (AN):  Arabic Number\n// , (CS):  Common Number Separator\n// m (NSM): Non-Spacing Mark\n// b (BN):  Boundary Neutral\n// s (B):   Paragraph Separator\n// t (S):   Segment Separator\n// w (WS):  Whitespace\n// N (ON):  Other Neutrals\n\n// Returns null if characters are ordered as they appear\n// (left-to-right), or an array of sections ({from, to, level}\n// objects) in the order in which they occur visually.\nvar bidiOrdering = (function() {\n  // Character types for codepoints 0 to 0xff\n  var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n  // Character types for codepoints 0x600 to 0x6f9\n  var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n  function charType(code) {\n    if (code <= 0xf7) { return lowTypes.charAt(code) }\n    else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n    else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n    else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n    else if (code == 0x200c) { return \"b\" }\n    else { return \"L\" }\n  }\n\n  var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n  function BidiSpan(level, from, to) {\n    this.level = level;\n    this.from = from; this.to = to;\n  }\n\n  return function(str, direction) {\n    var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n    if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n    var len = str.length, types = [];\n    for (var i = 0; i < len; ++i)\n      { types.push(charType(str.charCodeAt(i))); }\n\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\n    // change the type of the NSM to the type of the previous\n    // character. If the NSM is at the start of the level run, it will\n    // get the type of sor.\n    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n      var type = types[i$1];\n      if (type == \"m\") { types[i$1] = prev; }\n      else { prev = type; }\n    }\n\n    // W2. Search backwards from each instance of a European number\n    // until the first strong type (R, L, AL, or sor) is found. If an\n    // AL is found, change the type of the European number to Arabic\n    // number.\n    // W3. Change all ALs to R.\n    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n      var type$1 = types[i$2];\n      if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n    }\n\n    // W4. A single European separator between two European numbers\n    // changes to a European number. A single common separator between\n    // two numbers of the same type changes to that type.\n    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n      var type$2 = types[i$3];\n      if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n      else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n               (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n      prev$1 = type$2;\n    }\n\n    // W5. A sequence of European terminators adjacent to European\n    // numbers changes to all European numbers.\n    // W6. Otherwise, separators and terminators change to Other\n    // Neutral.\n    for (var i$4 = 0; i$4 < len; ++i$4) {\n      var type$3 = types[i$4];\n      if (type$3 == \",\") { types[i$4] = \"N\"; }\n      else if (type$3 == \"%\") {\n        var end = (void 0);\n        for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n        var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n        for (var j = i$4; j < end; ++j) { types[j] = replace; }\n        i$4 = end - 1;\n      }\n    }\n\n    // W7. Search backwards from each instance of a European number\n    // until the first strong type (R, L, or sor) is found. If an L is\n    // found, then change the type of the European number to L.\n    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n      var type$4 = types[i$5];\n      if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n      else if (isStrong.test(type$4)) { cur$1 = type$4; }\n    }\n\n    // N1. A sequence of neutrals takes the direction of the\n    // surrounding strong text if the text on both sides has the same\n    // direction. European and Arabic numbers act as if they were R in\n    // terms of their influence on neutrals. Start-of-level-run (sor)\n    // and end-of-level-run (eor) are used at level run boundaries.\n    // N2. Any remaining neutrals take the embedding direction.\n    for (var i$6 = 0; i$6 < len; ++i$6) {\n      if (isNeutral.test(types[i$6])) {\n        var end$1 = (void 0);\n        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n        var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n        var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n        var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n        i$6 = end$1 - 1;\n      }\n    }\n\n    // Here we depart from the documented algorithm, in order to avoid\n    // building up an actual levels array. Since there are only three\n    // levels (0, 1, 2) in an implementation that doesn't take\n    // explicit embedding into account, we can build up the order on\n    // the fly, without following the level-based algorithm.\n    var order = [], m;\n    for (var i$7 = 0; i$7 < len;) {\n      if (countsAsLeft.test(types[i$7])) {\n        var start = i$7;\n        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n        order.push(new BidiSpan(0, start, i$7));\n      } else {\n        var pos = i$7, at = order.length;\n        for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n        for (var j$2 = pos; j$2 < i$7;) {\n          if (countsAsNum.test(types[j$2])) {\n            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\n            var nstart = j$2;\n            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n            order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n            pos = j$2;\n          } else { ++j$2; }\n        }\n        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n      }\n    }\n    if (direction == \"ltr\") {\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift(new BidiSpan(0, 0, m[0].length));\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push(new BidiSpan(0, len - m[0].length, len));\n      }\n    }\n\n    return direction == \"rtl\" ? order.reverse() : order\n  }\n})();\n\n// Get the bidi ordering for the given line (and cache it). Returns\n// false for lines that are fully left-to-right, and an array of\n// BidiSpan objects otherwise.\nfunction getOrder(line, direction) {\n  var order = line.order;\n  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n  return order\n}\n\n// EVENT HANDLING\n\n// Lightweight event framework. on/off also work on DOM nodes,\n// registering native DOM handlers.\n\nvar noHandlers = [];\n\nvar on = function(emitter, type, f) {\n  if (emitter.addEventListener) {\n    emitter.addEventListener(type, f, false);\n  } else if (emitter.attachEvent) {\n    emitter.attachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers || (emitter._handlers = {});\n    map$$1[type] = (map$$1[type] || noHandlers).concat(f);\n  }\n};\n\nfunction getHandlers(emitter, type) {\n  return emitter._handlers && emitter._handlers[type] || noHandlers\n}\n\nfunction off(emitter, type, f) {\n  if (emitter.removeEventListener) {\n    emitter.removeEventListener(type, f, false);\n  } else if (emitter.detachEvent) {\n    emitter.detachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\n    if (arr) {\n      var index = indexOf(arr, f);\n      if (index > -1)\n        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n    }\n  }\n}\n\nfunction signal(emitter, type /*, values...*/) {\n  var handlers = getHandlers(emitter, type);\n  if (!handlers.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2);\n  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n}\n\n// The DOM events that CodeMirror handles can be overridden by\n// registering a (non-DOM) handler on the editor for the event name,\n// and preventDefault-ing the event in that handler.\nfunction signalDOMEvent(cm, e, override) {\n  if (typeof e == \"string\")\n    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n  signal(cm, override || e.type, cm, e);\n  return e_defaultPrevented(e) || e.codemirrorIgnore\n}\n\nfunction signalCursorActivity(cm) {\n  var arr = cm._handlers && cm._handlers.cursorActivity;\n  if (!arr) { return }\n  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n    { set.push(arr[i]); } }\n}\n\nfunction hasHandler(emitter, type) {\n  return getHandlers(emitter, type).length > 0\n}\n\n// Add on and off methods to a constructor's prototype, to make\n// registering events on such objects more convenient.\nfunction eventMixin(ctor) {\n  ctor.prototype.on = function(type, f) {on(this, type, f);};\n  ctor.prototype.off = function(type, f) {off(this, type, f);};\n}\n\n// Due to the fact that we still support jurassic IE versions, some\n// compatibility wrappers are needed.\n\nfunction e_preventDefault(e) {\n  if (e.preventDefault) { e.preventDefault(); }\n  else { e.returnValue = false; }\n}\nfunction e_stopPropagation(e) {\n  if (e.stopPropagation) { e.stopPropagation(); }\n  else { e.cancelBubble = true; }\n}\nfunction e_defaultPrevented(e) {\n  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n}\nfunction e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\nfunction e_target(e) {return e.target || e.srcElement}\nfunction e_button(e) {\n  var b = e.which;\n  if (b == null) {\n    if (e.button & 1) { b = 1; }\n    else if (e.button & 2) { b = 3; }\n    else if (e.button & 4) { b = 2; }\n  }\n  if (mac && e.ctrlKey && b == 1) { b = 3; }\n  return b\n}\n\n// Detect drag-and-drop\nvar dragAndDrop = function() {\n  // There is *some* kind of drag-and-drop support in IE6-8, but I\n  // couldn't get it to work yet.\n  if (ie && ie_version < 9) { return false }\n  var div = elt('div');\n  return \"draggable\" in div || \"dragDrop\" in div\n}();\n\nvar zwspSupported;\nfunction zeroWidthElement(measure) {\n  if (zwspSupported == null) {\n    var test = elt(\"span\", \"\\u200b\");\n    removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n    if (measure.firstChild.offsetHeight != 0)\n      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n  }\n  var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n    elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n  node.setAttribute(\"cm-text\", \"\");\n  return node\n}\n\n// Feature-detect IE's crummy client rect reporting for bidi text\nvar badBidiRects;\nfunction hasBadBidiRects(measure) {\n  if (badBidiRects != null) { return badBidiRects }\n  var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n  var r0 = range(txt, 0, 1).getBoundingClientRect();\n  var r1 = range(txt, 1, 2).getBoundingClientRect();\n  removeChildren(measure);\n  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n  return badBidiRects = (r1.right - r0.right < 3)\n}\n\n// See if \"\".split is the broken IE version, if so, provide an\n// alternative way to split lines.\nvar splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n  var pos = 0, result = [], l = string.length;\n  while (pos <= l) {\n    var nl = string.indexOf(\"\\n\", pos);\n    if (nl == -1) { nl = string.length; }\n    var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n    var rt = line.indexOf(\"\\r\");\n    if (rt != -1) {\n      result.push(line.slice(0, rt));\n      pos += rt + 1;\n    } else {\n      result.push(line);\n      pos = nl + 1;\n    }\n  }\n  return result\n} : function (string) { return string.split(/\\r\\n?|\\n/); };\n\nvar hasSelection = window.getSelection ? function (te) {\n  try { return te.selectionStart != te.selectionEnd }\n  catch(e) { return false }\n} : function (te) {\n  var range$$1;\n  try {range$$1 = te.ownerDocument.selection.createRange();}\n  catch(e) {}\n  if (!range$$1 || range$$1.parentElement() != te) { return false }\n  return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\n};\n\nvar hasCopyEvent = (function () {\n  var e = elt(\"div\");\n  if (\"oncopy\" in e) { return true }\n  e.setAttribute(\"oncopy\", \"return;\");\n  return typeof e.oncopy == \"function\"\n})();\n\nvar badZoomedRects = null;\nfunction hasBadZoomedRects(measure) {\n  if (badZoomedRects != null) { return badZoomedRects }\n  var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n  var normal = node.getBoundingClientRect();\n  var fromRange = range(node, 0, 1).getBoundingClientRect();\n  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n}\n\n// Known modes, by name and by MIME\nvar modes = {};\nvar mimeModes = {};\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nfunction defineMode(name, mode) {\n  if (arguments.length > 2)\n    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n  modes[name] = mode;\n}\n\nfunction defineMIME(mime, spec) {\n  mimeModes[mime] = spec;\n}\n\n// Given a MIME type, a {name, ...options} config object, or a name\n// string, return a mode config object.\nfunction resolveMode(spec) {\n  if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n    spec = mimeModes[spec];\n  } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n    var found = mimeModes[spec.name];\n    if (typeof found == \"string\") { found = {name: found}; }\n    spec = createObj(found, spec);\n    spec.name = found.name;\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n    return resolveMode(\"application/xml\")\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n    return resolveMode(\"application/json\")\n  }\n  if (typeof spec == \"string\") { return {name: spec} }\n  else { return spec || {name: \"null\"} }\n}\n\n// Given a mode spec (anything that resolveMode accepts), find and\n// initialize an actual mode object.\nfunction getMode(options, spec) {\n  spec = resolveMode(spec);\n  var mfactory = modes[spec.name];\n  if (!mfactory) { return getMode(options, \"text/plain\") }\n  var modeObj = mfactory(options, spec);\n  if (modeExtensions.hasOwnProperty(spec.name)) {\n    var exts = modeExtensions[spec.name];\n    for (var prop in exts) {\n      if (!exts.hasOwnProperty(prop)) { continue }\n      if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n      modeObj[prop] = exts[prop];\n    }\n  }\n  modeObj.name = spec.name;\n  if (spec.helperType) { modeObj.helperType = spec.helperType; }\n  if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n    { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n  return modeObj\n}\n\n// This can be used to attach properties to mode objects from\n// outside the actual mode definition.\nvar modeExtensions = {};\nfunction extendMode(mode, properties) {\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n  copyObj(properties, exts);\n}\n\nfunction copyState(mode, state) {\n  if (state === true) { return state }\n  if (mode.copyState) { return mode.copyState(state) }\n  var nstate = {};\n  for (var n in state) {\n    var val = state[n];\n    if (val instanceof Array) { val = val.concat([]); }\n    nstate[n] = val;\n  }\n  return nstate\n}\n\n// Given a mode and a state (for that mode), find the inner mode and\n// state at the position that the state refers to.\nfunction innerMode(mode, state) {\n  var info;\n  while (mode.innerMode) {\n    info = mode.innerMode(state);\n    if (!info || info.mode == mode) { break }\n    state = info.state;\n    mode = info.mode;\n  }\n  return info || {mode: mode, state: state}\n}\n\nfunction startState(mode, a1, a2) {\n  return mode.startState ? mode.startState(a1, a2) : true\n}\n\n// STRING STREAM\n\n// Fed to the mode parsers, provides helper functions to make\n// parsers more succinct.\n\nvar StringStream = function(string, tabSize, lineOracle) {\n  this.pos = this.start = 0;\n  this.string = string;\n  this.tabSize = tabSize || 8;\n  this.lastColumnPos = this.lastColumnValue = 0;\n  this.lineStart = 0;\n  this.lineOracle = lineOracle;\n};\n\nStringStream.prototype.eol = function () {return this.pos >= this.string.length};\nStringStream.prototype.sol = function () {return this.pos == this.lineStart};\nStringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\nStringStream.prototype.next = function () {\n  if (this.pos < this.string.length)\n    { return this.string.charAt(this.pos++) }\n};\nStringStream.prototype.eat = function (match) {\n  var ch = this.string.charAt(this.pos);\n  var ok;\n  if (typeof match == \"string\") { ok = ch == match; }\n  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n  if (ok) {++this.pos; return ch}\n};\nStringStream.prototype.eatWhile = function (match) {\n  var start = this.pos;\n  while (this.eat(match)){}\n  return this.pos > start\n};\nStringStream.prototype.eatSpace = function () {\n    var this$1 = this;\n\n  var start = this.pos;\n  while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\n  return this.pos > start\n};\nStringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\nStringStream.prototype.skipTo = function (ch) {\n  var found = this.string.indexOf(ch, this.pos);\n  if (found > -1) {this.pos = found; return true}\n};\nStringStream.prototype.backUp = function (n) {this.pos -= n;};\nStringStream.prototype.column = function () {\n  if (this.lastColumnPos < this.start) {\n    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n    this.lastColumnPos = this.start;\n  }\n  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.indentation = function () {\n  return countColumn(this.string, null, this.tabSize) -\n    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n  if (typeof pattern == \"string\") {\n    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n    var substr = this.string.substr(this.pos, pattern.length);\n    if (cased(substr) == cased(pattern)) {\n      if (consume !== false) { this.pos += pattern.length; }\n      return true\n    }\n  } else {\n    var match = this.string.slice(this.pos).match(pattern);\n    if (match && match.index > 0) { return null }\n    if (match && consume !== false) { this.pos += match[0].length; }\n    return match\n  }\n};\nStringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\nStringStream.prototype.hideFirstChars = function (n, inner) {\n  this.lineStart += n;\n  try { return inner() }\n  finally { this.lineStart -= n; }\n};\nStringStream.prototype.lookAhead = function (n) {\n  var oracle = this.lineOracle;\n  return oracle && oracle.lookAhead(n)\n};\nStringStream.prototype.baseToken = function () {\n  var oracle = this.lineOracle;\n  return oracle && oracle.baseToken(this.pos)\n};\n\nvar SavedContext = function(state, lookAhead) {\n  this.state = state;\n  this.lookAhead = lookAhead;\n};\n\nvar Context = function(doc, state, line, lookAhead) {\n  this.state = state;\n  this.doc = doc;\n  this.line = line;\n  this.maxLookAhead = lookAhead || 0;\n  this.baseTokens = null;\n  this.baseTokenPos = 1;\n};\n\nContext.prototype.lookAhead = function (n) {\n  var line = this.doc.getLine(this.line + n);\n  if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n  return line\n};\n\nContext.prototype.baseToken = function (n) {\n    var this$1 = this;\n\n  if (!this.baseTokens) { return null }\n  while (this.baseTokens[this.baseTokenPos] <= n)\n    { this$1.baseTokenPos += 2; }\n  var type = this.baseTokens[this.baseTokenPos + 1];\n  return {type: type && type.replace(/( |^)overlay .*/, \"\"),\n          size: this.baseTokens[this.baseTokenPos] - n}\n};\n\nContext.prototype.nextLine = function () {\n  this.line++;\n  if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n};\n\nContext.fromSaved = function (doc, saved, line) {\n  if (saved instanceof SavedContext)\n    { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n  else\n    { return new Context(doc, copyState(doc.mode, saved), line) }\n};\n\nContext.prototype.save = function (copy) {\n  var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n  return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n};\n\n\n// Compute a style array (an array starting with a mode generation\n// -- for invalidation -- followed by pairs of end positions and\n// style strings), which is used to highlight the tokens on the\n// line.\nfunction highlightLine(cm, line, context, forceToEnd) {\n  // A styles array always starts with a number identifying the\n  // mode/overlays that it is based on (for easy invalidation).\n  var st = [cm.state.modeGen], lineClasses = {};\n  // Compute the base array of styles\n  runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n          lineClasses, forceToEnd);\n  var state = context.state;\n\n  // Run overlays, adjust style array.\n  var loop = function ( o ) {\n    context.baseTokens = st;\n    var overlay = cm.state.overlays[o], i = 1, at = 0;\n    context.state = true;\n    runMode(cm, line.text, overlay.mode, context, function (end, style) {\n      var start = i;\n      // Ensure there's a token end at the current position, and that i points at it\n      while (at < end) {\n        var i_end = st[i];\n        if (i_end > end)\n          { st.splice(i, 1, end, st[i+1], i_end); }\n        i += 2;\n        at = Math.min(end, i_end);\n      }\n      if (!style) { return }\n      if (overlay.opaque) {\n        st.splice(start, i - start, end, \"overlay \" + style);\n        i = start + 2;\n      } else {\n        for (; start < i; start += 2) {\n          var cur = st[start+1];\n          st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n        }\n      }\n    }, lineClasses);\n    context.state = state;\n    context.baseTokens = null;\n    context.baseTokenPos = 1;\n  };\n\n  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n}\n\nfunction getLineStyles(cm, line, updateFrontier) {\n  if (!line.styles || line.styles[0] != cm.state.modeGen) {\n    var context = getContextBefore(cm, lineNo(line));\n    var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n    var result = highlightLine(cm, line, context);\n    if (resetState) { context.state = resetState; }\n    line.stateAfter = context.save(!resetState);\n    line.styles = result.styles;\n    if (result.classes) { line.styleClasses = result.classes; }\n    else if (line.styleClasses) { line.styleClasses = null; }\n    if (updateFrontier === cm.doc.highlightFrontier)\n      { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n  }\n  return line.styles\n}\n\nfunction getContextBefore(cm, n, precise) {\n  var doc = cm.doc, display = cm.display;\n  if (!doc.mode.startState) { return new Context(doc, true, n) }\n  var start = findStartLine(cm, n, precise);\n  var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n  var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n  doc.iter(start, n, function (line) {\n    processLine(cm, line.text, context);\n    var pos = context.line;\n    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n    context.nextLine();\n  });\n  if (precise) { doc.modeFrontier = context.line; }\n  return context\n}\n\n// Lightweight form of highlight -- proceed over this line and\n// update state, but don't save a style array. Used for lines that\n// aren't currently visible.\nfunction processLine(cm, text, context, startAt) {\n  var mode = cm.doc.mode;\n  var stream = new StringStream(text, cm.options.tabSize, context);\n  stream.start = stream.pos = startAt || 0;\n  if (text == \"\") { callBlankLine(mode, context.state); }\n  while (!stream.eol()) {\n    readToken(mode, stream, context.state);\n    stream.start = stream.pos;\n  }\n}\n\nfunction callBlankLine(mode, state) {\n  if (mode.blankLine) { return mode.blankLine(state) }\n  if (!mode.innerMode) { return }\n  var inner = innerMode(mode, state);\n  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n}\n\nfunction readToken(mode, stream, state, inner) {\n  for (var i = 0; i < 10; i++) {\n    if (inner) { inner[0] = innerMode(mode, state).mode; }\n    var style = mode.token(stream, state);\n    if (stream.pos > stream.start) { return style }\n  }\n  throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n}\n\nvar Token = function(stream, type, state) {\n  this.start = stream.start; this.end = stream.pos;\n  this.string = stream.current();\n  this.type = type || null;\n  this.state = state;\n};\n\n// Utility for getTokenAt and getLineTokens\nfunction takeToken(cm, pos, precise, asArray) {\n  var doc = cm.doc, mode = doc.mode, style;\n  pos = clipPos(doc, pos);\n  var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n  var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n  if (asArray) { tokens = []; }\n  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n    stream.start = stream.pos;\n    style = readToken(mode, stream, context.state);\n    if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n  }\n  return asArray ? tokens : new Token(stream, style, context.state)\n}\n\nfunction extractLineClasses(type, output) {\n  if (type) { for (;;) {\n    var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n    if (!lineClass) { break }\n    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n    var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n    if (output[prop] == null)\n      { output[prop] = lineClass[2]; }\n    else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n      { output[prop] += \" \" + lineClass[2]; }\n  } }\n  return type\n}\n\n// Run the given mode's parser over a line, calling f for each token.\nfunction runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n  var flattenSpans = mode.flattenSpans;\n  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n  var curStart = 0, curStyle = null;\n  var stream = new StringStream(text, cm.options.tabSize, context), style;\n  var inner = cm.options.addModeClass && [null];\n  if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n  while (!stream.eol()) {\n    if (stream.pos > cm.options.maxHighlightLength) {\n      flattenSpans = false;\n      if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n      stream.pos = text.length;\n      style = null;\n    } else {\n      style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n    }\n    if (inner) {\n      var mName = inner[0].name;\n      if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n    }\n    if (!flattenSpans || curStyle != style) {\n      while (curStart < stream.start) {\n        curStart = Math.min(stream.start, curStart + 5000);\n        f(curStart, curStyle);\n      }\n      curStyle = style;\n    }\n    stream.start = stream.pos;\n  }\n  while (curStart < stream.pos) {\n    // Webkit seems to refuse to render text nodes longer than 57444\n    // characters, and returns inaccurate measurements in nodes\n    // starting around 5000 chars.\n    var pos = Math.min(stream.pos, curStart + 5000);\n    f(pos, curStyle);\n    curStart = pos;\n  }\n}\n\n// Finds the line to start with when starting a parse. Tries to\n// find a line with a stateAfter, so that it can start with a\n// valid state. If that fails, it returns the line with the\n// smallest indentation, which tends to need the least context to\n// parse correctly.\nfunction findStartLine(cm, n, precise) {\n  var minindent, minline, doc = cm.doc;\n  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n  for (var search = n; search > lim; --search) {\n    if (search <= doc.first) { return doc.first }\n    var line = getLine(doc, search - 1), after = line.stateAfter;\n    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n      { return search }\n    var indented = countColumn(line.text, null, cm.options.tabSize);\n    if (minline == null || minindent > indented) {\n      minline = search - 1;\n      minindent = indented;\n    }\n  }\n  return minline\n}\n\nfunction retreatFrontier(doc, n) {\n  doc.modeFrontier = Math.min(doc.modeFrontier, n);\n  if (doc.highlightFrontier < n - 10) { return }\n  var start = doc.first;\n  for (var line = n - 1; line > start; line--) {\n    var saved = getLine(doc, line).stateAfter;\n    // change is on 3\n    // state on line 1 looked ahead 2 -- so saw 3\n    // test 1 + 2 < 3 should cover this\n    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n      start = line + 1;\n      break\n    }\n  }\n  doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n}\n\n// LINE DATA STRUCTURE\n\n// Line objects. These hold state related to a line, including\n// highlighting info (the styles array).\nvar Line = function(text, markedSpans, estimateHeight) {\n  this.text = text;\n  attachMarkedSpans(this, markedSpans);\n  this.height = estimateHeight ? estimateHeight(this) : 1;\n};\n\nLine.prototype.lineNo = function () { return lineNo(this) };\neventMixin(Line);\n\n// Change the content (text, markers) of a line. Automatically\n// invalidates cached information and tries to re-estimate the\n// line's height.\nfunction updateLine(line, text, markedSpans, estimateHeight) {\n  line.text = text;\n  if (line.stateAfter) { line.stateAfter = null; }\n  if (line.styles) { line.styles = null; }\n  if (line.order != null) { line.order = null; }\n  detachMarkedSpans(line);\n  attachMarkedSpans(line, markedSpans);\n  var estHeight = estimateHeight ? estimateHeight(line) : 1;\n  if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n}\n\n// Detach a line from the document tree and its markers.\nfunction cleanUpLine(line) {\n  line.parent = null;\n  detachMarkedSpans(line);\n}\n\n// Convert a style as returned by a mode (either null, or a string\n// containing one or more styles) to a CSS style. This is cached,\n// and also looks for line-wide styles.\nvar styleToClassCache = {};\nvar styleToClassCacheWithMode = {};\nfunction interpretTokenStyle(style, options) {\n  if (!style || /^\\s*$/.test(style)) { return null }\n  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n  return cache[style] ||\n    (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n}\n\n// Render the DOM representation of the text of a line. Also builds\n// up a 'line map', which points at the DOM nodes that represent\n// specific stretches of text, and is used by the measuring code.\n// The returned object contains the DOM node, this map, and\n// information about line-wide styles that were set by the mode.\nfunction buildLineContent(cm, lineView) {\n  // The padding-right forces the element to have a 'border', which\n  // is needed on Webkit to be able to get line-level bounding\n  // rectangles for it (in measureChar).\n  var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n  var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                 col: 0, pos: 0, cm: cm,\n                 trailingSpace: false,\n                 splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n  lineView.measure = {};\n\n  // Iterate over the logical lines that make up this visual line.\n  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n    builder.pos = 0;\n    builder.addToken = buildToken;\n    // Optionally wire in some hacks into the token-rendering\n    // algorithm, to deal with browser quirks.\n    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n    builder.map = [];\n    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n    if (line.styleClasses) {\n      if (line.styleClasses.bgClass)\n        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n      if (line.styleClasses.textClass)\n        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n    }\n\n    // Ensure at least a single node is present, for measuring.\n    if (builder.map.length == 0)\n      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n    // Store the map and a cache object for the current logical line\n    if (i == 0) {\n      lineView.measure.map = builder.map;\n      lineView.measure.cache = {};\n    } else {\n      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n    }\n  }\n\n  // See issue #2901\n  if (webkit) {\n    var last = builder.content.lastChild;\n    if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n      { builder.content.className = \"cm-tab-wrap-hack\"; }\n  }\n\n  signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n  if (builder.pre.className)\n    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n  return builder\n}\n\nfunction defaultSpecialCharPlaceholder(ch) {\n  var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n  token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n  token.setAttribute(\"aria-label\", token.title);\n  return token\n}\n\n// Build up the DOM representation for a single token, and add it to\n// the line map. Takes care to render special characters separately.\nfunction buildToken(builder, text, style, startStyle, endStyle, title, css) {\n  if (!text) { return }\n  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n  var special = builder.cm.state.specialChars, mustWrap = false;\n  var content;\n  if (!special.test(text)) {\n    builder.col += text.length;\n    content = document.createTextNode(displayText);\n    builder.map.push(builder.pos, builder.pos + text.length, content);\n    if (ie && ie_version < 9) { mustWrap = true; }\n    builder.pos += text.length;\n  } else {\n    content = document.createDocumentFragment();\n    var pos = 0;\n    while (true) {\n      special.lastIndex = pos;\n      var m = special.exec(text);\n      var skipped = m ? m.index - pos : text.length - pos;\n      if (skipped) {\n        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n        else { content.appendChild(txt); }\n        builder.map.push(builder.pos, builder.pos + skipped, txt);\n        builder.col += skipped;\n        builder.pos += skipped;\n      }\n      if (!m) { break }\n      pos += skipped + 1;\n      var txt$1 = (void 0);\n      if (m[0] == \"\\t\") {\n        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n        txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n        txt$1.setAttribute(\"role\", \"presentation\");\n        txt$1.setAttribute(\"cm-text\", \"\\t\");\n        builder.col += tabWidth;\n      } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n        txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        builder.col += 1;\n      } else {\n        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n        else { content.appendChild(txt$1); }\n        builder.col += 1;\n      }\n      builder.map.push(builder.pos, builder.pos + 1, txt$1);\n      builder.pos++;\n    }\n  }\n  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n  if (style || startStyle || endStyle || mustWrap || css) {\n    var fullStyle = style || \"\";\n    if (startStyle) { fullStyle += startStyle; }\n    if (endStyle) { fullStyle += endStyle; }\n    var token = elt(\"span\", [content], fullStyle, css);\n    if (title) { token.title = title; }\n    return builder.content.appendChild(token)\n  }\n  builder.content.appendChild(content);\n}\n\nfunction splitSpaces(text, trailingBefore) {\n  if (text.length > 1 && !/  /.test(text)) { return text }\n  var spaceBefore = trailingBefore, result = \"\";\n  for (var i = 0; i < text.length; i++) {\n    var ch = text.charAt(i);\n    if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n      { ch = \"\\u00a0\"; }\n    result += ch;\n    spaceBefore = ch == \" \";\n  }\n  return result\n}\n\n// Work around nonsense dimensions being reported for stretches of\n// right-to-left text.\nfunction buildTokenBadBidi(inner, order) {\n  return function (builder, text, style, startStyle, endStyle, title, css) {\n    style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n    var start = builder.pos, end = start + text.length;\n    for (;;) {\n      // Find the part that overlaps with the start of this text\n      var part = (void 0);\n      for (var i = 0; i < order.length; i++) {\n        part = order[i];\n        if (part.to > start && part.from <= start) { break }\n      }\n      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }\n      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n      startStyle = null;\n      text = text.slice(part.to - start);\n      start = part.to;\n    }\n  }\n}\n\nfunction buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n  var widget = !ignoreWidget && marker.widgetNode;\n  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n    if (!widget)\n      { widget = builder.content.appendChild(document.createElement(\"span\")); }\n    widget.setAttribute(\"cm-marker\", marker.id);\n  }\n  if (widget) {\n    builder.cm.display.input.setUneditable(widget);\n    builder.content.appendChild(widget);\n  }\n  builder.pos += size;\n  builder.trailingSpace = false;\n}\n\n// Outputs a number of spans to make up a line, taking highlighting\n// and marked text into account.\nfunction insertLineContent(line, builder, styles) {\n  var spans = line.markedSpans, allText = line.text, at = 0;\n  if (!spans) {\n    for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n    return\n  }\n\n  var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n  for (;;) {\n    if (nextChange == pos) { // Update current marker set\n      spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n      collapsed = null; nextChange = Infinity;\n      var foundBookmarks = [], endStyles = (void 0);\n      for (var j = 0; j < spans.length; ++j) {\n        var sp = spans[j], m = sp.marker;\n        if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n          foundBookmarks.push(m);\n        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n          if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n            nextChange = sp.to;\n            spanEndStyle = \"\";\n          }\n          if (m.className) { spanStyle += \" \" + m.className; }\n          if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n          if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n          if (m.title && !title) { title = m.title; }\n          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n            { collapsed = sp; }\n        } else if (sp.from > pos && nextChange > sp.from) {\n          nextChange = sp.from;\n        }\n      }\n      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n      if (collapsed && (collapsed.from || 0) == pos) {\n        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                           collapsed.marker, collapsed.from == null);\n        if (collapsed.to == null) { return }\n        if (collapsed.to == pos) { collapsed = false; }\n      }\n    }\n    if (pos >= len) { break }\n\n    var upto = Math.min(len, nextChange);\n    while (true) {\n      if (text) {\n        var end = pos + text.length;\n        if (!collapsed) {\n          var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n        }\n        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n        pos = end;\n        spanStartStyle = \"\";\n      }\n      text = allText.slice(at, at = styles[i++]);\n      style = interpretTokenStyle(styles[i++], builder.cm.options);\n    }\n  }\n}\n\n\n// These objects are used to represent the visible (currently drawn)\n// part of the document. A LineView may correspond to multiple\n// logical lines, if those are connected by collapsed ranges.\nfunction LineView(doc, line, lineN) {\n  // The starting line\n  this.line = line;\n  // Continuing lines, if any\n  this.rest = visualLineContinued(line);\n  // Number of logical lines in this visual line\n  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n  this.node = this.text = null;\n  this.hidden = lineIsHidden(doc, line);\n}\n\n// Create a range of LineView objects for the given lines.\nfunction buildViewArray(cm, from, to) {\n  var array = [], nextPos;\n  for (var pos = from; pos < to; pos = nextPos) {\n    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n    nextPos = pos + view.size;\n    array.push(view);\n  }\n  return array\n}\n\nvar operationGroup = null;\n\nfunction pushOperation(op) {\n  if (operationGroup) {\n    operationGroup.ops.push(op);\n  } else {\n    op.ownsGroup = operationGroup = {\n      ops: [op],\n      delayedCallbacks: []\n    };\n  }\n}\n\nfunction fireCallbacksForOps(group) {\n  // Calls delayed callbacks and cursorActivity handlers until no\n  // new ones appear\n  var callbacks = group.delayedCallbacks, i = 0;\n  do {\n    for (; i < callbacks.length; i++)\n      { callbacks[i].call(null); }\n    for (var j = 0; j < group.ops.length; j++) {\n      var op = group.ops[j];\n      if (op.cursorActivityHandlers)\n        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n    }\n  } while (i < callbacks.length)\n}\n\nfunction finishOperation(op, endCb) {\n  var group = op.ownsGroup;\n  if (!group) { return }\n\n  try { fireCallbacksForOps(group); }\n  finally {\n    operationGroup = null;\n    endCb(group);\n  }\n}\n\nvar orphanDelayedCallbacks = null;\n\n// Often, we want to signal events at a point where we are in the\n// middle of some work, but don't want the handler to start calling\n// other methods on the editor, which might be in an inconsistent\n// state or simply not expect any other events to happen.\n// signalLater looks whether there are any handlers, and schedules\n// them to be executed when the last operation ends, or, if no\n// operation is active, when a timeout fires.\nfunction signalLater(emitter, type /*, values...*/) {\n  var arr = getHandlers(emitter, type);\n  if (!arr.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2), list;\n  if (operationGroup) {\n    list = operationGroup.delayedCallbacks;\n  } else if (orphanDelayedCallbacks) {\n    list = orphanDelayedCallbacks;\n  } else {\n    list = orphanDelayedCallbacks = [];\n    setTimeout(fireOrphanDelayed, 0);\n  }\n  var loop = function ( i ) {\n    list.push(function () { return arr[i].apply(null, args); });\n  };\n\n  for (var i = 0; i < arr.length; ++i)\n    loop( i );\n}\n\nfunction fireOrphanDelayed() {\n  var delayed = orphanDelayedCallbacks;\n  orphanDelayedCallbacks = null;\n  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n}\n\n// When an aspect of a line changes, a string is added to\n// lineView.changes. This updates the relevant part of the line's\n// DOM structure.\nfunction updateLineForChanges(cm, lineView, lineN, dims) {\n  for (var j = 0; j < lineView.changes.length; j++) {\n    var type = lineView.changes[j];\n    if (type == \"text\") { updateLineText(cm, lineView); }\n    else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n    else if (type == \"class\") { updateLineClasses(cm, lineView); }\n    else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n  }\n  lineView.changes = null;\n}\n\n// Lines with gutter elements, widgets or a background class need to\n// be wrapped, and have the extra elements added to the wrapper div\nfunction ensureLineWrapped(lineView) {\n  if (lineView.node == lineView.text) {\n    lineView.node = elt(\"div\", null, null, \"position: relative\");\n    if (lineView.text.parentNode)\n      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n    lineView.node.appendChild(lineView.text);\n    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n  }\n  return lineView.node\n}\n\nfunction updateLineBackground(cm, lineView) {\n  var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n  if (cls) { cls += \" CodeMirror-linebackground\"; }\n  if (lineView.background) {\n    if (cls) { lineView.background.className = cls; }\n    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n  } else if (cls) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    cm.display.input.setUneditable(lineView.background);\n  }\n}\n\n// Wrapper around buildLineContent which will reuse the structure\n// in display.externalMeasured when possible.\nfunction getLineContent(cm, lineView) {\n  var ext = cm.display.externalMeasured;\n  if (ext && ext.line == lineView.line) {\n    cm.display.externalMeasured = null;\n    lineView.measure = ext.measure;\n    return ext.built\n  }\n  return buildLineContent(cm, lineView)\n}\n\n// Redraw the line's text. Interacts with the background and text\n// classes because the mode may output tokens that influence these\n// classes.\nfunction updateLineText(cm, lineView) {\n  var cls = lineView.text.className;\n  var built = getLineContent(cm, lineView);\n  if (lineView.text == lineView.node) { lineView.node = built.pre; }\n  lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n  lineView.text = built.pre;\n  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n    lineView.bgClass = built.bgClass;\n    lineView.textClass = built.textClass;\n    updateLineClasses(cm, lineView);\n  } else if (cls) {\n    lineView.text.className = cls;\n  }\n}\n\nfunction updateLineClasses(cm, lineView) {\n  updateLineBackground(cm, lineView);\n  if (lineView.line.wrapClass)\n    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n  else if (lineView.node != lineView.text)\n    { lineView.node.className = \"\"; }\n  var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n  lineView.text.className = textClass || \"\";\n}\n\nfunction updateLineGutter(cm, lineView, lineN, dims) {\n  if (lineView.gutter) {\n    lineView.node.removeChild(lineView.gutter);\n    lineView.gutter = null;\n  }\n  if (lineView.gutterBackground) {\n    lineView.node.removeChild(lineView.gutterBackground);\n    lineView.gutterBackground = null;\n  }\n  if (lineView.line.gutterClass) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                    (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(lineView.gutterBackground);\n    wrap.insertBefore(lineView.gutterBackground, lineView.text);\n  }\n  var markers = lineView.line.gutterMarkers;\n  if (cm.options.lineNumbers || markers) {\n    var wrap$1 = ensureLineWrapped(lineView);\n    var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(gutterWrap);\n    wrap$1.insertBefore(gutterWrap, lineView.text);\n    if (lineView.line.gutterClass)\n      { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n    if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n      { lineView.lineNumber = gutterWrap.appendChild(\n        elt(\"div\", lineNumberFor(cm.options, lineN),\n            \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n            (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\n      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n      if (found)\n        { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                   (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n    } }\n  }\n}\n\nfunction updateLineWidgets(cm, lineView, dims) {\n  if (lineView.alignable) { lineView.alignable = null; }\n  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n    next = node.nextSibling;\n    if (node.className == \"CodeMirror-linewidget\")\n      { lineView.node.removeChild(node); }\n  }\n  insertLineWidgets(cm, lineView, dims);\n}\n\n// Build a line's DOM representation from scratch\nfunction buildLineElement(cm, lineView, lineN, dims) {\n  var built = getLineContent(cm, lineView);\n  lineView.text = lineView.node = built.pre;\n  if (built.bgClass) { lineView.bgClass = built.bgClass; }\n  if (built.textClass) { lineView.textClass = built.textClass; }\n\n  updateLineClasses(cm, lineView);\n  updateLineGutter(cm, lineView, lineN, dims);\n  insertLineWidgets(cm, lineView, dims);\n  return lineView.node\n}\n\n// A lineView may contain multiple logical lines (when merged by\n// collapsed spans). The widgets for all of them need to be drawn.\nfunction insertLineWidgets(cm, lineView, dims) {\n  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n}\n\nfunction insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n  if (!line.widgets) { return }\n  var wrap = ensureLineWrapped(lineView);\n  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n    var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n    if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n    positionLineWidget(widget, node, lineView, dims);\n    cm.display.input.setUneditable(node);\n    if (allowAbove && widget.above)\n      { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n    else\n      { wrap.appendChild(node); }\n    signalLater(widget, \"redraw\");\n  }\n}\n\nfunction positionLineWidget(widget, node, lineView, dims) {\n  if (widget.noHScroll) {\n    (lineView.alignable || (lineView.alignable = [])).push(node);\n    var width = dims.wrapperWidth;\n    node.style.left = dims.fixedPos + \"px\";\n    if (!widget.coverGutter) {\n      width -= dims.gutterTotalWidth;\n      node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n    }\n    node.style.width = width + \"px\";\n  }\n  if (widget.coverGutter) {\n    node.style.zIndex = 5;\n    node.style.position = \"relative\";\n    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n  }\n}\n\nfunction widgetHeight(widget) {\n  if (widget.height != null) { return widget.height }\n  var cm = widget.doc.cm;\n  if (!cm) { return 0 }\n  if (!contains(document.body, widget.node)) {\n    var parentStyle = \"position: relative;\";\n    if (widget.coverGutter)\n      { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n    if (widget.noHScroll)\n      { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n    removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n  }\n  return widget.height = widget.node.parentNode.offsetHeight\n}\n\n// Return true when the given mouse event happened in a widget\nfunction eventInWidget(display, e) {\n  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n    if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n        (n.parentNode == display.sizer && n != display.mover))\n      { return true }\n  }\n}\n\n// POSITION MEASUREMENT\n\nfunction paddingTop(display) {return display.lineSpace.offsetTop}\nfunction paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\nfunction paddingH(display) {\n  if (display.cachedPaddingH) { return display.cachedPaddingH }\n  var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n  return data\n}\n\nfunction scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\nfunction displayWidth(cm) {\n  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n}\nfunction displayHeight(cm) {\n  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n}\n\n// Ensure the lineView.wrapping.heights array is populated. This is\n// an array of bottom offsets for the lines that make up a drawn\n// line. When lineWrapping is on, there might be more than one\n// height.\nfunction ensureLineHeights(cm, lineView, rect) {\n  var wrapping = cm.options.lineWrapping;\n  var curWidth = wrapping && displayWidth(cm);\n  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n    var heights = lineView.measure.heights = [];\n    if (wrapping) {\n      lineView.measure.width = curWidth;\n      var rects = lineView.text.firstChild.getClientRects();\n      for (var i = 0; i < rects.length - 1; i++) {\n        var cur = rects[i], next = rects[i + 1];\n        if (Math.abs(cur.bottom - next.bottom) > 2)\n          { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n      }\n    }\n    heights.push(rect.bottom - rect.top);\n  }\n}\n\n// Find a line map (mapping character offsets to text nodes) and a\n// measurement cache for the given line number. (A line view might\n// contain multiple lines when collapsed ranges are present.)\nfunction mapFromLineView(lineView, line, lineN) {\n  if (lineView.line == line)\n    { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n  for (var i = 0; i < lineView.rest.length; i++)\n    { if (lineView.rest[i] == line)\n      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n    { if (lineNo(lineView.rest[i$1]) > lineN)\n      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n}\n\n// Render a line into the hidden node display.externalMeasured. Used\n// when measurement is needed for a line that's not in the viewport.\nfunction updateExternalMeasurement(cm, line) {\n  line = visualLine(line);\n  var lineN = lineNo(line);\n  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n  view.lineN = lineN;\n  var built = view.built = buildLineContent(cm, view);\n  view.text = built.pre;\n  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n  return view\n}\n\n// Get a {top, bottom, left, right} box (in line-local coordinates)\n// for a given character.\nfunction measureChar(cm, line, ch, bias) {\n  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n}\n\n// Find a line view that corresponds to the given line number.\nfunction findViewForLine(cm, lineN) {\n  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n    { return cm.display.view[findViewIndex(cm, lineN)] }\n  var ext = cm.display.externalMeasured;\n  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n    { return ext }\n}\n\n// Measurement can be split in two steps, the set-up work that\n// applies to the whole line, and the measurement of the actual\n// character. Functions like coordsChar, that need to do a lot of\n// measurements in a row, can thus ensure that the set-up work is\n// only done once.\nfunction prepareMeasureForLine(cm, line) {\n  var lineN = lineNo(line);\n  var view = findViewForLine(cm, lineN);\n  if (view && !view.text) {\n    view = null;\n  } else if (view && view.changes) {\n    updateLineForChanges(cm, view, lineN, getDimensions(cm));\n    cm.curOp.forceUpdate = true;\n  }\n  if (!view)\n    { view = updateExternalMeasurement(cm, line); }\n\n  var info = mapFromLineView(view, line, lineN);\n  return {\n    line: line, view: view, rect: null,\n    map: info.map, cache: info.cache, before: info.before,\n    hasHeights: false\n  }\n}\n\n// Given a prepared measurement object, measures the position of an\n// actual character (or fetches it from the cache).\nfunction measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n  if (prepared.before) { ch = -1; }\n  var key = ch + (bias || \"\"), found;\n  if (prepared.cache.hasOwnProperty(key)) {\n    found = prepared.cache[key];\n  } else {\n    if (!prepared.rect)\n      { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n    if (!prepared.hasHeights) {\n      ensureLineHeights(cm, prepared.view, prepared.rect);\n      prepared.hasHeights = true;\n    }\n    found = measureCharInner(cm, prepared, ch, bias);\n    if (!found.bogus) { prepared.cache[key] = found; }\n  }\n  return {left: found.left, right: found.right,\n          top: varHeight ? found.rtop : found.top,\n          bottom: varHeight ? found.rbottom : found.bottom}\n}\n\nvar nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\nfunction nodeAndOffsetInLineMap(map$$1, ch, bias) {\n  var node, start, end, collapse, mStart, mEnd;\n  // First, search the line map for the text node corresponding to,\n  // or closest to, the target character.\n  for (var i = 0; i < map$$1.length; i += 3) {\n    mStart = map$$1[i];\n    mEnd = map$$1[i + 1];\n    if (ch < mStart) {\n      start = 0; end = 1;\n      collapse = \"left\";\n    } else if (ch < mEnd) {\n      start = ch - mStart;\n      end = start + 1;\n    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\n      end = mEnd - mStart;\n      start = end - 1;\n      if (ch >= mEnd) { collapse = \"right\"; }\n    }\n    if (start != null) {\n      node = map$$1[i + 2];\n      if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n        { collapse = bias; }\n      if (bias == \"left\" && start == 0)\n        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\n          node = map$$1[(i -= 3) + 2];\n          collapse = \"left\";\n        } }\n      if (bias == \"right\" && start == mEnd - mStart)\n        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\n          node = map$$1[(i += 3) + 2];\n          collapse = \"right\";\n        } }\n      break\n    }\n  }\n  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n}\n\nfunction getUsefulRect(rects, bias) {\n  var rect = nullRect;\n  if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n    if ((rect = rects[i]).left != rect.right) { break }\n  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n    if ((rect = rects[i$1]).left != rect.right) { break }\n  } }\n  return rect\n}\n\nfunction measureCharInner(cm, prepared, ch, bias) {\n  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n  var rect;\n  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n        { rect = node.parentNode.getBoundingClientRect(); }\n      else\n        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n      if (rect.left || rect.right || start == 0) { break }\n      end = start;\n      start = start - 1;\n      collapse = \"right\";\n    }\n    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n  } else { // If it is a widget, simply get the box for the whole widget.\n    if (start > 0) { collapse = bias = \"right\"; }\n    var rects;\n    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n      { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n    else\n      { rect = node.getBoundingClientRect(); }\n  }\n  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n    var rSpan = node.parentNode.getClientRects()[0];\n    if (rSpan)\n      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n    else\n      { rect = nullRect; }\n  }\n\n  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n  var mid = (rtop + rbot) / 2;\n  var heights = prepared.view.measure.heights;\n  var i = 0;\n  for (; i < heights.length - 1; i++)\n    { if (mid < heights[i]) { break } }\n  var top = i ? heights[i - 1] : 0, bot = heights[i];\n  var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                top: top, bottom: bot};\n  if (!rect.left && !rect.right) { result.bogus = true; }\n  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n  return result\n}\n\n// Work around problem with bounding client rects on ranges being\n// returned incorrectly when zoomed on IE10 and below.\nfunction maybeUpdateRectForZooming(measure, rect) {\n  if (!window.screen || screen.logicalXDPI == null ||\n      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n    { return rect }\n  var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n  var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n  return {left: rect.left * scaleX, right: rect.right * scaleX,\n          top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n}\n\nfunction clearLineMeasurementCacheFor(lineView) {\n  if (lineView.measure) {\n    lineView.measure.cache = {};\n    lineView.measure.heights = null;\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { lineView.measure.caches[i] = {}; } }\n  }\n}\n\nfunction clearLineMeasurementCache(cm) {\n  cm.display.externalMeasure = null;\n  removeChildren(cm.display.lineMeasure);\n  for (var i = 0; i < cm.display.view.length; i++)\n    { clearLineMeasurementCacheFor(cm.display.view[i]); }\n}\n\nfunction clearCaches(cm) {\n  clearLineMeasurementCache(cm);\n  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n  cm.display.lineNumChars = null;\n}\n\nfunction pageScrollX() {\n  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n  // which causes page_Offset and bounding client rects to use\n  // different reference viewports and invalidate our calculations.\n  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n  return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n}\nfunction pageScrollY() {\n  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n  return window.pageYOffset || (document.documentElement || document.body).scrollTop\n}\n\nfunction widgetTopHeight(lineObj) {\n  var height = 0;\n  if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\n    { height += widgetHeight(lineObj.widgets[i]); } } }\n  return height\n}\n\n// Converts a {top, bottom, left, right} box from line-local\n// coordinates into another coordinate system. Context may be one of\n// \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n// or \"page\".\nfunction intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n  if (!includeWidgets) {\n    var height = widgetTopHeight(lineObj);\n    rect.top += height; rect.bottom += height;\n  }\n  if (context == \"line\") { return rect }\n  if (!context) { context = \"local\"; }\n  var yOff = heightAtLine(lineObj);\n  if (context == \"local\") { yOff += paddingTop(cm.display); }\n  else { yOff -= cm.display.viewOffset; }\n  if (context == \"page\" || context == \"window\") {\n    var lOff = cm.display.lineSpace.getBoundingClientRect();\n    yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n    var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n    rect.left += xOff; rect.right += xOff;\n  }\n  rect.top += yOff; rect.bottom += yOff;\n  return rect\n}\n\n// Coverts a box from \"div\" coords to another coordinate system.\n// Context may be \"window\", \"page\", \"div\", or \"local\"./null.\nfunction fromCoordSystem(cm, coords, context) {\n  if (context == \"div\") { return coords }\n  var left = coords.left, top = coords.top;\n  // First move into \"page\" coordinate system\n  if (context == \"page\") {\n    left -= pageScrollX();\n    top -= pageScrollY();\n  } else if (context == \"local\" || !context) {\n    var localBox = cm.display.sizer.getBoundingClientRect();\n    left += localBox.left;\n    top += localBox.top;\n  }\n\n  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n}\n\nfunction charCoords(cm, pos, context, lineObj, bias) {\n  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n}\n\n// Returns a box for a given cursor position, which may have an\n// 'other' property containing the position of the secondary cursor\n// on a bidi boundary.\n// A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n// and after `char - 1` in writing order of `char - 1`\n// A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n// and before `char` in writing order of `char`\n// Examples (upper-case letters are RTL, lower-case are LTR):\n//     Pos(0, 1, ...)\n//     before   after\n// ab     a|b     a|b\n// aB     a|B     aB|\n// Ab     |Ab     A|b\n// AB     B|A     B|A\n// Every position after the last character on a line is considered to stick\n// to the last character on the line.\nfunction cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n  lineObj = lineObj || getLine(cm.doc, pos.line);\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n  function get(ch, right) {\n    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n    if (right) { m.left = m.right; } else { m.right = m.left; }\n    return intoCoordSystem(cm, lineObj, m, context)\n  }\n  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n  if (ch >= lineObj.text.length) {\n    ch = lineObj.text.length;\n    sticky = \"before\";\n  } else if (ch <= 0) {\n    ch = 0;\n    sticky = \"after\";\n  }\n  if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n  function getBidi(ch, partPos, invert) {\n    var part = order[partPos], right = part.level == 1;\n    return get(invert ? ch - 1 : ch, right != invert)\n  }\n  var partPos = getBidiPartAt(order, ch, sticky);\n  var other = bidiOther;\n  var val = getBidi(ch, partPos, sticky == \"before\");\n  if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n  return val\n}\n\n// Used to cheaply estimate the coordinates for a position. Used for\n// intermediate scroll updates.\nfunction estimateCoords(cm, pos) {\n  var left = 0;\n  pos = clipPos(cm.doc, pos);\n  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n  var lineObj = getLine(cm.doc, pos.line);\n  var top = heightAtLine(lineObj) + paddingTop(cm.display);\n  return {left: left, right: left, top: top, bottom: top + lineObj.height}\n}\n\n// Positions returned by coordsChar contain some extra information.\n// xRel is the relative x position of the input coordinates compared\n// to the found position (so xRel > 0 means the coordinates are to\n// the right of the character position, for example). When outside\n// is true, that means the coordinates lie outside the line's\n// vertical range.\nfunction PosWithInfo(line, ch, sticky, outside, xRel) {\n  var pos = Pos(line, ch, sticky);\n  pos.xRel = xRel;\n  if (outside) { pos.outside = true; }\n  return pos\n}\n\n// Compute the character position closest to the given coordinates.\n// Input must be lineSpace-local (\"div\" coordinate system).\nfunction coordsChar(cm, x, y) {\n  var doc = cm.doc;\n  y += cm.display.viewOffset;\n  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\n  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n  if (lineN > last)\n    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\n  if (x < 0) { x = 0; }\n\n  var lineObj = getLine(doc, lineN);\n  for (;;) {\n    var found = coordsCharInner(cm, lineObj, lineN, x, y);\n    var merged = collapsedSpanAtEnd(lineObj);\n    var mergedPos = merged && merged.find(0, true);\n    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n      { lineN = lineNo(lineObj = mergedPos.to.line); }\n    else\n      { return found }\n  }\n}\n\nfunction wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n  y -= widgetTopHeight(lineObj);\n  var end = lineObj.text.length;\n  var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\n  end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\n  return {begin: begin, end: end}\n}\n\nfunction wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n}\n\n// Returns true if the given side of a box is after the given\n// coordinates, in top-to-bottom, left-to-right order.\nfunction boxIsAfter(box, x, y, left) {\n  return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\n}\n\nfunction coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\n  // Move y into line-local coordinate space\n  y -= heightAtLine(lineObj);\n  var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n  // When directly calling `measureCharPrepared`, we have to adjust\n  // for the widgets at this line.\n  var widgetHeight$$1 = widgetTopHeight(lineObj);\n  var begin = 0, end = lineObj.text.length, ltr = true;\n\n  var order = getOrder(lineObj, cm.doc.direction);\n  // If the line isn't plain left-to-right text, first figure out\n  // which bidi section the coordinates fall into.\n  if (order) {\n    var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                 (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);\n    ltr = part.level != 1;\n    // The awkward -1 offsets are needed because findFirst (called\n    // on these below) will treat its first bound as inclusive,\n    // second as exclusive, but we want to actually address the\n    // characters in the part's range\n    begin = ltr ? part.from : part.to - 1;\n    end = ltr ? part.to : part.from - 1;\n  }\n\n  // A binary search to find the first character whose bounding box\n  // starts after the coordinates. If we run across any whose box wrap\n  // the coordinates, store that.\n  var chAround = null, boxAround = null;\n  var ch = findFirst(function (ch) {\n    var box = measureCharPrepared(cm, preparedMeasure, ch);\n    box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;\n    if (!boxIsAfter(box, x, y, false)) { return false }\n    if (box.top <= y && box.left <= x) {\n      chAround = ch;\n      boxAround = box;\n    }\n    return true\n  }, begin, end);\n\n  var baseX, sticky, outside = false;\n  // If a box around the coordinates was found, use that\n  if (boxAround) {\n    // Distinguish coordinates nearer to the left or right side of the box\n    var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n    ch = chAround + (atStart ? 0 : 1);\n    sticky = atStart ? \"after\" : \"before\";\n    baseX = atLeft ? boxAround.left : boxAround.right;\n  } else {\n    // (Adjust for extended bound, if necessary.)\n    if (!ltr && (ch == end || ch == begin)) { ch++; }\n    // To determine which side to associate with, get the box to the\n    // left of the character and compare it's vertical position to the\n    // coordinates\n    sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\n      (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?\n      \"after\" : \"before\";\n    // Now get accurate coordinates for this place, in order to get a\n    // base X position\n    var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), \"line\", lineObj, preparedMeasure);\n    baseX = coords.left;\n    outside = y < coords.top || y >= coords.bottom;\n  }\n\n  ch = skipExtendingChars(lineObj.text, ch, 1);\n  return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)\n}\n\nfunction coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {\n  // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n  // situation, we can take this ordering to correspond to the visual\n  // ordering. This finds the first part whose end is after the given\n  // coordinates.\n  var index = findFirst(function (i) {\n    var part = order[i], ltr = part.level != 1;\n    return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\n                                   \"line\", lineObj, preparedMeasure), x, y, true)\n  }, 0, order.length - 1);\n  var part = order[index];\n  // If this isn't the first part, the part's start is also after\n  // the coordinates, and the coordinates aren't on the same line as\n  // that start, move one part back.\n  if (index > 0) {\n    var ltr = part.level != 1;\n    var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\n                             \"line\", lineObj, preparedMeasure);\n    if (boxIsAfter(start, x, y, true) && start.top > y)\n      { part = order[index - 1]; }\n  }\n  return part\n}\n\nfunction coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n  // In a wrapped line, rtl text on wrapping boundaries can do things\n  // that don't correspond to the ordering in our `order` array at\n  // all, so a binary search doesn't work, and we want to return a\n  // part that only spans one line so that the binary search in\n  // coordsCharInner is safe. As such, we first find the extent of the\n  // wrapped line, and then do a flat search in which we discard any\n  // spans that aren't on the line.\n  var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n  var begin = ref.begin;\n  var end = ref.end;\n  if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n  var part = null, closestDist = null;\n  for (var i = 0; i < order.length; i++) {\n    var p = order[i];\n    if (p.from >= end || p.to <= begin) { continue }\n    var ltr = p.level != 1;\n    var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n    // Weigh against spans ending before this, so that they are only\n    // picked if nothing ends after\n    var dist = endX < x ? x - endX + 1e9 : endX - x;\n    if (!part || closestDist > dist) {\n      part = p;\n      closestDist = dist;\n    }\n  }\n  if (!part) { part = order[order.length - 1]; }\n  // Clip the part to the wrapped line.\n  if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\n  if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\n  return part\n}\n\nvar measureText;\n// Compute the default text height.\nfunction textHeight(display) {\n  if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n  if (measureText == null) {\n    measureText = elt(\"pre\");\n    // Measure a bunch of lines, for browsers that compute\n    // fractional heights.\n    for (var i = 0; i < 49; ++i) {\n      measureText.appendChild(document.createTextNode(\"x\"));\n      measureText.appendChild(elt(\"br\"));\n    }\n    measureText.appendChild(document.createTextNode(\"x\"));\n  }\n  removeChildrenAndAdd(display.measure, measureText);\n  var height = measureText.offsetHeight / 50;\n  if (height > 3) { display.cachedTextHeight = height; }\n  removeChildren(display.measure);\n  return height || 1\n}\n\n// Compute the default character width.\nfunction charWidth(display) {\n  if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n  var anchor = elt(\"span\", \"xxxxxxxxxx\");\n  var pre = elt(\"pre\", [anchor]);\n  removeChildrenAndAdd(display.measure, pre);\n  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n  if (width > 2) { display.cachedCharWidth = width; }\n  return width || 10\n}\n\n// Do a bulk-read of the DOM positions and sizes needed to draw the\n// view, so that we don't interleave reading and writing to the DOM.\nfunction getDimensions(cm) {\n  var d = cm.display, left = {}, width = {};\n  var gutterLeft = d.gutters.clientLeft;\n  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n    width[cm.options.gutters[i]] = n.clientWidth;\n  }\n  return {fixedPos: compensateForHScroll(d),\n          gutterTotalWidth: d.gutters.offsetWidth,\n          gutterLeft: left,\n          gutterWidth: width,\n          wrapperWidth: d.wrapper.clientWidth}\n}\n\n// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n// but using getBoundingClientRect to get a sub-pixel-accurate\n// result.\nfunction compensateForHScroll(display) {\n  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n}\n\n// Returns a function that estimates the height of a line, to use as\n// first approximation until the line becomes visible (and is thus\n// properly measurable).\nfunction estimateHeight(cm) {\n  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n  return function (line) {\n    if (lineIsHidden(cm.doc, line)) { return 0 }\n\n    var widgetsHeight = 0;\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n    } }\n\n    if (wrapping)\n      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n    else\n      { return widgetsHeight + th }\n  }\n}\n\nfunction estimateLineHeights(cm) {\n  var doc = cm.doc, est = estimateHeight(cm);\n  doc.iter(function (line) {\n    var estHeight = est(line);\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  });\n}\n\n// Given a mouse event, find the corresponding position. If liberal\n// is false, it checks whether a gutter or scrollbar was clicked,\n// and returns null if it was. forRect is used by rectangular\n// selections, and tries to estimate a character position even for\n// coordinates beyond the right of the text.\nfunction posFromMouse(cm, e, liberal, forRect) {\n  var display = cm.display;\n  if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n  var x, y, space = display.lineSpace.getBoundingClientRect();\n  // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n  try { x = e.clientX - space.left; y = e.clientY - space.top; }\n  catch (e) { return null }\n  var coords = coordsChar(cm, x, y), line;\n  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n  }\n  return coords\n}\n\n// Find the view element corresponding to a given line. Return null\n// when the line isn't visible.\nfunction findViewIndex(cm, n) {\n  if (n >= cm.display.viewTo) { return null }\n  n -= cm.display.viewFrom;\n  if (n < 0) { return null }\n  var view = cm.display.view;\n  for (var i = 0; i < view.length; i++) {\n    n -= view[i].size;\n    if (n < 0) { return i }\n  }\n}\n\nfunction updateSelection(cm) {\n  cm.display.input.showSelection(cm.display.input.prepareSelection());\n}\n\nfunction prepareSelection(cm, primary) {\n  if ( primary === void 0 ) primary = true;\n\n  var doc = cm.doc, result = {};\n  var curFragment = result.cursors = document.createDocumentFragment();\n  var selFragment = result.selection = document.createDocumentFragment();\n\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    if (!primary && i == doc.sel.primIndex) { continue }\n    var range$$1 = doc.sel.ranges[i];\n    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\n    var collapsed = range$$1.empty();\n    if (collapsed || cm.options.showCursorWhenSelecting)\n      { drawSelectionCursor(cm, range$$1.head, curFragment); }\n    if (!collapsed)\n      { drawSelectionRange(cm, range$$1, selFragment); }\n  }\n  return result\n}\n\n// Draws a cursor for the given range\nfunction drawSelectionCursor(cm, head, output) {\n  var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n  var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n  cursor.style.left = pos.left + \"px\";\n  cursor.style.top = pos.top + \"px\";\n  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n  if (pos.other) {\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\n    var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n    otherCursor.style.display = \"\";\n    otherCursor.style.left = pos.other.left + \"px\";\n    otherCursor.style.top = pos.other.top + \"px\";\n    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n  }\n}\n\nfunction cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n// Draws the given range as a highlighted selection\nfunction drawSelectionRange(cm, range$$1, output) {\n  var display = cm.display, doc = cm.doc;\n  var fragment = document.createDocumentFragment();\n  var padding = paddingH(cm.display), leftSide = padding.left;\n  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n  var docLTR = doc.direction == \"ltr\";\n\n  function add(left, top, width, bottom) {\n    if (top < 0) { top = 0; }\n    top = Math.round(top);\n    bottom = Math.round(bottom);\n    fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n  }\n\n  function drawForLine(line, fromArg, toArg) {\n    var lineObj = getLine(doc, line);\n    var lineLen = lineObj.text.length;\n    var start, end;\n    function coords(ch, bias) {\n      return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n    }\n\n    function wrapX(pos, dir, side) {\n      var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n      var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\n      var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n      return coords(ch, prop)[prop]\n    }\n\n    var order = getOrder(lineObj, doc.direction);\n    iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n      var ltr = dir == \"ltr\";\n      var fromPos = coords(from, ltr ? \"left\" : \"right\");\n      var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n\n      var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n      var first = i == 0, last = !order || i == order.length - 1;\n      if (toPos.top - fromPos.top <= 3) { // Single line\n        var openLeft = (docLTR ? openStart : openEnd) && first;\n        var openRight = (docLTR ? openEnd : openStart) && last;\n        var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n        var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n        add(left, fromPos.top, right - left, fromPos.bottom);\n      } else { // Multiple lines\n        var topLeft, topRight, botLeft, botRight;\n        if (ltr) {\n          topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n          topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n          botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n          botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n        } else {\n          topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n          topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n          botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n          botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n        }\n        add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n        if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n        add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n      }\n\n      if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\n      if (cmpCoords(toPos, start) < 0) { start = toPos; }\n      if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\n      if (cmpCoords(toPos, end) < 0) { end = toPos; }\n    });\n    return {start: start, end: end}\n  }\n\n  var sFrom = range$$1.from(), sTo = range$$1.to();\n  if (sFrom.line == sTo.line) {\n    drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n  } else {\n    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n    var singleVLine = visualLine(fromLine) == visualLine(toLine);\n    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n    if (singleVLine) {\n      if (leftEnd.top < rightStart.top - 2) {\n        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n      } else {\n        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n      }\n    }\n    if (leftEnd.bottom < rightStart.top)\n      { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n  }\n\n  output.appendChild(fragment);\n}\n\n// Cursor-blinking\nfunction restartBlink(cm) {\n  if (!cm.state.focused) { return }\n  var display = cm.display;\n  clearInterval(display.blinker);\n  var on = true;\n  display.cursorDiv.style.visibility = \"\";\n  if (cm.options.cursorBlinkRate > 0)\n    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\n      cm.options.cursorBlinkRate); }\n  else if (cm.options.cursorBlinkRate < 0)\n    { display.cursorDiv.style.visibility = \"hidden\"; }\n}\n\nfunction ensureFocus(cm) {\n  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n}\n\nfunction delayBlurEvent(cm) {\n  cm.state.delayingBlurEvent = true;\n  setTimeout(function () { if (cm.state.delayingBlurEvent) {\n    cm.state.delayingBlurEvent = false;\n    onBlur(cm);\n  } }, 100);\n}\n\nfunction onFocus(cm, e) {\n  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\n\n  if (cm.options.readOnly == \"nocursor\") { return }\n  if (!cm.state.focused) {\n    signal(cm, \"focus\", cm, e);\n    cm.state.focused = true;\n    addClass(cm.display.wrapper, \"CodeMirror-focused\");\n    // This test prevents this from firing when a context\n    // menu is closed (since the input reset would kill the\n    // select-all detection hack)\n    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n      cm.display.input.reset();\n      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n    }\n    cm.display.input.receivedFocus();\n  }\n  restartBlink(cm);\n}\nfunction onBlur(cm, e) {\n  if (cm.state.delayingBlurEvent) { return }\n\n  if (cm.state.focused) {\n    signal(cm, \"blur\", cm, e);\n    cm.state.focused = false;\n    rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n  }\n  clearInterval(cm.display.blinker);\n  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n}\n\n// Read the actual heights of the rendered lines, and update their\n// stored heights to match.\nfunction updateHeightsInViewport(cm) {\n  var display = cm.display;\n  var prevBottom = display.lineDiv.offsetTop;\n  for (var i = 0; i < display.view.length; i++) {\n    var cur = display.view[i], height = (void 0);\n    if (cur.hidden) { continue }\n    if (ie && ie_version < 8) {\n      var bot = cur.node.offsetTop + cur.node.offsetHeight;\n      height = bot - prevBottom;\n      prevBottom = bot;\n    } else {\n      var box = cur.node.getBoundingClientRect();\n      height = box.bottom - box.top;\n    }\n    var diff = cur.line.height - height;\n    if (height < 2) { height = textHeight(display); }\n    if (diff > .005 || diff < -.005) {\n      updateLineHeight(cur.line, height);\n      updateWidgetHeight(cur.line);\n      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n        { updateWidgetHeight(cur.rest[j]); } }\n    }\n  }\n}\n\n// Read and store the height of line widgets associated with the\n// given line.\nfunction updateWidgetHeight(line) {\n  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)\n    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight; } }\n}\n\n// Compute the lines that are visible in a given viewport (defaults\n// the the current scroll position). viewport may contain top,\n// height, and ensure (see op.scrollToPos) properties.\nfunction visibleLines(display, doc, viewport) {\n  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n  top = Math.floor(top - paddingTop(display));\n  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n  // forces those lines into the viewport (if possible).\n  if (viewport && viewport.ensure) {\n    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n    if (ensureFrom < from) {\n      from = ensureFrom;\n      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n      to = ensureTo;\n    }\n  }\n  return {from: from, to: Math.max(to, from + 1)}\n}\n\n// Re-align line numbers and gutter marks to compensate for\n// horizontal scrolling.\nfunction alignHorizontally(cm) {\n  var display = cm.display, view = display.view;\n  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n  var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n    if (cm.options.fixedGutter) {\n      if (view[i].gutter)\n        { view[i].gutter.style.left = left; }\n      if (view[i].gutterBackground)\n        { view[i].gutterBackground.style.left = left; }\n    }\n    var align = view[i].alignable;\n    if (align) { for (var j = 0; j < align.length; j++)\n      { align[j].style.left = left; } }\n  } }\n  if (cm.options.fixedGutter)\n    { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n}\n\n// Used to ensure that the line number gutter is still the right\n// size for the current document size. Returns true when an update\n// is needed.\nfunction maybeUpdateLineNumberWidth(cm) {\n  if (!cm.options.lineNumbers) { return false }\n  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n  if (last.length != display.lineNumChars) {\n    var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                               \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n    display.lineGutter.style.width = \"\";\n    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n    display.lineNumWidth = display.lineNumInnerWidth + padding;\n    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n    display.lineGutter.style.width = display.lineNumWidth + \"px\";\n    updateGutterSpace(cm);\n    return true\n  }\n  return false\n}\n\n// SCROLLING THINGS INTO VIEW\n\n// If an editor sits on the top or bottom of the window, partially\n// scrolled out of view, this ensures that the cursor is visible.\nfunction maybeScrollWindow(cm, rect) {\n  if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n  if (rect.top + box.top < 0) { doScroll = true; }\n  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n  if (doScroll != null && !phantom) {\n    var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n    cm.display.lineSpace.appendChild(scrollNode);\n    scrollNode.scrollIntoView(doScroll);\n    cm.display.lineSpace.removeChild(scrollNode);\n  }\n}\n\n// Scroll a given position into view (immediately), verifying that\n// it actually became visible (as line heights are accurately\n// measured, the position of something may 'drift' during drawing).\nfunction scrollPosIntoView(cm, pos, end, margin) {\n  if (margin == null) { margin = 0; }\n  var rect;\n  if (!cm.options.lineWrapping && pos == end) {\n    // Set pos and end to the cursor positions around the character pos sticks to\n    // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n    // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n    pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n    end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n  }\n  for (var limit = 0; limit < 5; limit++) {\n    var changed = false;\n    var coords = cursorCoords(cm, pos);\n    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n    rect = {left: Math.min(coords.left, endCoords.left),\n            top: Math.min(coords.top, endCoords.top) - margin,\n            right: Math.max(coords.left, endCoords.left),\n            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n    var scrollPos = calculateScrollPos(cm, rect);\n    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n    if (scrollPos.scrollTop != null) {\n      updateScrollTop(cm, scrollPos.scrollTop);\n      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n    }\n    if (scrollPos.scrollLeft != null) {\n      setScrollLeft(cm, scrollPos.scrollLeft);\n      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n    }\n    if (!changed) { break }\n  }\n  return rect\n}\n\n// Scroll a given set of coordinates into view (immediately).\nfunction scrollIntoView(cm, rect) {\n  var scrollPos = calculateScrollPos(cm, rect);\n  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n}\n\n// Calculate a new scroll position needed to scroll the given\n// rectangle into view. Returns an object with scrollTop and\n// scrollLeft properties. When these are undefined, the\n// vertical/horizontal position does not need to be adjusted.\nfunction calculateScrollPos(cm, rect) {\n  var display = cm.display, snapMargin = textHeight(cm.display);\n  if (rect.top < 0) { rect.top = 0; }\n  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n  var screen = displayHeight(cm), result = {};\n  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n  var docBottom = cm.doc.height + paddingVert(display);\n  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n  if (rect.top < screentop) {\n    result.scrollTop = atTop ? 0 : rect.top;\n  } else if (rect.bottom > screentop + screen) {\n    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n    if (newTop != screentop) { result.scrollTop = newTop; }\n  }\n\n  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n  var tooWide = rect.right - rect.left > screenw;\n  if (tooWide) { rect.right = rect.left + screenw; }\n  if (rect.left < 10)\n    { result.scrollLeft = 0; }\n  else if (rect.left < screenleft)\n    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\n  else if (rect.right > screenw + screenleft - 3)\n    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n  return result\n}\n\n// Store a relative adjustment to the scroll position in the current\n// operation (to be applied when the operation finishes).\nfunction addToScrollTop(cm, top) {\n  if (top == null) { return }\n  resolveScrollToPos(cm);\n  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n}\n\n// Make sure that at the end of the operation the current cursor is\n// shown.\nfunction ensureCursorVisible(cm) {\n  resolveScrollToPos(cm);\n  var cur = cm.getCursor();\n  cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n}\n\nfunction scrollToCoords(cm, x, y) {\n  if (x != null || y != null) { resolveScrollToPos(cm); }\n  if (x != null) { cm.curOp.scrollLeft = x; }\n  if (y != null) { cm.curOp.scrollTop = y; }\n}\n\nfunction scrollToRange(cm, range$$1) {\n  resolveScrollToPos(cm);\n  cm.curOp.scrollToPos = range$$1;\n}\n\n// When an operation has its scrollToPos property set, and another\n// scroll action is applied before the end of the operation, this\n// 'simulates' scrolling that position into view in a cheap way, so\n// that the effect of intermediate scroll commands is not ignored.\nfunction resolveScrollToPos(cm) {\n  var range$$1 = cm.curOp.scrollToPos;\n  if (range$$1) {\n    cm.curOp.scrollToPos = null;\n    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\n    scrollToCoordsRange(cm, from, to, range$$1.margin);\n  }\n}\n\nfunction scrollToCoordsRange(cm, from, to, margin) {\n  var sPos = calculateScrollPos(cm, {\n    left: Math.min(from.left, to.left),\n    top: Math.min(from.top, to.top) - margin,\n    right: Math.max(from.right, to.right),\n    bottom: Math.max(from.bottom, to.bottom) + margin\n  });\n  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n}\n\n// Sync the scrollable area and scrollbars, ensure the viewport\n// covers the visible area.\nfunction updateScrollTop(cm, val) {\n  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n  if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n  setScrollTop(cm, val, true);\n  if (gecko) { updateDisplaySimple(cm); }\n  startWorker(cm, 100);\n}\n\nfunction setScrollTop(cm, val, forceScroll) {\n  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\n  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n  cm.doc.scrollTop = val;\n  cm.display.scrollbars.setScrollTop(val);\n  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n}\n\n// Sync scroller and scrollbar, ensure the gutter elements are\n// aligned.\nfunction setScrollLeft(cm, val, isScroller, forceScroll) {\n  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n  cm.doc.scrollLeft = val;\n  alignHorizontally(cm);\n  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n  cm.display.scrollbars.setScrollLeft(val);\n}\n\n// SCROLLBARS\n\n// Prepare DOM reads needed to update the scrollbars. Done in one\n// shot to minimize update/measure roundtrips.\nfunction measureForScrollbars(cm) {\n  var d = cm.display, gutterW = d.gutters.offsetWidth;\n  var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n  return {\n    clientHeight: d.scroller.clientHeight,\n    viewHeight: d.wrapper.clientHeight,\n    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n    viewWidth: d.wrapper.clientWidth,\n    barLeft: cm.options.fixedGutter ? gutterW : 0,\n    docHeight: docH,\n    scrollHeight: docH + scrollGap(cm) + d.barHeight,\n    nativeBarWidth: d.nativeBarWidth,\n    gutterWidth: gutterW\n  }\n}\n\nvar NativeScrollbars = function(place, scroll, cm) {\n  this.cm = cm;\n  var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n  var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n  place(vert); place(horiz);\n\n  on(vert, \"scroll\", function () {\n    if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n  });\n  on(horiz, \"scroll\", function () {\n    if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n  });\n\n  this.checkedZeroWidth = false;\n  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n};\n\nNativeScrollbars.prototype.update = function (measure) {\n  var needsH = measure.scrollWidth > measure.clientWidth + 1;\n  var needsV = measure.scrollHeight > measure.clientHeight + 1;\n  var sWidth = measure.nativeBarWidth;\n\n  if (needsV) {\n    this.vert.style.display = \"block\";\n    this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n    // A bug in IE8 can cause this value to be negative, so guard it.\n    this.vert.firstChild.style.height =\n      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n  } else {\n    this.vert.style.display = \"\";\n    this.vert.firstChild.style.height = \"0\";\n  }\n\n  if (needsH) {\n    this.horiz.style.display = \"block\";\n    this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n    this.horiz.style.left = measure.barLeft + \"px\";\n    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n    this.horiz.firstChild.style.width =\n      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n  } else {\n    this.horiz.style.display = \"\";\n    this.horiz.firstChild.style.width = \"0\";\n  }\n\n  if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n    if (sWidth == 0) { this.zeroWidthHack(); }\n    this.checkedZeroWidth = true;\n  }\n\n  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n};\n\nNativeScrollbars.prototype.setScrollLeft = function (pos) {\n  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n};\n\nNativeScrollbars.prototype.setScrollTop = function (pos) {\n  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n};\n\nNativeScrollbars.prototype.zeroWidthHack = function () {\n  var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n  this.horiz.style.height = this.vert.style.width = w;\n  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n  this.disableHoriz = new Delayed;\n  this.disableVert = new Delayed;\n};\n\nNativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n  bar.style.pointerEvents = \"auto\";\n  function maybeDisable() {\n    // To find out whether the scrollbar is still visible, we\n    // check whether the element under the pixel in the bottom\n    // right corner of the scrollbar box is the scrollbar box\n    // itself (when the bar is still visible) or its filler child\n    // (when the bar is hidden). If it is still visible, we keep\n    // it enabled, if it's hidden, we disable pointer events.\n    var box = bar.getBoundingClientRect();\n    var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n    if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\n    else { delay.set(1000, maybeDisable); }\n  }\n  delay.set(1000, maybeDisable);\n};\n\nNativeScrollbars.prototype.clear = function () {\n  var parent = this.horiz.parentNode;\n  parent.removeChild(this.horiz);\n  parent.removeChild(this.vert);\n};\n\nvar NullScrollbars = function () {};\n\nNullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\nNullScrollbars.prototype.setScrollLeft = function () {};\nNullScrollbars.prototype.setScrollTop = function () {};\nNullScrollbars.prototype.clear = function () {};\n\nfunction updateScrollbars(cm, measure) {\n  if (!measure) { measure = measureForScrollbars(cm); }\n  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n  updateScrollbarsInner(cm, measure);\n  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n      { updateHeightsInViewport(cm); }\n    updateScrollbarsInner(cm, measureForScrollbars(cm));\n    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n  }\n}\n\n// Re-synchronize the fake scrollbars with the actual size of the\n// content.\nfunction updateScrollbarsInner(cm, measure) {\n  var d = cm.display;\n  var sizes = d.scrollbars.update(measure);\n\n  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n  d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n  if (sizes.right && sizes.bottom) {\n    d.scrollbarFiller.style.display = \"block\";\n    d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n    d.scrollbarFiller.style.width = sizes.right + \"px\";\n  } else { d.scrollbarFiller.style.display = \"\"; }\n  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n    d.gutterFiller.style.display = \"block\";\n    d.gutterFiller.style.height = sizes.bottom + \"px\";\n    d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n  } else { d.gutterFiller.style.display = \"\"; }\n}\n\nvar scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\nfunction initScrollbars(cm) {\n  if (cm.display.scrollbars) {\n    cm.display.scrollbars.clear();\n    if (cm.display.scrollbars.addClass)\n      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n    // Prevent clicks in the scrollbars from killing focus\n    on(node, \"mousedown\", function () {\n      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n    });\n    node.setAttribute(\"cm-not-content\", \"true\");\n  }, function (pos, axis) {\n    if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n    else { updateScrollTop(cm, pos); }\n  }, cm);\n  if (cm.display.scrollbars.addClass)\n    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n}\n\n// Operations are used to wrap a series of changes to the editor\n// state in such a way that each change won't have to update the\n// cursor and display (which would be awkward, slow, and\n// error-prone). Instead, display updates are batched and then all\n// combined and executed at once.\n\nvar nextOpId = 0;\n// Start a new operation.\nfunction startOperation(cm) {\n  cm.curOp = {\n    cm: cm,\n    viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n    startHeight: cm.doc.height, // Used to detect need to update scrollbar\n    forceUpdate: false,      // Used to force a redraw\n    updateInput: null,       // Whether to reset the input textarea\n    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n    changeObjs: null,        // Accumulated changes, for firing change events\n    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n    selectionChanged: false, // Whether the selection needs to be redrawn\n    updateMaxLine: false,    // Set when the widest line needs to be determined anew\n    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n    scrollToPos: null,       // Used to scroll to a specific position\n    focus: false,\n    id: ++nextOpId           // Unique ID\n  };\n  pushOperation(cm.curOp);\n}\n\n// Finish an operation, updating the display and signalling delayed events\nfunction endOperation(cm) {\n  var op = cm.curOp;\n  finishOperation(op, function (group) {\n    for (var i = 0; i < group.ops.length; i++)\n      { group.ops[i].cm.curOp = null; }\n    endOperations(group);\n  });\n}\n\n// The DOM updates done when an operation finishes are batched so\n// that the minimum number of relayouts are required.\nfunction endOperations(group) {\n  var ops = group.ops;\n  for (var i = 0; i < ops.length; i++) // Read DOM\n    { endOperation_R1(ops[i]); }\n  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n    { endOperation_W1(ops[i$1]); }\n  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n    { endOperation_R2(ops[i$2]); }\n  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n    { endOperation_W2(ops[i$3]); }\n  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n    { endOperation_finish(ops[i$4]); }\n}\n\nfunction endOperation_R1(op) {\n  var cm = op.cm, display = cm.display;\n  maybeClipScrollbars(cm);\n  if (op.updateMaxLine) { findMaxLine(cm); }\n\n  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                       op.scrollToPos.to.line >= display.viewTo) ||\n    display.maxLineChanged && cm.options.lineWrapping;\n  op.update = op.mustUpdate &&\n    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n}\n\nfunction endOperation_W1(op) {\n  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n}\n\nfunction endOperation_R2(op) {\n  var cm = op.cm, display = cm.display;\n  if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n  op.barMeasure = measureForScrollbars(cm);\n\n  // If the max line changed since it was last measured, measure it,\n  // and ensure the document's width matches it.\n  // updateDisplay_W2 will use these properties to do the actual resizing\n  if (display.maxLineChanged && !cm.options.lineWrapping) {\n    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n    cm.display.sizerWidth = op.adjustWidthTo;\n    op.barMeasure.scrollWidth =\n      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n  }\n\n  if (op.updatedDisplay || op.selectionChanged)\n    { op.preparedSelection = display.input.prepareSelection(); }\n}\n\nfunction endOperation_W2(op) {\n  var cm = op.cm;\n\n  if (op.adjustWidthTo != null) {\n    cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n    if (op.maxScrollLeft < cm.doc.scrollLeft)\n      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n    cm.display.maxLineChanged = false;\n  }\n\n  var takeFocus = op.focus && op.focus == activeElt();\n  if (op.preparedSelection)\n    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n  if (op.updatedDisplay || op.startHeight != cm.doc.height)\n    { updateScrollbars(cm, op.barMeasure); }\n  if (op.updatedDisplay)\n    { setDocumentHeight(cm, op.barMeasure); }\n\n  if (op.selectionChanged) { restartBlink(cm); }\n\n  if (cm.state.focused && op.updateInput)\n    { cm.display.input.reset(op.typing); }\n  if (takeFocus) { ensureFocus(op.cm); }\n}\n\nfunction endOperation_finish(op) {\n  var cm = op.cm, display = cm.display, doc = cm.doc;\n\n  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n  // Abort mouse wheel delta measurement, when scrolling explicitly\n  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n    { display.wheelStartX = display.wheelStartY = null; }\n\n  // Propagate the scroll position to the actual DOM scroller\n  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n  // If we need to scroll a specific position into view, do so.\n  if (op.scrollToPos) {\n    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n    maybeScrollWindow(cm, rect);\n  }\n\n  // Fire events for markers that are hidden/unidden by editing or\n  // undoing\n  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n  if (hidden) { for (var i = 0; i < hidden.length; ++i)\n    { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n  if (display.wrapper.offsetHeight)\n    { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n  // Fire change events, and delayed event handlers\n  if (op.changeObjs)\n    { signal(cm, \"changes\", cm, op.changeObjs); }\n  if (op.update)\n    { op.update.finish(); }\n}\n\n// Run the given function in an operation\nfunction runInOp(cm, f) {\n  if (cm.curOp) { return f() }\n  startOperation(cm);\n  try { return f() }\n  finally { endOperation(cm); }\n}\n// Wraps a function in an operation. Returns the wrapped function.\nfunction operation(cm, f) {\n  return function() {\n    if (cm.curOp) { return f.apply(cm, arguments) }\n    startOperation(cm);\n    try { return f.apply(cm, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n// Used to add methods to editor and doc instances, wrapping them in\n// operations.\nfunction methodOp(f) {\n  return function() {\n    if (this.curOp) { return f.apply(this, arguments) }\n    startOperation(this);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(this); }\n  }\n}\nfunction docMethodOp(f) {\n  return function() {\n    var cm = this.cm;\n    if (!cm || cm.curOp) { return f.apply(this, arguments) }\n    startOperation(cm);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n\n// Updates the display.view data structure for a given change to the\n// document. From and to are in pre-change coordinates. Lendiff is\n// the amount of lines added or subtracted by the change. This is\n// used for changes that span multiple lines, or change the way\n// lines are divided into visual lines. regLineChange (below)\n// registers single-line changes.\nfunction regChange(cm, from, to, lendiff) {\n  if (from == null) { from = cm.doc.first; }\n  if (to == null) { to = cm.doc.first + cm.doc.size; }\n  if (!lendiff) { lendiff = 0; }\n\n  var display = cm.display;\n  if (lendiff && to < display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers > from))\n    { display.updateLineNumbers = from; }\n\n  cm.curOp.viewChanged = true;\n\n  if (from >= display.viewTo) { // Change after\n    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n      { resetView(cm); }\n  } else if (to <= display.viewFrom) { // Change before\n    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n      resetView(cm);\n    } else {\n      display.viewFrom += lendiff;\n      display.viewTo += lendiff;\n    }\n  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n    resetView(cm);\n  } else if (from <= display.viewFrom) { // Top overlap\n    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cut) {\n      display.view = display.view.slice(cut.index);\n      display.viewFrom = cut.lineN;\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  } else if (to >= display.viewTo) { // Bottom overlap\n    var cut$1 = viewCuttingPoint(cm, from, from, -1);\n    if (cut$1) {\n      display.view = display.view.slice(0, cut$1.index);\n      display.viewTo = cut$1.lineN;\n    } else {\n      resetView(cm);\n    }\n  } else { // Gap in the middle\n    var cutTop = viewCuttingPoint(cm, from, from, -1);\n    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cutTop && cutBot) {\n      display.view = display.view.slice(0, cutTop.index)\n        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n        .concat(display.view.slice(cutBot.index));\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  }\n\n  var ext = display.externalMeasured;\n  if (ext) {\n    if (to < ext.lineN)\n      { ext.lineN += lendiff; }\n    else if (from < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n  }\n}\n\n// Register a change to a single line. Type must be one of \"text\",\n// \"gutter\", \"class\", \"widget\"\nfunction regLineChange(cm, line, type) {\n  cm.curOp.viewChanged = true;\n  var display = cm.display, ext = cm.display.externalMeasured;\n  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n    { display.externalMeasured = null; }\n\n  if (line < display.viewFrom || line >= display.viewTo) { return }\n  var lineView = display.view[findViewIndex(cm, line)];\n  if (lineView.node == null) { return }\n  var arr = lineView.changes || (lineView.changes = []);\n  if (indexOf(arr, type) == -1) { arr.push(type); }\n}\n\n// Clear the view.\nfunction resetView(cm) {\n  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n  cm.display.view = [];\n  cm.display.viewOffset = 0;\n}\n\nfunction viewCuttingPoint(cm, oldN, newN, dir) {\n  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n    { return {index: index, lineN: newN} }\n  var n = cm.display.viewFrom;\n  for (var i = 0; i < index; i++)\n    { n += view[i].size; }\n  if (n != oldN) {\n    if (dir > 0) {\n      if (index == view.length - 1) { return null }\n      diff = (n + view[index].size) - oldN;\n      index++;\n    } else {\n      diff = n - oldN;\n    }\n    oldN += diff; newN += diff;\n  }\n  while (visualLineNo(cm.doc, newN) != newN) {\n    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n    index += dir;\n  }\n  return {index: index, lineN: newN}\n}\n\n// Force the view to cover a given range, adding empty view element\n// or clipping off existing ones as needed.\nfunction adjustView(cm, from, to) {\n  var display = cm.display, view = display.view;\n  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n    display.view = buildViewArray(cm, from, to);\n    display.viewFrom = from;\n  } else {\n    if (display.viewFrom > from)\n      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n    else if (display.viewFrom < from)\n      { display.view = display.view.slice(findViewIndex(cm, from)); }\n    display.viewFrom = from;\n    if (display.viewTo < to)\n      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n    else if (display.viewTo > to)\n      { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n  }\n  display.viewTo = to;\n}\n\n// Count the number of lines in the view whose DOM representation is\n// out of date (or nonexistent).\nfunction countDirtyView(cm) {\n  var view = cm.display.view, dirty = 0;\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n  }\n  return dirty\n}\n\n// HIGHLIGHT WORKER\n\nfunction startWorker(cm, time) {\n  if (cm.doc.highlightFrontier < cm.display.viewTo)\n    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n}\n\nfunction highlightWorker(cm) {\n  var doc = cm.doc;\n  if (doc.highlightFrontier >= cm.display.viewTo) { return }\n  var end = +new Date + cm.options.workTime;\n  var context = getContextBefore(cm, doc.highlightFrontier);\n  var changedLines = [];\n\n  doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n    if (context.line >= cm.display.viewFrom) { // Visible\n      var oldStyles = line.styles;\n      var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n      var highlighted = highlightLine(cm, line, context, true);\n      if (resetState) { context.state = resetState; }\n      line.styles = highlighted.styles;\n      var oldCls = line.styleClasses, newCls = highlighted.classes;\n      if (newCls) { line.styleClasses = newCls; }\n      else if (oldCls) { line.styleClasses = null; }\n      var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n      if (ischange) { changedLines.push(context.line); }\n      line.stateAfter = context.save();\n      context.nextLine();\n    } else {\n      if (line.text.length <= cm.options.maxHighlightLength)\n        { processLine(cm, line.text, context); }\n      line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n      context.nextLine();\n    }\n    if (+new Date > end) {\n      startWorker(cm, cm.options.workDelay);\n      return true\n    }\n  });\n  doc.highlightFrontier = context.line;\n  doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n  if (changedLines.length) { runInOp(cm, function () {\n    for (var i = 0; i < changedLines.length; i++)\n      { regLineChange(cm, changedLines[i], \"text\"); }\n  }); }\n}\n\n// DISPLAY DRAWING\n\nvar DisplayUpdate = function(cm, viewport, force) {\n  var display = cm.display;\n\n  this.viewport = viewport;\n  // Store some values that we'll need later (but don't want to force a relayout for)\n  this.visible = visibleLines(display, cm.doc, viewport);\n  this.editorIsHidden = !display.wrapper.offsetWidth;\n  this.wrapperHeight = display.wrapper.clientHeight;\n  this.wrapperWidth = display.wrapper.clientWidth;\n  this.oldDisplayWidth = displayWidth(cm);\n  this.force = force;\n  this.dims = getDimensions(cm);\n  this.events = [];\n};\n\nDisplayUpdate.prototype.signal = function (emitter, type) {\n  if (hasHandler(emitter, type))\n    { this.events.push(arguments); }\n};\nDisplayUpdate.prototype.finish = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.events.length; i++)\n    { signal.apply(null, this$1.events[i]); }\n};\n\nfunction maybeClipScrollbars(cm) {\n  var display = cm.display;\n  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n    display.heightForcer.style.height = scrollGap(cm) + \"px\";\n    display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n    display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n    display.scrollbarsClipped = true;\n  }\n}\n\nfunction selectionSnapshot(cm) {\n  if (cm.hasFocus()) { return null }\n  var active = activeElt();\n  if (!active || !contains(cm.display.lineDiv, active)) { return null }\n  var result = {activeElt: active};\n  if (window.getSelection) {\n    var sel = window.getSelection();\n    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n      result.anchorNode = sel.anchorNode;\n      result.anchorOffset = sel.anchorOffset;\n      result.focusNode = sel.focusNode;\n      result.focusOffset = sel.focusOffset;\n    }\n  }\n  return result\n}\n\nfunction restoreSelection(snapshot) {\n  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n  snapshot.activeElt.focus();\n  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n    var sel = window.getSelection(), range$$1 = document.createRange();\n    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n    range$$1.collapse(false);\n    sel.removeAllRanges();\n    sel.addRange(range$$1);\n    sel.extend(snapshot.focusNode, snapshot.focusOffset);\n  }\n}\n\n// Does the actual updating of the line display. Bails out\n// (returning false) when there is nothing to be done and forced is\n// false.\nfunction updateDisplayIfNeeded(cm, update) {\n  var display = cm.display, doc = cm.doc;\n\n  if (update.editorIsHidden) {\n    resetView(cm);\n    return false\n  }\n\n  // Bail out if the visible area is already rendered and nothing changed.\n  if (!update.force &&\n      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n      display.renderedView == display.view && countDirtyView(cm) == 0)\n    { return false }\n\n  if (maybeUpdateLineNumberWidth(cm)) {\n    resetView(cm);\n    update.dims = getDimensions(cm);\n  }\n\n  // Compute a suitable new viewport (from & to)\n  var end = doc.first + doc.size;\n  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n  if (sawCollapsedSpans) {\n    from = visualLineNo(cm.doc, from);\n    to = visualLineEndNo(cm.doc, to);\n  }\n\n  var different = from != display.viewFrom || to != display.viewTo ||\n    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n  adjustView(cm, from, to);\n\n  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n  // Position the mover div to align with the current scroll position\n  cm.display.mover.style.top = display.viewOffset + \"px\";\n\n  var toUpdate = countDirtyView(cm);\n  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n    { return false }\n\n  // For big changes, we hide the enclosing element during the\n  // update, since that speeds up the operations on most browsers.\n  var selSnapshot = selectionSnapshot(cm);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n  patchDisplay(cm, display.updateLineNumbers, update.dims);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n  display.renderedView = display.view;\n  // There might have been a widget with a focused element that got\n  // hidden or updated, if so re-focus it.\n  restoreSelection(selSnapshot);\n\n  // Prevent selection and cursors from interfering with the scroll\n  // width and height.\n  removeChildren(display.cursorDiv);\n  removeChildren(display.selectionDiv);\n  display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n  if (different) {\n    display.lastWrapHeight = update.wrapperHeight;\n    display.lastWrapWidth = update.wrapperWidth;\n    startWorker(cm, 400);\n  }\n\n  display.updateLineNumbers = null;\n\n  return true\n}\n\nfunction postUpdateDisplay(cm, update) {\n  var viewport = update.viewport;\n\n  for (var first = true;; first = false) {\n    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n      // Clip forced viewport to actual scrollable area.\n      if (viewport && viewport.top != null)\n        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n      // Updated line heights might result in the drawn area not\n      // actually covering the viewport. Keep looping until it does.\n      update.visible = visibleLines(cm.display, cm.doc, viewport);\n      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n        { break }\n    }\n    if (!updateDisplayIfNeeded(cm, update)) { break }\n    updateHeightsInViewport(cm);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n    update.force = false;\n  }\n\n  update.signal(cm, \"update\", cm);\n  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n    update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n  }\n}\n\nfunction updateDisplaySimple(cm, viewport) {\n  var update = new DisplayUpdate(cm, viewport);\n  if (updateDisplayIfNeeded(cm, update)) {\n    updateHeightsInViewport(cm);\n    postUpdateDisplay(cm, update);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n    update.finish();\n  }\n}\n\n// Sync the actual display DOM structure with display.view, removing\n// nodes for lines that are no longer in view, and creating the ones\n// that are not there yet, and updating the ones that are out of\n// date.\nfunction patchDisplay(cm, updateNumbersFrom, dims) {\n  var display = cm.display, lineNumbers = cm.options.lineNumbers;\n  var container = display.lineDiv, cur = container.firstChild;\n\n  function rm(node) {\n    var next = node.nextSibling;\n    // Works around a throw-scroll bug in OS X Webkit\n    if (webkit && mac && cm.display.currentWheelTarget == node)\n      { node.style.display = \"none\"; }\n    else\n      { node.parentNode.removeChild(node); }\n    return next\n  }\n\n  var view = display.view, lineN = display.viewFrom;\n  // Loop over the elements in the view, syncing cur (the DOM nodes\n  // in display.lineDiv) with the view as we go.\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (lineView.hidden) {\n    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n      var node = buildLineElement(cm, lineView, lineN, dims);\n      container.insertBefore(node, cur);\n    } else { // Already drawn\n      while (cur != lineView.node) { cur = rm(cur); }\n      var updateNumber = lineNumbers && updateNumbersFrom != null &&\n        updateNumbersFrom <= lineN && lineView.lineNumber;\n      if (lineView.changes) {\n        if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n        updateLineForChanges(cm, lineView, lineN, dims);\n      }\n      if (updateNumber) {\n        removeChildren(lineView.lineNumber);\n        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n      }\n      cur = lineView.node.nextSibling;\n    }\n    lineN += lineView.size;\n  }\n  while (cur) { cur = rm(cur); }\n}\n\nfunction updateGutterSpace(cm) {\n  var width = cm.display.gutters.offsetWidth;\n  cm.display.sizer.style.marginLeft = width + \"px\";\n}\n\nfunction setDocumentHeight(cm, measure) {\n  cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n  cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n}\n\n// Rebuild the gutter elements, ensure the margin to the left of the\n// code matches their width.\nfunction updateGutters(cm) {\n  var gutters = cm.display.gutters, specs = cm.options.gutters;\n  removeChildren(gutters);\n  var i = 0;\n  for (; i < specs.length; ++i) {\n    var gutterClass = specs[i];\n    var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n    if (gutterClass == \"CodeMirror-linenumbers\") {\n      cm.display.lineGutter = gElt;\n      gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n    }\n  }\n  gutters.style.display = i ? \"\" : \"none\";\n  updateGutterSpace(cm);\n}\n\n// Make sure the gutters options contains the element\n// \"CodeMirror-linenumbers\" when the lineNumbers option is true.\nfunction setGuttersForLineNumbers(options) {\n  var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n  if (found == -1 && options.lineNumbers) {\n    options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n  } else if (found > -1 && !options.lineNumbers) {\n    options.gutters = options.gutters.slice(0);\n    options.gutters.splice(found, 1);\n  }\n}\n\n// Since the delta values reported on mouse wheel events are\n// unstandardized between browsers and even browser versions, and\n// generally horribly unpredictable, this code starts by measuring\n// the scroll effect that the first few mouse wheel events have,\n// and, from that, detects the way it can convert deltas to pixel\n// offsets afterwards.\n//\n// The reason we want to know the amount a wheel event will scroll\n// is that it gives us a chance to update the display before the\n// actual scrolling happens, reducing flickering.\n\nvar wheelSamples = 0;\nvar wheelPixelsPerUnit = null;\n// Fill in a browser-detected starting value on browsers where we\n// know one. These don't have to be accurate -- the result of them\n// being wrong would just be a slight flicker on the first wheel\n// scroll (if it is large enough).\nif (ie) { wheelPixelsPerUnit = -.53; }\nelse if (gecko) { wheelPixelsPerUnit = 15; }\nelse if (chrome) { wheelPixelsPerUnit = -.7; }\nelse if (safari) { wheelPixelsPerUnit = -1/3; }\n\nfunction wheelEventDelta(e) {\n  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n  else if (dy == null) { dy = e.wheelDelta; }\n  return {x: dx, y: dy}\n}\nfunction wheelEventPixels(e) {\n  var delta = wheelEventDelta(e);\n  delta.x *= wheelPixelsPerUnit;\n  delta.y *= wheelPixelsPerUnit;\n  return delta\n}\n\nfunction onScrollWheel(cm, e) {\n  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n  var display = cm.display, scroll = display.scroller;\n  // Quit if there's nothing to scroll here\n  var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n  var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n  if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n  // Webkit browsers on OS X abort momentum scrolls when the target\n  // of the scroll event is removed from the scrollable element.\n  // This hack (see related code in patchDisplay) makes sure the\n  // element is kept around.\n  if (dy && mac && webkit) {\n    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n      for (var i = 0; i < view.length; i++) {\n        if (view[i].node == cur) {\n          cm.display.currentWheelTarget = cur;\n          break outer\n        }\n      }\n    }\n  }\n\n  // On some browsers, horizontal scrolling will cause redraws to\n  // happen before the gutter has been realigned, causing it to\n  // wriggle around in a most unseemly way. When we have an\n  // estimated pixels/delta value, we just handle horizontal\n  // scrolling entirely here. It'll be slightly off from native, but\n  // better than glitching out.\n  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n    if (dy && canScrollY)\n      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n    // Only prevent default scrolling if vertical scrolling is\n    // actually possible. Otherwise, it causes vertical scroll\n    // jitter on OSX trackpads when deltaX is small and deltaY\n    // is large (issue #3579)\n    if (!dy || (dy && canScrollY))\n      { e_preventDefault(e); }\n    display.wheelStartX = null; // Abort measurement, if in progress\n    return\n  }\n\n  // 'Project' the visible viewport to cover the area that is being\n  // scrolled into view (if we know enough to estimate it).\n  if (dy && wheelPixelsPerUnit != null) {\n    var pixels = dy * wheelPixelsPerUnit;\n    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n    updateDisplaySimple(cm, {top: top, bottom: bot});\n  }\n\n  if (wheelSamples < 20) {\n    if (display.wheelStartX == null) {\n      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n      display.wheelDX = dx; display.wheelDY = dy;\n      setTimeout(function () {\n        if (display.wheelStartX == null) { return }\n        var movedX = scroll.scrollLeft - display.wheelStartX;\n        var movedY = scroll.scrollTop - display.wheelStartY;\n        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n          (movedX && display.wheelDX && movedX / display.wheelDX);\n        display.wheelStartX = display.wheelStartY = null;\n        if (!sample) { return }\n        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n        ++wheelSamples;\n      }, 200);\n    } else {\n      display.wheelDX += dx; display.wheelDY += dy;\n    }\n  }\n}\n\n// Selection objects are immutable. A new one is created every time\n// the selection changes. A selection is one or more non-overlapping\n// (and non-touching) ranges, sorted, and an integer that indicates\n// which one is the primary selection (the one that's scrolled into\n// view, that getCursor returns, etc).\nvar Selection = function(ranges, primIndex) {\n  this.ranges = ranges;\n  this.primIndex = primIndex;\n};\n\nSelection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\nSelection.prototype.equals = function (other) {\n    var this$1 = this;\n\n  if (other == this) { return true }\n  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var here = this$1.ranges[i], there = other.ranges[i];\n    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n  }\n  return true\n};\n\nSelection.prototype.deepCopy = function () {\n    var this$1 = this;\n\n  var out = [];\n  for (var i = 0; i < this.ranges.length; i++)\n    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\n  return new Selection(out, this.primIndex)\n};\n\nSelection.prototype.somethingSelected = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.ranges.length; i++)\n    { if (!this$1.ranges[i].empty()) { return true } }\n  return false\n};\n\nSelection.prototype.contains = function (pos, end) {\n    var this$1 = this;\n\n  if (!end) { end = pos; }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var range = this$1.ranges[i];\n    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n      { return i }\n  }\n  return -1\n};\n\nvar Range = function(anchor, head) {\n  this.anchor = anchor; this.head = head;\n};\n\nRange.prototype.from = function () { return minPos(this.anchor, this.head) };\nRange.prototype.to = function () { return maxPos(this.anchor, this.head) };\nRange.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n// Take an unsorted, potentially overlapping set of ranges, and\n// build a selection out of it. 'Consumes' ranges array (modifying\n// it).\nfunction normalizeSelection(ranges, primIndex) {\n  var prim = ranges[primIndex];\n  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n  primIndex = indexOf(ranges, prim);\n  for (var i = 1; i < ranges.length; i++) {\n    var cur = ranges[i], prev = ranges[i - 1];\n    if (cmp(prev.to(), cur.from()) >= 0) {\n      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n      if (i <= primIndex) { --primIndex; }\n      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n    }\n  }\n  return new Selection(ranges, primIndex)\n}\n\nfunction simpleSelection(anchor, head) {\n  return new Selection([new Range(anchor, head || anchor)], 0)\n}\n\n// Compute the position of the end of a change (its 'to' property\n// refers to the pre-change end).\nfunction changeEnd(change) {\n  if (!change.text) { return change.to }\n  return Pos(change.from.line + change.text.length - 1,\n             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n}\n\n// Adjust a position to refer to the post-change position of the\n// same text, or the end of the change if the change covers it.\nfunction adjustForChange(pos, change) {\n  if (cmp(pos, change.from) < 0) { return pos }\n  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n  return Pos(line, ch)\n}\n\nfunction computeSelAfterChange(doc, change) {\n  var out = [];\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    var range = doc.sel.ranges[i];\n    out.push(new Range(adjustForChange(range.anchor, change),\n                       adjustForChange(range.head, change)));\n  }\n  return normalizeSelection(out, doc.sel.primIndex)\n}\n\nfunction offsetPos(pos, old, nw) {\n  if (pos.line == old.line)\n    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n  else\n    { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n}\n\n// Used by replaceSelections to allow moving the selection to the\n// start or around the replaced test. Hint may be \"start\" or \"around\".\nfunction computeReplacedSel(doc, changes, hint) {\n  var out = [];\n  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n    var from = offsetPos(change.from, oldPrev, newPrev);\n    var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n    oldPrev = change.to;\n    newPrev = to;\n    if (hint == \"around\") {\n      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n      out[i] = new Range(inv ? to : from, inv ? from : to);\n    } else {\n      out[i] = new Range(from, from);\n    }\n  }\n  return new Selection(out, doc.sel.primIndex)\n}\n\n// Used to get the editor into a consistent state again when options change.\n\nfunction loadMode(cm) {\n  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n  resetModeState(cm);\n}\n\nfunction resetModeState(cm) {\n  cm.doc.iter(function (line) {\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n  });\n  cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n  startWorker(cm, 100);\n  cm.state.modeGen++;\n  if (cm.curOp) { regChange(cm); }\n}\n\n// DOCUMENT DATA STRUCTURE\n\n// By default, updates that start and end at the beginning of a line\n// are treated specially, in order to make the association of line\n// widgets and marker elements with the text behave more intuitive.\nfunction isWholeLineUpdate(doc, change) {\n  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n}\n\n// Perform a change on the document data structure.\nfunction updateDoc(doc, change, markedSpans, estimateHeight$$1) {\n  function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n  function update(line, text, spans) {\n    updateLine(line, text, spans, estimateHeight$$1);\n    signalLater(line, \"change\", line, change);\n  }\n  function linesFor(start, end) {\n    var result = [];\n    for (var i = start; i < end; ++i)\n      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\n    return result\n  }\n\n  var from = change.from, to = change.to, text = change.text;\n  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n  // Adjust the line structure\n  if (change.full) {\n    doc.insert(0, linesFor(0, text.length));\n    doc.remove(text.length, doc.size - text.length);\n  } else if (isWholeLineUpdate(doc, change)) {\n    // This is a whole-line replace. Treated specially to make\n    // sure line objects move the way they are supposed to.\n    var added = linesFor(0, text.length - 1);\n    update(lastLine, lastLine.text, lastSpans);\n    if (nlines) { doc.remove(from.line, nlines); }\n    if (added.length) { doc.insert(from.line, added); }\n  } else if (firstLine == lastLine) {\n    if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n    } else {\n      var added$1 = linesFor(1, text.length - 1);\n      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      doc.insert(from.line + 1, added$1);\n    }\n  } else if (text.length == 1) {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n    doc.remove(from.line + 1, nlines);\n  } else {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n    var added$2 = linesFor(1, text.length - 1);\n    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n    doc.insert(from.line + 1, added$2);\n  }\n\n  signalLater(doc, \"change\", doc, change);\n}\n\n// Call f for all linked documents.\nfunction linkedDocs(doc, f, sharedHistOnly) {\n  function propagate(doc, skip, sharedHist) {\n    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n      var rel = doc.linked[i];\n      if (rel.doc == skip) { continue }\n      var shared = sharedHist && rel.sharedHist;\n      if (sharedHistOnly && !shared) { continue }\n      f(rel.doc, shared);\n      propagate(rel.doc, doc, shared);\n    } }\n  }\n  propagate(doc, null, true);\n}\n\n// Attach a document to an editor.\nfunction attachDoc(cm, doc) {\n  if (doc.cm) { throw new Error(\"This document is already in use.\") }\n  cm.doc = doc;\n  doc.cm = cm;\n  estimateLineHeights(cm);\n  loadMode(cm);\n  setDirectionClass(cm);\n  if (!cm.options.lineWrapping) { findMaxLine(cm); }\n  cm.options.mode = doc.modeOption;\n  regChange(cm);\n}\n\nfunction setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n}\n\nfunction directionChanged(cm) {\n  runInOp(cm, function () {\n    setDirectionClass(cm);\n    regChange(cm);\n  });\n}\n\nfunction History(startGen) {\n  // Arrays of change events and selections. Doing something adds an\n  // event to done and clears undo. Undoing moves events from done\n  // to undone, redoing moves them in the other direction.\n  this.done = []; this.undone = [];\n  this.undoDepth = Infinity;\n  // Used to track when changes can be merged into a single undo\n  // event\n  this.lastModTime = this.lastSelTime = 0;\n  this.lastOp = this.lastSelOp = null;\n  this.lastOrigin = this.lastSelOrigin = null;\n  // Used by the isClean() method\n  this.generation = this.maxGeneration = startGen || 1;\n}\n\n// Create a history change event from an updateDoc-style change\n// object.\nfunction historyChangeFromChange(doc, change) {\n  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n  return histChange\n}\n\n// Pop all selection events off the end of a history array. Stop at\n// a change event.\nfunction clearSelectionEvents(array) {\n  while (array.length) {\n    var last = lst(array);\n    if (last.ranges) { array.pop(); }\n    else { break }\n  }\n}\n\n// Find the top change event in the history. Pop off selection\n// events that are in the way.\nfunction lastChangeEvent(hist, force) {\n  if (force) {\n    clearSelectionEvents(hist.done);\n    return lst(hist.done)\n  } else if (hist.done.length && !lst(hist.done).ranges) {\n    return lst(hist.done)\n  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n    hist.done.pop();\n    return lst(hist.done)\n  }\n}\n\n// Register a change in the history. Merges changes that are within\n// a single operation, or are close together with an origin that\n// allows merging (starting with \"+\") into a single event.\nfunction addChangeToHistory(doc, change, selAfter, opId) {\n  var hist = doc.history;\n  hist.undone.length = 0;\n  var time = +new Date, cur;\n  var last;\n\n  if ((hist.lastOp == opId ||\n       hist.lastOrigin == change.origin && change.origin &&\n       ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n        change.origin.charAt(0) == \"*\")) &&\n      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n    // Merge this change into the last event\n    last = lst(cur.changes);\n    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n      // Optimized case for simple insertion -- don't want to add\n      // new changesets for every character typed\n      last.to = changeEnd(change);\n    } else {\n      // Add new sub-event\n      cur.changes.push(historyChangeFromChange(doc, change));\n    }\n  } else {\n    // Can not be merged, start a new event.\n    var before = lst(hist.done);\n    if (!before || !before.ranges)\n      { pushSelectionToHistory(doc.sel, hist.done); }\n    cur = {changes: [historyChangeFromChange(doc, change)],\n           generation: hist.generation};\n    hist.done.push(cur);\n    while (hist.done.length > hist.undoDepth) {\n      hist.done.shift();\n      if (!hist.done[0].ranges) { hist.done.shift(); }\n    }\n  }\n  hist.done.push(selAfter);\n  hist.generation = ++hist.maxGeneration;\n  hist.lastModTime = hist.lastSelTime = time;\n  hist.lastOp = hist.lastSelOp = opId;\n  hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n  if (!last) { signal(doc, \"historyAdded\"); }\n}\n\nfunction selectionEventCanBeMerged(doc, origin, prev, sel) {\n  var ch = origin.charAt(0);\n  return ch == \"*\" ||\n    ch == \"+\" &&\n    prev.ranges.length == sel.ranges.length &&\n    prev.somethingSelected() == sel.somethingSelected() &&\n    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n}\n\n// Called whenever the selection changes, sets the new selection as\n// the pending selection in the history, and pushes the old pending\n// selection into the 'done' array when it was significantly\n// different (in number of selected ranges, emptiness, or time).\nfunction addSelectionToHistory(doc, sel, opId, options) {\n  var hist = doc.history, origin = options && options.origin;\n\n  // A new event is started when the previous origin does not match\n  // the current, or the origins don't allow matching. Origins\n  // starting with * are always merged, those starting with + are\n  // merged when similar and close together in time.\n  if (opId == hist.lastSelOp ||\n      (origin && hist.lastSelOrigin == origin &&\n       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n    { hist.done[hist.done.length - 1] = sel; }\n  else\n    { pushSelectionToHistory(sel, hist.done); }\n\n  hist.lastSelTime = +new Date;\n  hist.lastSelOrigin = origin;\n  hist.lastSelOp = opId;\n  if (options && options.clearRedo !== false)\n    { clearSelectionEvents(hist.undone); }\n}\n\nfunction pushSelectionToHistory(sel, dest) {\n  var top = lst(dest);\n  if (!(top && top.ranges && top.equals(sel)))\n    { dest.push(sel); }\n}\n\n// Used to store marked span information in the history.\nfunction attachLocalSpans(doc, change, from, to) {\n  var existing = change[\"spans_\" + doc.id], n = 0;\n  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n    if (line.markedSpans)\n      { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n    ++n;\n  });\n}\n\n// When un/re-doing restores text containing marked spans, those\n// that have been explicitly cleared should not be restored.\nfunction removeClearedSpans(spans) {\n  if (!spans) { return null }\n  var out;\n  for (var i = 0; i < spans.length; ++i) {\n    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n    else if (out) { out.push(spans[i]); }\n  }\n  return !out ? spans : out.length ? out : null\n}\n\n// Retrieve and filter the old marked spans stored in a change event.\nfunction getOldSpans(doc, change) {\n  var found = change[\"spans_\" + doc.id];\n  if (!found) { return null }\n  var nw = [];\n  for (var i = 0; i < change.text.length; ++i)\n    { nw.push(removeClearedSpans(found[i])); }\n  return nw\n}\n\n// Used for un/re-doing changes from the history. Combines the\n// result of computing the existing spans with the set of spans that\n// existed in the history (so that deleting around a span and then\n// undoing brings back the span).\nfunction mergeOldSpans(doc, change) {\n  var old = getOldSpans(doc, change);\n  var stretched = stretchSpansOverChange(doc, change);\n  if (!old) { return stretched }\n  if (!stretched) { return old }\n\n  for (var i = 0; i < old.length; ++i) {\n    var oldCur = old[i], stretchCur = stretched[i];\n    if (oldCur && stretchCur) {\n      spans: for (var j = 0; j < stretchCur.length; ++j) {\n        var span = stretchCur[j];\n        for (var k = 0; k < oldCur.length; ++k)\n          { if (oldCur[k].marker == span.marker) { continue spans } }\n        oldCur.push(span);\n      }\n    } else if (stretchCur) {\n      old[i] = stretchCur;\n    }\n  }\n  return old\n}\n\n// Used both to provide a JSON-safe object in .getHistory, and, when\n// detaching a document, to split the history in two\nfunction copyHistoryArray(events, newGroup, instantiateSel) {\n  var copy = [];\n  for (var i = 0; i < events.length; ++i) {\n    var event = events[i];\n    if (event.ranges) {\n      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n      continue\n    }\n    var changes = event.changes, newChanges = [];\n    copy.push({changes: newChanges});\n    for (var j = 0; j < changes.length; ++j) {\n      var change = changes[j], m = (void 0);\n      newChanges.push({from: change.from, to: change.to, text: change.text});\n      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n        if (indexOf(newGroup, Number(m[1])) > -1) {\n          lst(newChanges)[prop] = change[prop];\n          delete change[prop];\n        }\n      } } }\n    }\n  }\n  return copy\n}\n\n// The 'scroll' parameter given to many of these indicated whether\n// the new cursor position should be scrolled into view after\n// modifying the selection.\n\n// If shift is held or the extend flag is set, extends a range to\n// include a given position (and optionally a second position).\n// Otherwise, simply returns the range between the given positions.\n// Used for cursor motion and such.\nfunction extendRange(range, head, other, extend) {\n  if (extend) {\n    var anchor = range.anchor;\n    if (other) {\n      var posBefore = cmp(head, anchor) < 0;\n      if (posBefore != (cmp(other, anchor) < 0)) {\n        anchor = head;\n        head = other;\n      } else if (posBefore != (cmp(head, other) < 0)) {\n        head = other;\n      }\n    }\n    return new Range(anchor, head)\n  } else {\n    return new Range(other || head, head)\n  }\n}\n\n// Extend the primary selection range, discard the rest.\nfunction extendSelection(doc, head, other, options, extend) {\n  if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n  setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n}\n\n// Extend all selections (pos is an array of selections with length\n// equal the number of selections)\nfunction extendSelections(doc, heads, options) {\n  var out = [];\n  var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n  for (var i = 0; i < doc.sel.ranges.length; i++)\n    { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n  var newSel = normalizeSelection(out, doc.sel.primIndex);\n  setSelection(doc, newSel, options);\n}\n\n// Updates a single range in the selection.\nfunction replaceOneSelection(doc, i, range, options) {\n  var ranges = doc.sel.ranges.slice(0);\n  ranges[i] = range;\n  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n}\n\n// Reset the selection to a single range.\nfunction setSimpleSelection(doc, anchor, head, options) {\n  setSelection(doc, simpleSelection(anchor, head), options);\n}\n\n// Give beforeSelectionChange handlers a change to influence a\n// selection update.\nfunction filterSelectionChange(doc, sel, options) {\n  var obj = {\n    ranges: sel.ranges,\n    update: function(ranges) {\n      var this$1 = this;\n\n      this.ranges = [];\n      for (var i = 0; i < ranges.length; i++)\n        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                   clipPos(doc, ranges[i].head)); }\n    },\n    origin: options && options.origin\n  };\n  signal(doc, \"beforeSelectionChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }\n  else { return sel }\n}\n\nfunction setSelectionReplaceHistory(doc, sel, options) {\n  var done = doc.history.done, last = lst(done);\n  if (last && last.ranges) {\n    done[done.length - 1] = sel;\n    setSelectionNoUndo(doc, sel, options);\n  } else {\n    setSelection(doc, sel, options);\n  }\n}\n\n// Set a new selection.\nfunction setSelection(doc, sel, options) {\n  setSelectionNoUndo(doc, sel, options);\n  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n}\n\nfunction setSelectionNoUndo(doc, sel, options) {\n  if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n    { sel = filterSelectionChange(doc, sel, options); }\n\n  var bias = options && options.bias ||\n    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n  if (!(options && options.scroll === false) && doc.cm)\n    { ensureCursorVisible(doc.cm); }\n}\n\nfunction setSelectionInner(doc, sel) {\n  if (sel.equals(doc.sel)) { return }\n\n  doc.sel = sel;\n\n  if (doc.cm) {\n    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n    signalCursorActivity(doc.cm);\n  }\n  signalLater(doc, \"cursorActivity\", doc);\n}\n\n// Verify that the selection does not partially select any atomic\n// marked ranges.\nfunction reCheckSelection(doc) {\n  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n}\n\n// Return a selection that does not partially select any atomic\n// ranges.\nfunction skipAtomicInSelection(doc, sel, bias, mayClear) {\n  var out;\n  for (var i = 0; i < sel.ranges.length; i++) {\n    var range = sel.ranges[i];\n    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n    if (out || newAnchor != range.anchor || newHead != range.head) {\n      if (!out) { out = sel.ranges.slice(0, i); }\n      out[i] = new Range(newAnchor, newHead);\n    }\n  }\n  return out ? normalizeSelection(out, sel.primIndex) : sel\n}\n\nfunction skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n  var line = getLine(doc, pos.line);\n  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n    var sp = line.markedSpans[i], m = sp.marker;\n    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n      if (mayClear) {\n        signal(m, \"beforeCursorEnter\");\n        if (m.explicitlyCleared) {\n          if (!line.markedSpans) { break }\n          else {--i; continue}\n        }\n      }\n      if (!m.atomic) { continue }\n\n      if (oldPos) {\n        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\n          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n          { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n      }\n\n      var far = m.find(dir < 0 ? -1 : 1);\n      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\n        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n    }\n  } }\n  return pos\n}\n\n// Ensure a given position is not inside an atomic range.\nfunction skipAtomic(doc, pos, oldPos, bias, mayClear) {\n  var dir = bias || 1;\n  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n  if (!found) {\n    doc.cantEdit = true;\n    return Pos(doc.first, 0)\n  }\n  return found\n}\n\nfunction movePos(doc, pos, dir, line) {\n  if (dir < 0 && pos.ch == 0) {\n    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n    else { return null }\n  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n    else { return null }\n  } else {\n    return new Pos(pos.line, pos.ch + dir)\n  }\n}\n\nfunction selectAll(cm) {\n  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n}\n\n// UPDATING\n\n// Allow \"beforeChange\" event handlers to influence a change\nfunction filterChange(doc, change, update) {\n  var obj = {\n    canceled: false,\n    from: change.from,\n    to: change.to,\n    text: change.text,\n    origin: change.origin,\n    cancel: function () { return obj.canceled = true; }\n  };\n  if (update) { obj.update = function (from, to, text, origin) {\n    if (from) { obj.from = clipPos(doc, from); }\n    if (to) { obj.to = clipPos(doc, to); }\n    if (text) { obj.text = text; }\n    if (origin !== undefined) { obj.origin = origin; }\n  }; }\n  signal(doc, \"beforeChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n  if (obj.canceled) { return null }\n  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n}\n\n// Apply a change to a document, and add it to the document's\n// history, and propagating it to all linked documents.\nfunction makeChange(doc, change, ignoreReadOnly) {\n  if (doc.cm) {\n    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n    if (doc.cm.state.suppressEdits) { return }\n  }\n\n  if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n    change = filterChange(doc, change, true);\n    if (!change) { return }\n  }\n\n  // Possibly split or suppress the update based on the presence\n  // of read-only spans in its range.\n  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n  if (split) {\n    for (var i = split.length - 1; i >= 0; --i)\n      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\n  } else {\n    makeChangeInner(doc, change);\n  }\n}\n\nfunction makeChangeInner(doc, change) {\n  if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n  var selAfter = computeSelAfterChange(doc, change);\n  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n  var rebased = [];\n\n  linkedDocs(doc, function (doc, sharedHist) {\n    if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n      rebaseHist(doc.history, change);\n      rebased.push(doc.history);\n    }\n    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n  });\n}\n\n// Revert a change stored in a document's history.\nfunction makeChangeFromHistory(doc, type, allowSelectionOnly) {\n  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }\n\n  var hist = doc.history, event, selAfter = doc.sel;\n  var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n  // Verify that there is a useable event (so that ctrl-z won't\n  // needlessly clear selection events)\n  var i = 0;\n  for (; i < source.length; i++) {\n    event = source[i];\n    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n      { break }\n  }\n  if (i == source.length) { return }\n  hist.lastOrigin = hist.lastSelOrigin = null;\n\n  for (;;) {\n    event = source.pop();\n    if (event.ranges) {\n      pushSelectionToHistory(event, dest);\n      if (allowSelectionOnly && !event.equals(doc.sel)) {\n        setSelection(doc, event, {clearRedo: false});\n        return\n      }\n      selAfter = event;\n    }\n    else { break }\n  }\n\n  // Build up a reverse change object to add to the opposite history\n  // stack (redo when undoing, and vice versa).\n  var antiChanges = [];\n  pushSelectionToHistory(selAfter, dest);\n  dest.push({changes: antiChanges, generation: hist.generation});\n  hist.generation = event.generation || ++hist.maxGeneration;\n\n  var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n  var loop = function ( i ) {\n    var change = event.changes[i];\n    change.origin = type;\n    if (filter && !filterChange(doc, change, false)) {\n      source.length = 0;\n      return {}\n    }\n\n    antiChanges.push(historyChangeFromChange(doc, change));\n\n    var after = i ? computeSelAfterChange(doc, change) : lst(source);\n    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n    var rebased = [];\n\n    // Propagate to the linked documents\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n    });\n  };\n\n  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n    var returned = loop( i$1 );\n\n    if ( returned ) return returned.v;\n  }\n}\n\n// Sub-views need their line numbers shifted when text is added\n// above or below them in the parent document.\nfunction shiftDoc(doc, distance) {\n  if (distance == 0) { return }\n  doc.first += distance;\n  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n    Pos(range.anchor.line + distance, range.anchor.ch),\n    Pos(range.head.line + distance, range.head.ch)\n  ); }), doc.sel.primIndex);\n  if (doc.cm) {\n    regChange(doc.cm, doc.first, doc.first - distance, distance);\n    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n      { regLineChange(doc.cm, l, \"gutter\"); }\n  }\n}\n\n// More lower-level change function, handling only a single document\n// (not linked ones).\nfunction makeChangeSingleDoc(doc, change, selAfter, spans) {\n  if (doc.cm && !doc.cm.curOp)\n    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n  if (change.to.line < doc.first) {\n    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n    return\n  }\n  if (change.from.line > doc.lastLine()) { return }\n\n  // Clip the change to the size of this doc\n  if (change.from.line < doc.first) {\n    var shift = change.text.length - 1 - (doc.first - change.from.line);\n    shiftDoc(doc, shift);\n    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n              text: [lst(change.text)], origin: change.origin};\n  }\n  var last = doc.lastLine();\n  if (change.to.line > last) {\n    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n              text: [change.text[0]], origin: change.origin};\n  }\n\n  change.removed = getBetween(doc, change.from, change.to);\n\n  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n  else { updateDoc(doc, change, spans); }\n  setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n}\n\n// Handle the interaction of a change to a document with the editor\n// that this document is part of.\nfunction makeChangeSingleDocInEditor(cm, change, spans) {\n  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n  var recomputeMaxLength = false, checkWidthStart = from.line;\n  if (!cm.options.lineWrapping) {\n    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n    doc.iter(checkWidthStart, to.line + 1, function (line) {\n      if (line == display.maxLine) {\n        recomputeMaxLength = true;\n        return true\n      }\n    });\n  }\n\n  if (doc.sel.contains(change.from, change.to) > -1)\n    { signalCursorActivity(cm); }\n\n  updateDoc(doc, change, spans, estimateHeight(cm));\n\n  if (!cm.options.lineWrapping) {\n    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n      var len = lineLength(line);\n      if (len > display.maxLineLength) {\n        display.maxLine = line;\n        display.maxLineLength = len;\n        display.maxLineChanged = true;\n        recomputeMaxLength = false;\n      }\n    });\n    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n  }\n\n  retreatFrontier(doc, from.line);\n  startWorker(cm, 400);\n\n  var lendiff = change.text.length - (to.line - from.line) - 1;\n  // Remember that these lines changed, for updating the display\n  if (change.full)\n    { regChange(cm); }\n  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n    { regLineChange(cm, from.line, \"text\"); }\n  else\n    { regChange(cm, from.line, to.line + 1, lendiff); }\n\n  var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n  if (changeHandler || changesHandler) {\n    var obj = {\n      from: from, to: to,\n      text: change.text,\n      removed: change.removed,\n      origin: change.origin\n    };\n    if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n  }\n  cm.display.selForContextMenu = null;\n}\n\nfunction replaceRange(doc, code, from, to, origin) {\n  if (!to) { to = from; }\n  if (cmp(to, from) < 0) { var assign;\n    (assign = [to, from], from = assign[0], to = assign[1], assign); }\n  if (typeof code == \"string\") { code = doc.splitLines(code); }\n  makeChange(doc, {from: from, to: to, text: code, origin: origin});\n}\n\n// Rebasing/resetting history to deal with externally-sourced changes\n\nfunction rebaseHistSelSingle(pos, from, to, diff) {\n  if (to < pos.line) {\n    pos.line += diff;\n  } else if (from < pos.line) {\n    pos.line = from;\n    pos.ch = 0;\n  }\n}\n\n// Tries to rebase an array of history events given a change in the\n// document. If the change touches the same lines as the event, the\n// event, and everything 'behind' it, is discarded. If the change is\n// before the event, the event's positions are updated. Uses a\n// copy-on-write scheme for the positions, to avoid having to\n// reallocate them all on every rebase, but also avoid problems with\n// shared position objects being unsafely updated.\nfunction rebaseHistArray(array, from, to, diff) {\n  for (var i = 0; i < array.length; ++i) {\n    var sub = array[i], ok = true;\n    if (sub.ranges) {\n      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n      for (var j = 0; j < sub.ranges.length; j++) {\n        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n      }\n      continue\n    }\n    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n      var cur = sub.changes[j$1];\n      if (to < cur.from.line) {\n        cur.from = Pos(cur.from.line + diff, cur.from.ch);\n        cur.to = Pos(cur.to.line + diff, cur.to.ch);\n      } else if (from <= cur.to.line) {\n        ok = false;\n        break\n      }\n    }\n    if (!ok) {\n      array.splice(0, i + 1);\n      i = 0;\n    }\n  }\n}\n\nfunction rebaseHist(hist, change) {\n  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n  rebaseHistArray(hist.done, from, to, diff);\n  rebaseHistArray(hist.undone, from, to, diff);\n}\n\n// Utility for applying a change to a line by handle or number,\n// returning the number and optionally registering the line as\n// changed.\nfunction changeLine(doc, handle, changeType, op) {\n  var no = handle, line = handle;\n  if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n  else { no = lineNo(handle); }\n  if (no == null) { return null }\n  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n  return line\n}\n\n// The document is represented as a BTree consisting of leaves, with\n// chunk of lines in them, and branches, with up to ten leaves or\n// other branch nodes below them. The top node is always a branch\n// node, and is the document object itself (meaning it has\n// additional methods and properties).\n//\n// All nodes have parent links. The tree is used both to go from\n// line numbers to line objects, and to go from objects to numbers.\n// It also indexes by height, and is used to convert between height\n// and line object, and to find the total height of the document.\n//\n// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\nfunction LeafChunk(lines) {\n  var this$1 = this;\n\n  this.lines = lines;\n  this.parent = null;\n  var height = 0;\n  for (var i = 0; i < lines.length; ++i) {\n    lines[i].parent = this$1;\n    height += lines[i].height;\n  }\n  this.height = height;\n}\n\nLeafChunk.prototype = {\n  chunkSize: function chunkSize() { return this.lines.length },\n\n  // Remove the n lines at offset 'at'.\n  removeInner: function removeInner(at, n) {\n    var this$1 = this;\n\n    for (var i = at, e = at + n; i < e; ++i) {\n      var line = this$1.lines[i];\n      this$1.height -= line.height;\n      cleanUpLine(line);\n      signalLater(line, \"delete\");\n    }\n    this.lines.splice(at, n);\n  },\n\n  // Helper used to collapse a small branch into a single leaf.\n  collapse: function collapse(lines) {\n    lines.push.apply(lines, this.lines);\n  },\n\n  // Insert the given array of lines at offset 'at', count them as\n  // having the given height.\n  insertInner: function insertInner(at, lines, height) {\n    var this$1 = this;\n\n    this.height += height;\n    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }\n  },\n\n  // Used to iterate over a part of the tree.\n  iterN: function iterN(at, n, op) {\n    var this$1 = this;\n\n    for (var e = at + n; at < e; ++at)\n      { if (op(this$1.lines[at])) { return true } }\n  }\n};\n\nfunction BranchChunk(children) {\n  var this$1 = this;\n\n  this.children = children;\n  var size = 0, height = 0;\n  for (var i = 0; i < children.length; ++i) {\n    var ch = children[i];\n    size += ch.chunkSize(); height += ch.height;\n    ch.parent = this$1;\n  }\n  this.size = size;\n  this.height = height;\n  this.parent = null;\n}\n\nBranchChunk.prototype = {\n  chunkSize: function chunkSize() { return this.size },\n\n  removeInner: function removeInner(at, n) {\n    var this$1 = this;\n\n    this.size -= n;\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at < sz) {\n        var rm = Math.min(n, sz - at), oldHeight = child.height;\n        child.removeInner(at, rm);\n        this$1.height -= oldHeight - child.height;\n        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\n        if ((n -= rm) == 0) { break }\n        at = 0;\n      } else { at -= sz; }\n    }\n    // If the result is smaller than 25 lines, ensure that it is a\n    // single leaf node.\n    if (this.size - n < 25 &&\n        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n      var lines = [];\n      this.collapse(lines);\n      this.children = [new LeafChunk(lines)];\n      this.children[0].parent = this;\n    }\n  },\n\n  collapse: function collapse(lines) {\n    var this$1 = this;\n\n    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }\n  },\n\n  insertInner: function insertInner(at, lines, height) {\n    var this$1 = this;\n\n    this.size += lines.length;\n    this.height += height;\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at <= sz) {\n        child.insertInner(at, lines, height);\n        if (child.lines && child.lines.length > 50) {\n          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n          var remaining = child.lines.length % 25 + 25;\n          for (var pos = remaining; pos < child.lines.length;) {\n            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n            child.height -= leaf.height;\n            this$1.children.splice(++i, 0, leaf);\n            leaf.parent = this$1;\n          }\n          child.lines = child.lines.slice(0, remaining);\n          this$1.maybeSpill();\n        }\n        break\n      }\n      at -= sz;\n    }\n  },\n\n  // When a node has grown, check whether it should be split.\n  maybeSpill: function maybeSpill() {\n    if (this.children.length <= 10) { return }\n    var me = this;\n    do {\n      var spilled = me.children.splice(me.children.length - 5, 5);\n      var sibling = new BranchChunk(spilled);\n      if (!me.parent) { // Become the parent node\n        var copy = new BranchChunk(me.children);\n        copy.parent = me;\n        me.children = [copy, sibling];\n        me = copy;\n     } else {\n        me.size -= sibling.size;\n        me.height -= sibling.height;\n        var myIndex = indexOf(me.parent.children, me);\n        me.parent.children.splice(myIndex + 1, 0, sibling);\n      }\n      sibling.parent = me.parent;\n    } while (me.children.length > 10)\n    me.parent.maybeSpill();\n  },\n\n  iterN: function iterN(at, n, op) {\n    var this$1 = this;\n\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at < sz) {\n        var used = Math.min(n, sz - at);\n        if (child.iterN(at, used, op)) { return true }\n        if ((n -= used) == 0) { break }\n        at = 0;\n      } else { at -= sz; }\n    }\n  }\n};\n\n// Line widgets are block elements displayed above or below a line.\n\nvar LineWidget = function(doc, node, options) {\n  var this$1 = this;\n\n  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n    { this$1[opt] = options[opt]; } } }\n  this.doc = doc;\n  this.node = node;\n};\n\nLineWidget.prototype.clear = function () {\n    var this$1 = this;\n\n  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n  if (no == null || !ws) { return }\n  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\n  if (!ws.length) { line.widgets = null; }\n  var height = widgetHeight(this);\n  updateLineHeight(line, Math.max(0, line.height - height));\n  if (cm) {\n    runInOp(cm, function () {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n    });\n    signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n  }\n};\n\nLineWidget.prototype.changed = function () {\n    var this$1 = this;\n\n  var oldH = this.height, cm = this.doc.cm, line = this.line;\n  this.height = null;\n  var diff = widgetHeight(this) - oldH;\n  if (!diff) { return }\n  updateLineHeight(line, line.height + diff);\n  if (cm) {\n    runInOp(cm, function () {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n      signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n    });\n  }\n};\neventMixin(LineWidget);\n\nfunction adjustScrollWhenAboveVisible(cm, line, diff) {\n  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n    { addToScrollTop(cm, diff); }\n}\n\nfunction addLineWidget(doc, handle, node, options) {\n  var widget = new LineWidget(doc, node, options);\n  var cm = doc.cm;\n  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n  changeLine(doc, handle, \"widget\", function (line) {\n    var widgets = line.widgets || (line.widgets = []);\n    if (widget.insertAt == null) { widgets.push(widget); }\n    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\n    widget.line = line;\n    if (cm && !lineIsHidden(doc, line)) {\n      var aboveVisible = heightAtLine(line) < doc.scrollTop;\n      updateLineHeight(line, line.height + widgetHeight(widget));\n      if (aboveVisible) { addToScrollTop(cm, widget.height); }\n      cm.curOp.forceUpdate = true;\n    }\n    return true\n  });\n  signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle));\n  return widget\n}\n\n// TEXTMARKERS\n\n// Created with markText and setBookmark methods. A TextMarker is a\n// handle that can be used to clear or find a marked position in the\n// document. Line objects hold arrays (markedSpans) containing\n// {from, to, marker} object pointing to such marker objects, and\n// indicating that such a marker is present on that line. Multiple\n// lines may point to the same marker when it spans across lines.\n// The spans will have null for their from/to properties when the\n// marker continues beyond the start/end of the line. Markers have\n// links back to the lines they currently touch.\n\n// Collapsed markers have unique ids, in order to be able to order\n// them, which is needed for uniquely determining an outer marker\n// when they overlap (they may nest, but not partially overlap).\nvar nextMarkerId = 0;\n\nvar TextMarker = function(doc, type) {\n  this.lines = [];\n  this.type = type;\n  this.doc = doc;\n  this.id = ++nextMarkerId;\n};\n\n// Clear the marker.\nTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  var cm = this.doc.cm, withOp = cm && !cm.curOp;\n  if (withOp) { startOperation(cm); }\n  if (hasHandler(this, \"clear\")) {\n    var found = this.find();\n    if (found) { signalLater(this, \"clear\", found.from, found.to); }\n  }\n  var min = null, max = null;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n    else if (cm) {\n      if (span.to != null) { max = lineNo(line); }\n      if (span.from != null) { min = lineNo(line); }\n    }\n    line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\n      { updateLineHeight(line, textHeight(cm.display)); }\n  }\n  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\n    if (len > cm.display.maxLineLength) {\n      cm.display.maxLine = visual;\n      cm.display.maxLineLength = len;\n      cm.display.maxLineChanged = true;\n    }\n  } }\n\n  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n  this.lines.length = 0;\n  this.explicitlyCleared = true;\n  if (this.atomic && this.doc.cantEdit) {\n    this.doc.cantEdit = false;\n    if (cm) { reCheckSelection(cm.doc); }\n  }\n  if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n  if (withOp) { endOperation(cm); }\n  if (this.parent) { this.parent.clear(); }\n};\n\n// Find the position of the marker in the document. Returns a {from,\n// to} object by default. Side can be passed to get a specific side\n// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n// Pos objects returned contain a line object, rather than a line\n// number (used to prevent looking up the same line twice).\nTextMarker.prototype.find = function (side, lineObj) {\n    var this$1 = this;\n\n  if (side == null && this.type == \"bookmark\") { side = 1; }\n  var from, to;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (span.from != null) {\n      from = Pos(lineObj ? line : lineNo(line), span.from);\n      if (side == -1) { return from }\n    }\n    if (span.to != null) {\n      to = Pos(lineObj ? line : lineNo(line), span.to);\n      if (side == 1) { return to }\n    }\n  }\n  return from && {from: from, to: to}\n};\n\n// Signals that the marker's widget changed, and surrounding layout\n// should be recomputed.\nTextMarker.prototype.changed = function () {\n    var this$1 = this;\n\n  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n  if (!pos || !cm) { return }\n  runInOp(cm, function () {\n    var line = pos.line, lineN = lineNo(pos.line);\n    var view = findViewForLine(cm, lineN);\n    if (view) {\n      clearLineMeasurementCacheFor(view);\n      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n    }\n    cm.curOp.updateMaxLine = true;\n    if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n      var oldHeight = widget.height;\n      widget.height = null;\n      var dHeight = widgetHeight(widget) - oldHeight;\n      if (dHeight)\n        { updateLineHeight(line, line.height + dHeight); }\n    }\n    signalLater(cm, \"markerChanged\", cm, this$1);\n  });\n};\n\nTextMarker.prototype.attachLine = function (line) {\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;\n    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n  }\n  this.lines.push(line);\n};\n\nTextMarker.prototype.detachLine = function (line) {\n  this.lines.splice(indexOf(this.lines, line), 1);\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n  }\n};\neventMixin(TextMarker);\n\n// Create a marker, wire it up to the right lines, and\nfunction markText(doc, from, to, options, type) {\n  // Shared markers (across linked documents) are handled separately\n  // (markTextShared will call out to this again, once per\n  // document).\n  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n  // Ensure we are in an operation.\n  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n  var marker = new TextMarker(doc, type), diff = cmp(from, to);\n  if (options) { copyObj(options, marker, false); }\n  // Don't connect empty markers unless clearWhenEmpty is false\n  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n    { return marker }\n  if (marker.replacedWith) {\n    // Showing up as a widget implies collapsed (widget replaces text)\n    marker.collapsed = true;\n    marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n  }\n  if (marker.collapsed) {\n    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n      { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n    seeCollapsedSpans();\n  }\n\n  if (marker.addToHistory)\n    { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n  var curLine = from.line, cm = doc.cm, updateMaxLine;\n  doc.iter(curLine, to.line + 1, function (line) {\n    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n      { updateMaxLine = true; }\n    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n    addMarkedSpan(line, new MarkedSpan(marker,\n                                       curLine == from.line ? from.ch : null,\n                                       curLine == to.line ? to.ch : null));\n    ++curLine;\n  });\n  // lineIsHidden depends on the presence of the spans, so needs a second pass\n  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n  }); }\n\n  if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n  if (marker.readOnly) {\n    seeReadOnlySpans();\n    if (doc.history.done.length || doc.history.undone.length)\n      { doc.clearHistory(); }\n  }\n  if (marker.collapsed) {\n    marker.id = ++nextMarkerId;\n    marker.atomic = true;\n  }\n  if (cm) {\n    // Sync editor state\n    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n    if (marker.collapsed)\n      { regChange(cm, from.line, to.line + 1); }\n    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n    if (marker.atomic) { reCheckSelection(cm.doc); }\n    signalLater(cm, \"markerAdded\", cm, marker);\n  }\n  return marker\n}\n\n// SHARED TEXTMARKERS\n\n// A shared marker spans multiple linked documents. It is\n// implemented as a meta-marker-object controlling multiple normal\n// markers.\nvar SharedTextMarker = function(markers, primary) {\n  var this$1 = this;\n\n  this.markers = markers;\n  this.primary = primary;\n  for (var i = 0; i < markers.length; ++i)\n    { markers[i].parent = this$1; }\n};\n\nSharedTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  this.explicitlyCleared = true;\n  for (var i = 0; i < this.markers.length; ++i)\n    { this$1.markers[i].clear(); }\n  signalLater(this, \"clear\");\n};\n\nSharedTextMarker.prototype.find = function (side, lineObj) {\n  return this.primary.find(side, lineObj)\n};\neventMixin(SharedTextMarker);\n\nfunction markTextShared(doc, from, to, options, type) {\n  options = copyObj(options);\n  options.shared = false;\n  var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n  var widget = options.widgetNode;\n  linkedDocs(doc, function (doc) {\n    if (widget) { options.widgetNode = widget.cloneNode(true); }\n    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n    for (var i = 0; i < doc.linked.length; ++i)\n      { if (doc.linked[i].isParent) { return } }\n    primary = lst(markers);\n  });\n  return new SharedTextMarker(markers, primary)\n}\n\nfunction findSharedMarkers(doc) {\n  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n}\n\nfunction copySharedMarkers(doc, markers) {\n  for (var i = 0; i < markers.length; i++) {\n    var marker = markers[i], pos = marker.find();\n    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n    if (cmp(mFrom, mTo)) {\n      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n      marker.markers.push(subMark);\n      subMark.parent = marker;\n    }\n  }\n}\n\nfunction detachSharedMarkers(markers) {\n  var loop = function ( i ) {\n    var marker = markers[i], linked = [marker.primary.doc];\n    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n    for (var j = 0; j < marker.markers.length; j++) {\n      var subMarker = marker.markers[j];\n      if (indexOf(linked, subMarker.doc) == -1) {\n        subMarker.parent = null;\n        marker.markers.splice(j--, 1);\n      }\n    }\n  };\n\n  for (var i = 0; i < markers.length; i++) loop( i );\n}\n\nvar nextDocId = 0;\nvar Doc = function(text, mode, firstLine, lineSep, direction) {\n  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n  if (firstLine == null) { firstLine = 0; }\n\n  BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n  this.first = firstLine;\n  this.scrollTop = this.scrollLeft = 0;\n  this.cantEdit = false;\n  this.cleanGeneration = 1;\n  this.modeFrontier = this.highlightFrontier = firstLine;\n  var start = Pos(firstLine, 0);\n  this.sel = simpleSelection(start);\n  this.history = new History(null);\n  this.id = ++nextDocId;\n  this.modeOption = mode;\n  this.lineSep = lineSep;\n  this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n  this.extend = false;\n\n  if (typeof text == \"string\") { text = this.splitLines(text); }\n  updateDoc(this, {from: start, to: start, text: text});\n  setSelection(this, simpleSelection(start), sel_dontScroll);\n};\n\nDoc.prototype = createObj(BranchChunk.prototype, {\n  constructor: Doc,\n  // Iterate over the document. Supports two forms -- with only one\n  // argument, it calls that for each line in the document. With\n  // three, it iterates over the range given by the first two (with\n  // the second being non-inclusive).\n  iter: function(from, to, op) {\n    if (op) { this.iterN(from - this.first, to - from, op); }\n    else { this.iterN(this.first, this.first + this.size, from); }\n  },\n\n  // Non-public interface for adding and removing lines.\n  insert: function(at, lines) {\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n    this.insertInner(at - this.first, lines, height);\n  },\n  remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n  // From here, the methods are part of the public interface. Most\n  // are also available from CodeMirror (editor) instances.\n\n  getValue: function(lineSep) {\n    var lines = getLines(this, this.first, this.first + this.size);\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n  setValue: docMethodOp(function(code) {\n    var top = Pos(this.first, 0), last = this.first + this.size - 1;\n    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                      text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n    if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n    setSelection(this, simpleSelection(top), sel_dontScroll);\n  }),\n  replaceRange: function(code, from, to, origin) {\n    from = clipPos(this, from);\n    to = to ? clipPos(this, to) : from;\n    replaceRange(this, code, from, to, origin);\n  },\n  getRange: function(from, to, lineSep) {\n    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n\n  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n  getLineNumber: function(line) {return lineNo(line)},\n\n  getLineHandleVisualStart: function(line) {\n    if (typeof line == \"number\") { line = getLine(this, line); }\n    return visualLine(line)\n  },\n\n  lineCount: function() {return this.size},\n  firstLine: function() {return this.first},\n  lastLine: function() {return this.first + this.size - 1},\n\n  clipPos: function(pos) {return clipPos(this, pos)},\n\n  getCursor: function(start) {\n    var range$$1 = this.sel.primary(), pos;\n    if (start == null || start == \"head\") { pos = range$$1.head; }\n    else if (start == \"anchor\") { pos = range$$1.anchor; }\n    else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\n    else { pos = range$$1.from(); }\n    return pos\n  },\n  listSelections: function() { return this.sel.ranges },\n  somethingSelected: function() {return this.sel.somethingSelected()},\n\n  setCursor: docMethodOp(function(line, ch, options) {\n    setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n  }),\n  setSelection: docMethodOp(function(anchor, head, options) {\n    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n  }),\n  extendSelection: docMethodOp(function(head, other, options) {\n    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n  }),\n  extendSelections: docMethodOp(function(heads, options) {\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  extendSelectionsBy: docMethodOp(function(f, options) {\n    var heads = map(this.sel.ranges, f);\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  setSelections: docMethodOp(function(ranges, primary, options) {\n    var this$1 = this;\n\n    if (!ranges.length) { return }\n    var out = [];\n    for (var i = 0; i < ranges.length; i++)\n      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\n                         clipPos(this$1, ranges[i].head)); }\n    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n    setSelection(this, normalizeSelection(out, primary), options);\n  }),\n  addSelection: docMethodOp(function(anchor, head, options) {\n    var ranges = this.sel.ranges.slice(0);\n    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n  }),\n\n  getSelection: function(lineSep) {\n    var this$1 = this;\n\n    var ranges = this.sel.ranges, lines;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      lines = lines ? lines.concat(sel) : sel;\n    }\n    if (lineSep === false) { return lines }\n    else { return lines.join(lineSep || this.lineSeparator()) }\n  },\n  getSelections: function(lineSep) {\n    var this$1 = this;\n\n    var parts = [], ranges = this.sel.ranges;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\n      parts[i] = sel;\n    }\n    return parts\n  },\n  replaceSelection: function(code, collapse, origin) {\n    var dup = [];\n    for (var i = 0; i < this.sel.ranges.length; i++)\n      { dup[i] = code; }\n    this.replaceSelections(dup, collapse, origin || \"+input\");\n  },\n  replaceSelections: docMethodOp(function(code, collapse, origin) {\n    var this$1 = this;\n\n    var changes = [], sel = this.sel;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range$$1 = sel.ranges[i];\n      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\n    }\n    var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n      { makeChange(this$1, changes[i$1]); }\n    if (newSel) { setSelectionReplaceHistory(this, newSel); }\n    else if (this.cm) { ensureCursorVisible(this.cm); }\n  }),\n  undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n  redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n  setExtending: function(val) {this.extend = val;},\n  getExtending: function() {return this.extend},\n\n  historySize: function() {\n    var hist = this.history, done = 0, undone = 0;\n    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n    return {undo: done, redo: undone}\n  },\n  clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n  markClean: function() {\n    this.cleanGeneration = this.changeGeneration(true);\n  },\n  changeGeneration: function(forceSplit) {\n    if (forceSplit)\n      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n    return this.history.generation\n  },\n  isClean: function (gen) {\n    return this.history.generation == (gen || this.cleanGeneration)\n  },\n\n  getHistory: function() {\n    return {done: copyHistoryArray(this.history.done),\n            undone: copyHistoryArray(this.history.undone)}\n  },\n  setHistory: function(histData) {\n    var hist = this.history = new History(this.history.maxGeneration);\n    hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n  },\n\n  setGutterMarker: docMethodOp(function(line, gutterID, value) {\n    return changeLine(this, line, \"gutter\", function (line) {\n      var markers = line.gutterMarkers || (line.gutterMarkers = {});\n      markers[gutterID] = value;\n      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n      return true\n    })\n  }),\n\n  clearGutter: docMethodOp(function(gutterID) {\n    var this$1 = this;\n\n    this.iter(function (line) {\n      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n        changeLine(this$1, line, \"gutter\", function () {\n          line.gutterMarkers[gutterID] = null;\n          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n          return true\n        });\n      }\n    });\n  }),\n\n  lineInfo: function(line) {\n    var n;\n    if (typeof line == \"number\") {\n      if (!isLine(this, line)) { return null }\n      n = line;\n      line = getLine(this, line);\n      if (!line) { return null }\n    } else {\n      n = lineNo(line);\n      if (n == null) { return null }\n    }\n    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n            widgets: line.widgets}\n  },\n\n  addLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      if (!line[prop]) { line[prop] = cls; }\n      else if (classTest(cls).test(line[prop])) { return false }\n      else { line[prop] += \" \" + cls; }\n      return true\n    })\n  }),\n  removeLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      var cur = line[prop];\n      if (!cur) { return false }\n      else if (cls == null) { line[prop] = null; }\n      else {\n        var found = cur.match(classTest(cls));\n        if (!found) { return false }\n        var end = found.index + found[0].length;\n        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n      }\n      return true\n    })\n  }),\n\n  addLineWidget: docMethodOp(function(handle, node, options) {\n    return addLineWidget(this, handle, node, options)\n  }),\n  removeLineWidget: function(widget) { widget.clear(); },\n\n  markText: function(from, to, options) {\n    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n  },\n  setBookmark: function(pos, options) {\n    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                    insertLeft: options && options.insertLeft,\n                    clearWhenEmpty: false, shared: options && options.shared,\n                    handleMouseEvents: options && options.handleMouseEvents};\n    pos = clipPos(this, pos);\n    return markText(this, pos, pos, realOpts, \"bookmark\")\n  },\n  findMarksAt: function(pos) {\n    pos = clipPos(this, pos);\n    var markers = [], spans = getLine(this, pos.line).markedSpans;\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if ((span.from == null || span.from <= pos.ch) &&\n          (span.to == null || span.to >= pos.ch))\n        { markers.push(span.marker.parent || span.marker); }\n    } }\n    return markers\n  },\n  findMarks: function(from, to, filter) {\n    from = clipPos(this, from); to = clipPos(this, to);\n    var found = [], lineNo$$1 = from.line;\n    this.iter(from.line, to.line + 1, function (line) {\n      var spans = line.markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; i++) {\n        var span = spans[i];\n        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\n              span.from == null && lineNo$$1 != from.line ||\n              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\n            (!filter || filter(span.marker)))\n          { found.push(span.marker.parent || span.marker); }\n      } }\n      ++lineNo$$1;\n    });\n    return found\n  },\n  getAllMarks: function() {\n    var markers = [];\n    this.iter(function (line) {\n      var sps = line.markedSpans;\n      if (sps) { for (var i = 0; i < sps.length; ++i)\n        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n    });\n    return markers\n  },\n\n  posFromIndex: function(off) {\n    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\n    this.iter(function (line) {\n      var sz = line.text.length + sepSize;\n      if (sz > off) { ch = off; return true }\n      off -= sz;\n      ++lineNo$$1;\n    });\n    return clipPos(this, Pos(lineNo$$1, ch))\n  },\n  indexFromPos: function (coords) {\n    coords = clipPos(this, coords);\n    var index = coords.ch;\n    if (coords.line < this.first || coords.ch < 0) { return 0 }\n    var sepSize = this.lineSeparator().length;\n    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n      index += line.text.length + sepSize;\n    });\n    return index\n  },\n\n  copy: function(copyHistory) {\n    var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                      this.modeOption, this.first, this.lineSep, this.direction);\n    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n    doc.sel = this.sel;\n    doc.extend = false;\n    if (copyHistory) {\n      doc.history.undoDepth = this.history.undoDepth;\n      doc.setHistory(this.getHistory());\n    }\n    return doc\n  },\n\n  linkedDoc: function(options) {\n    if (!options) { options = {}; }\n    var from = this.first, to = this.first + this.size;\n    if (options.from != null && options.from > from) { from = options.from; }\n    if (options.to != null && options.to < to) { to = options.to; }\n    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n    if (options.sharedHist) { copy.history = this.history\n    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n    copySharedMarkers(copy, findSharedMarkers(this));\n    return copy\n  },\n  unlinkDoc: function(other) {\n    var this$1 = this;\n\n    if (other instanceof CodeMirror$1) { other = other.doc; }\n    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n      var link = this$1.linked[i];\n      if (link.doc != other) { continue }\n      this$1.linked.splice(i, 1);\n      other.unlinkDoc(this$1);\n      detachSharedMarkers(findSharedMarkers(this$1));\n      break\n    } }\n    // If the histories were shared, split them again\n    if (other.history == this.history) {\n      var splitIds = [other.id];\n      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n      other.history = new History(null);\n      other.history.done = copyHistoryArray(this.history.done, splitIds);\n      other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n    }\n  },\n  iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n  getMode: function() {return this.mode},\n  getEditor: function() {return this.cm},\n\n  splitLines: function(str) {\n    if (this.lineSep) { return str.split(this.lineSep) }\n    return splitLinesAuto(str)\n  },\n  lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n  setDirection: docMethodOp(function (dir) {\n    if (dir != \"rtl\") { dir = \"ltr\"; }\n    if (dir == this.direction) { return }\n    this.direction = dir;\n    this.iter(function (line) { return line.order = null; });\n    if (this.cm) { directionChanged(this.cm); }\n  })\n});\n\n// Public alias.\nDoc.prototype.eachLine = Doc.prototype.iter;\n\n// Kludge to work around strange IE behavior where it'll sometimes\n// re-fire a series of drag-related events right after the drop (#1551)\nvar lastDrop = 0;\n\nfunction onDrop(e) {\n  var cm = this;\n  clearDragCursor(cm);\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n    { return }\n  e_preventDefault(e);\n  if (ie) { lastDrop = +new Date; }\n  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n  if (!pos || cm.isReadOnly()) { return }\n  // Might be a file drop, in which case we simply extract the text\n  // and insert it.\n  if (files && files.length && window.FileReader && window.File) {\n    var n = files.length, text = Array(n), read = 0;\n    var loadFile = function (file, i) {\n      if (cm.options.allowDropFileTypes &&\n          indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n        { return }\n\n      var reader = new FileReader;\n      reader.onload = operation(cm, function () {\n        var content = reader.result;\n        if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\n        text[i] = content;\n        if (++read == n) {\n          pos = clipPos(cm.doc, pos);\n          var change = {from: pos, to: pos,\n                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                        origin: \"paste\"};\n          makeChange(cm.doc, change);\n          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n        }\n      });\n      reader.readAsText(file);\n    };\n    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\n  } else { // Normal drop\n    // Don't do a replace if the drop happened inside of the selected text.\n    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n      cm.state.draggingText(e);\n      // Ensure the editor is re-focused\n      setTimeout(function () { return cm.display.input.focus(); }, 20);\n      return\n    }\n    try {\n      var text$1 = e.dataTransfer.getData(\"Text\");\n      if (text$1) {\n        var selected;\n        if (cm.state.draggingText && !cm.state.draggingText.copy)\n          { selected = cm.listSelections(); }\n        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n          { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n        cm.replaceSelection(text$1, \"around\", \"paste\");\n        cm.display.input.focus();\n      }\n    }\n    catch(e){}\n  }\n}\n\nfunction onDragStart(cm, e) {\n  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n  e.dataTransfer.setData(\"Text\", cm.getSelection());\n  e.dataTransfer.effectAllowed = \"copyMove\";\n\n  // Use dummy image instead of default browsers image.\n  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n  if (e.dataTransfer.setDragImage && !safari) {\n    var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n    img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    if (presto) {\n      img.width = img.height = 1;\n      cm.display.wrapper.appendChild(img);\n      // Force a relayout, or Opera won't use our image for some obscure reason\n      img._top = img.offsetTop;\n    }\n    e.dataTransfer.setDragImage(img, 0, 0);\n    if (presto) { img.parentNode.removeChild(img); }\n  }\n}\n\nfunction onDragOver(cm, e) {\n  var pos = posFromMouse(cm, e);\n  if (!pos) { return }\n  var frag = document.createDocumentFragment();\n  drawSelectionCursor(cm, pos, frag);\n  if (!cm.display.dragCursor) {\n    cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n  }\n  removeChildrenAndAdd(cm.display.dragCursor, frag);\n}\n\nfunction clearDragCursor(cm) {\n  if (cm.display.dragCursor) {\n    cm.display.lineSpace.removeChild(cm.display.dragCursor);\n    cm.display.dragCursor = null;\n  }\n}\n\n// These must be handled carefully, because naively registering a\n// handler for each editor will cause the editors to never be\n// garbage collected.\n\nfunction forEachCodeMirror(f) {\n  if (!document.getElementsByClassName) { return }\n  var byClass = document.getElementsByClassName(\"CodeMirror\");\n  for (var i = 0; i < byClass.length; i++) {\n    var cm = byClass[i].CodeMirror;\n    if (cm) { f(cm); }\n  }\n}\n\nvar globalsRegistered = false;\nfunction ensureGlobalHandlers() {\n  if (globalsRegistered) { return }\n  registerGlobalHandlers();\n  globalsRegistered = true;\n}\nfunction registerGlobalHandlers() {\n  // When the window resizes, we need to refresh active editors.\n  var resizeTimer;\n  on(window, \"resize\", function () {\n    if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n      resizeTimer = null;\n      forEachCodeMirror(onResize);\n    }, 100); }\n  });\n  // When the window loses focus, we want to show the editor as blurred\n  on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n}\n// Called when the window resizes\nfunction onResize(cm) {\n  var d = cm.display;\n  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n    { return }\n  // Might be a text scaling operation, clear size caches.\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n  d.scrollbarsClipped = false;\n  cm.setSize();\n}\n\nvar keyNames = {\n  3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n  46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n  106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n  173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n  221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n  63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n};\n\n// Number keys\nfor (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n// Alphabetic keys\nfor (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n// Function keys\nfor (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\nvar keyMap = {};\n\nkeyMap.basic = {\n  \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n  \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n  \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n  \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n  \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n  \"Esc\": \"singleSelection\"\n};\n// Note that the save and find-related commands aren't defined by\n// default. User code or addons can define them. Unknown commands\n// are simply ignored.\nkeyMap.pcDefault = {\n  \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n  \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n  \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n  \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n  \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n  \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n  \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n  fallthrough: \"basic\"\n};\n// Very basic readline/emacs-style bindings, which are standard on Mac.\nkeyMap.emacsy = {\n  \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n  \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n  \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n  \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n  \"Ctrl-O\": \"openLine\"\n};\nkeyMap.macDefault = {\n  \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n  \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n  \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n  \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n  \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n  \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n  \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n  fallthrough: [\"basic\", \"emacsy\"]\n};\nkeyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n// KEYMAP DISPATCH\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/);\n  name = parts[parts.length - 1];\n  var alt, ctrl, shift, cmd;\n  for (var i = 0; i < parts.length - 1; i++) {\n    var mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n    else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n    else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n    else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n  }\n  if (alt) { name = \"Alt-\" + name; }\n  if (ctrl) { name = \"Ctrl-\" + name; }\n  if (cmd) { name = \"Cmd-\" + name; }\n  if (shift) { name = \"Shift-\" + name; }\n  return name\n}\n\n// This is a kludge to keep keymaps mostly working as raw objects\n// (backwards compatibility) while at the same time support features\n// like normalization and multi-stroke key bindings. It compiles a\n// new normalized keymap, and then updates the old object to reflect\n// this.\nfunction normalizeKeyMap(keymap) {\n  var copy = {};\n  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n    var value = keymap[keyname];\n    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n    if (value == \"...\") { delete keymap[keyname]; continue }\n\n    var keys = map(keyname.split(\" \"), normalizeKeyName);\n    for (var i = 0; i < keys.length; i++) {\n      var val = (void 0), name = (void 0);\n      if (i == keys.length - 1) {\n        name = keys.join(\" \");\n        val = value;\n      } else {\n        name = keys.slice(0, i + 1).join(\" \");\n        val = \"...\";\n      }\n      var prev = copy[name];\n      if (!prev) { copy[name] = val; }\n      else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n    }\n    delete keymap[keyname];\n  } }\n  for (var prop in copy) { keymap[prop] = copy[prop]; }\n  return keymap\n}\n\nfunction lookupKey(key, map$$1, handle, context) {\n  map$$1 = getKeyMap(map$$1);\n  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\n  if (found === false) { return \"nothing\" }\n  if (found === \"...\") { return \"multi\" }\n  if (found != null && handle(found)) { return \"handled\" }\n\n  if (map$$1.fallthrough) {\n    if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\n      { return lookupKey(key, map$$1.fallthrough, handle, context) }\n    for (var i = 0; i < map$$1.fallthrough.length; i++) {\n      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\n      if (result) { return result }\n    }\n  }\n}\n\n// Modifier key presses don't count as 'real' key presses for the\n// purpose of keymap fallthrough.\nfunction isModifierKey(value) {\n  var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n  return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n}\n\nfunction addModifierNames(name, event, noShift) {\n  var base = name;\n  if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") { name = \"Cmd-\" + name; }\n  if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n  return name\n}\n\n// Look up the name of a key as indicated by an event object.\nfunction keyName(event, noShift) {\n  if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n  var name = keyNames[event.keyCode];\n  if (name == null || event.altGraphKey) { return false }\n  return addModifierNames(name, event, noShift)\n}\n\nfunction getKeyMap(val) {\n  return typeof val == \"string\" ? keyMap[val] : val\n}\n\n// Helper for deleting text near the selection(s), used to implement\n// backspace, delete, and similar functionality.\nfunction deleteNearSelection(cm, compute) {\n  var ranges = cm.doc.sel.ranges, kill = [];\n  // Build up a set of ranges to kill first, merging overlapping\n  // ranges.\n  for (var i = 0; i < ranges.length; i++) {\n    var toKill = compute(ranges[i]);\n    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n      var replaced = kill.pop();\n      if (cmp(replaced.from, toKill.from) < 0) {\n        toKill.from = replaced.from;\n        break\n      }\n    }\n    kill.push(toKill);\n  }\n  // Next, remove those actual ranges.\n  runInOp(cm, function () {\n    for (var i = kill.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n    ensureCursorVisible(cm);\n  });\n}\n\nfunction moveCharLogically(line, ch, dir) {\n  var target = skipExtendingChars(line.text, ch + dir, dir);\n  return target < 0 || target > line.text.length ? null : target\n}\n\nfunction moveLogically(line, start, dir) {\n  var ch = moveCharLogically(line, start.ch, dir);\n  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n}\n\nfunction endOfLine(visually, cm, lineObj, lineNo, dir) {\n  if (visually) {\n    var order = getOrder(lineObj, cm.doc.direction);\n    if (order) {\n      var part = dir < 0 ? lst(order) : order[0];\n      var moveInStorageOrder = (dir < 0) == (part.level == 1);\n      var sticky = moveInStorageOrder ? \"after\" : \"before\";\n      var ch;\n      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n      // it could be that the last bidi part is not on the last visual line,\n      // since visual lines contain content order-consecutive chunks.\n      // Thus, in rtl, we are looking for the first (content-order) character\n      // in the rtl chunk that is on the last line (that is, the same line\n      // as the last (content-order) character).\n      if (part.level > 0 || cm.doc.direction == \"rtl\") {\n        var prep = prepareMeasureForLine(cm, lineObj);\n        ch = dir < 0 ? lineObj.text.length - 1 : 0;\n        var targetTop = measureCharPrepared(cm, prep, ch).top;\n        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n        if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n      } else { ch = dir < 0 ? part.to : part.from; }\n      return new Pos(lineNo, ch, sticky)\n    }\n  }\n  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n}\n\nfunction moveVisually(cm, line, start, dir) {\n  var bidi = getOrder(line, cm.doc.direction);\n  if (!bidi) { return moveLogically(line, start, dir) }\n  if (start.ch >= line.text.length) {\n    start.ch = line.text.length;\n    start.sticky = \"before\";\n  } else if (start.ch <= 0) {\n    start.ch = 0;\n    start.sticky = \"after\";\n  }\n  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n  if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n    // nothing interesting happens.\n    return moveLogically(line, start, dir)\n  }\n\n  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n  var prep;\n  var getWrappedLineExtent = function (ch) {\n    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n    prep = prep || prepareMeasureForLine(cm, line);\n    return wrappedLineExtentChar(cm, line, prep, ch)\n  };\n  var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n  if (cm.doc.direction == \"rtl\" || part.level == 1) {\n    var moveInStorageOrder = (part.level == 1) == (dir < 0);\n    var ch = mv(start, moveInStorageOrder ? 1 : -1);\n    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n      // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n      var sticky = moveInStorageOrder ? \"before\" : \"after\";\n      return new Pos(start.line, ch, sticky)\n    }\n  }\n\n  // Case 3: Could not move within this bidi part in this visual line, so leave\n  // the current bidi part\n\n  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n      ? new Pos(start.line, mv(ch, 1), \"before\")\n      : new Pos(start.line, ch, \"after\"); };\n\n    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n      var part = bidi[partPos];\n      var moveInStorageOrder = (dir > 0) == (part.level != 1);\n      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n      ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n    }\n  };\n\n  // Case 3a: Look for other bidi parts on the same visual line\n  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n  if (res) { return res }\n\n  // Case 3b: Look for other bidi parts on the next visual line\n  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n    if (res) { return res }\n  }\n\n  // Case 4: Nowhere to move\n  return null\n}\n\n// Commands are parameter-less actions that can be performed on an\n// editor, mostly used for keybindings.\nvar commands = {\n  selectAll: selectAll,\n  singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n  killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n    if (range.empty()) {\n      var len = getLine(cm.doc, range.head.line).text.length;\n      if (range.head.ch == len && range.head.line < cm.lastLine())\n        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n      else\n        { return {from: range.head, to: Pos(range.head.line, len)} }\n    } else {\n      return {from: range.from(), to: range.to()}\n    }\n  }); },\n  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0),\n    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n  }); }); },\n  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0), to: range.from()\n  }); }); },\n  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n    return {from: leftPos, to: range.from()}\n  }); },\n  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n    return {from: range.from(), to: rightPos }\n  }); },\n  undo: function (cm) { return cm.undo(); },\n  redo: function (cm) { return cm.redo(); },\n  undoSelection: function (cm) { return cm.undoSelection(); },\n  redoSelection: function (cm) { return cm.redoSelection(); },\n  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n    {origin: \"+move\", bias: -1}\n  ); },\n  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: 0, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n    if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n    return pos\n  }, sel_move); },\n  goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n  goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n  goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n  goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n  goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n  goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n  goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n  goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n  goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n  goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n  goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n  goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n  delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\n  delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n  delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n  delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n  delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n  delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n  indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n  indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n  indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n  insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n  insertSoftTab: function (cm) {\n    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n    for (var i = 0; i < ranges.length; i++) {\n      var pos = ranges[i].from();\n      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n      spaces.push(spaceStr(tabSize - col % tabSize));\n    }\n    cm.replaceSelections(spaces);\n  },\n  defaultTab: function (cm) {\n    if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n    else { cm.execCommand(\"insertTab\"); }\n  },\n  // Swap the two chars left and right of each selection's head.\n  // Move cursor behind the two swapped characters afterwards.\n  //\n  // Doesn't consider line feeds a character.\n  // Doesn't scan more than one line above to find a character.\n  // Doesn't do anything on an empty line.\n  // Doesn't do anything with non-empty selections.\n  transposeChars: function (cm) { return runInOp(cm, function () {\n    var ranges = cm.listSelections(), newSel = [];\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) { continue }\n      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n      if (line) {\n        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n        if (cur.ch > 0) {\n          cur = new Pos(cur.line, cur.ch + 1);\n          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                          Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n        } else if (cur.line > cm.doc.first) {\n          var prev = getLine(cm.doc, cur.line - 1).text;\n          if (prev) {\n            cur = new Pos(cur.line, 1);\n            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                            prev.charAt(prev.length - 1),\n                            Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n          }\n        }\n      }\n      newSel.push(new Range(cur, cur));\n    }\n    cm.setSelections(newSel);\n  }); },\n  newlineAndIndent: function (cm) { return runInOp(cm, function () {\n    var sels = cm.listSelections();\n    for (var i = sels.length - 1; i >= 0; i--)\n      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n    sels = cm.listSelections();\n    for (var i$1 = 0; i$1 < sels.length; i$1++)\n      { cm.indentLine(sels[i$1].from().line, null, true); }\n    ensureCursorVisible(cm);\n  }); },\n  openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n};\n\n\nfunction lineStart(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLine(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, visual, lineN, 1)\n}\nfunction lineEnd(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLineEnd(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, line, lineN, -1)\n}\nfunction lineStartSmart(cm, pos) {\n  var start = lineStart(cm, pos.line);\n  var line = getLine(cm.doc, start.line);\n  var order = getOrder(line, cm.doc.direction);\n  if (!order || order[0].level == 0) {\n    var firstNonWS = Math.max(0, line.text.search(/\\S/));\n    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n  }\n  return start\n}\n\n// Run a handler that was bound to a key.\nfunction doHandleBinding(cm, bound, dropShift) {\n  if (typeof bound == \"string\") {\n    bound = commands[bound];\n    if (!bound) { return false }\n  }\n  // Ensure previous input has been read, so that the handler sees a\n  // consistent view of the document\n  cm.display.input.ensurePolled();\n  var prevShift = cm.display.shift, done = false;\n  try {\n    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n    if (dropShift) { cm.display.shift = false; }\n    done = bound(cm) != Pass;\n  } finally {\n    cm.display.shift = prevShift;\n    cm.state.suppressEdits = false;\n  }\n  return done\n}\n\nfunction lookupKeyForEditor(cm, name, handle) {\n  for (var i = 0; i < cm.state.keyMaps.length; i++) {\n    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n    if (result) { return result }\n  }\n  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n    || lookupKey(name, cm.options.keyMap, handle, cm)\n}\n\n// Note that, despite the name, this function is also used to check\n// for bound mouse clicks.\n\nvar stopSeq = new Delayed;\nfunction dispatchKey(cm, name, e, handle) {\n  var seq = cm.state.keySeq;\n  if (seq) {\n    if (isModifierKey(name)) { return \"handled\" }\n    stopSeq.set(50, function () {\n      if (cm.state.keySeq == seq) {\n        cm.state.keySeq = null;\n        cm.display.input.reset();\n      }\n    });\n    name = seq + \" \" + name;\n  }\n  var result = lookupKeyForEditor(cm, name, handle);\n\n  if (result == \"multi\")\n    { cm.state.keySeq = name; }\n  if (result == \"handled\")\n    { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n  if (result == \"handled\" || result == \"multi\") {\n    e_preventDefault(e);\n    restartBlink(cm);\n  }\n\n  if (seq && !result && /\\'$/.test(name)) {\n    e_preventDefault(e);\n    return true\n  }\n  return !!result\n}\n\n// Handle a key from the keydown event.\nfunction handleKeyBinding(cm, e) {\n  var name = keyName(e, true);\n  if (!name) { return false }\n\n  if (e.shiftKey && !cm.state.keySeq) {\n    // First try to resolve full name (including 'Shift-'). Failing\n    // that, see if there is a cursor-motion command (starting with\n    // 'go') bound to the keyname without 'Shift-'.\n    return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n        || dispatchKey(cm, name, e, function (b) {\n             if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n               { return doHandleBinding(cm, b) }\n           })\n  } else {\n    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n  }\n}\n\n// Handle a key from the keypress event\nfunction handleCharBinding(cm, e, ch) {\n  return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n}\n\nvar lastStoppedKey = null;\nfunction onKeyDown(e) {\n  var cm = this;\n  cm.curOp.focus = activeElt();\n  if (signalDOMEvent(cm, e)) { return }\n  // IE does strange things with escape.\n  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n  var code = e.keyCode;\n  cm.display.shift = code == 16 || e.shiftKey;\n  var handled = handleKeyBinding(cm, e);\n  if (presto) {\n    lastStoppedKey = handled ? code : null;\n    // Opera has no cut event... we try to at least catch the key combo\n    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n      { cm.replaceSelection(\"\", null, \"cut\"); }\n  }\n\n  // Turn mouse into crosshair when Alt is held on Mac.\n  if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n    { showCrossHair(cm); }\n}\n\nfunction showCrossHair(cm) {\n  var lineDiv = cm.display.lineDiv;\n  addClass(lineDiv, \"CodeMirror-crosshair\");\n\n  function up(e) {\n    if (e.keyCode == 18 || !e.altKey) {\n      rmClass(lineDiv, \"CodeMirror-crosshair\");\n      off(document, \"keyup\", up);\n      off(document, \"mouseover\", up);\n    }\n  }\n  on(document, \"keyup\", up);\n  on(document, \"mouseover\", up);\n}\n\nfunction onKeyUp(e) {\n  if (e.keyCode == 16) { this.doc.sel.shift = false; }\n  signalDOMEvent(this, e);\n}\n\nfunction onKeyPress(e) {\n  var cm = this;\n  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n  var keyCode = e.keyCode, charCode = e.charCode;\n  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n  // Some browsers fire keypress events for backspace\n  if (ch == \"\\x08\") { return }\n  if (handleCharBinding(cm, e, ch)) { return }\n  cm.display.input.onKeyPress(e);\n}\n\nvar DOUBLECLICK_DELAY = 400;\n\nvar PastClick = function(time, pos, button) {\n  this.time = time;\n  this.pos = pos;\n  this.button = button;\n};\n\nPastClick.prototype.compare = function (time, pos, button) {\n  return this.time + DOUBLECLICK_DELAY > time &&\n    cmp(pos, this.pos) == 0 && button == this.button\n};\n\nvar lastClick;\nvar lastDoubleClick;\nfunction clickRepeat(pos, button) {\n  var now = +new Date;\n  if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n    lastClick = lastDoubleClick = null;\n    return \"triple\"\n  } else if (lastClick && lastClick.compare(now, pos, button)) {\n    lastDoubleClick = new PastClick(now, pos, button);\n    lastClick = null;\n    return \"double\"\n  } else {\n    lastClick = new PastClick(now, pos, button);\n    lastDoubleClick = null;\n    return \"single\"\n  }\n}\n\n// A mouse down can be a single click, double click, triple click,\n// start of selection drag, start of text drag, new cursor\n// (ctrl-click), rectangle drag (alt-drag), or xwin\n// middle-click-paste. Or it might be a click on something we should\n// not interfere with, such as a scrollbar or widget.\nfunction onMouseDown(e) {\n  var cm = this, display = cm.display;\n  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n  display.input.ensurePolled();\n  display.shift = e.shiftKey;\n\n  if (eventInWidget(display, e)) {\n    if (!webkit) {\n      // Briefly turn off draggability, to allow widgets to do\n      // normal dragging things.\n      display.scroller.draggable = false;\n      setTimeout(function () { return display.scroller.draggable = true; }, 100);\n    }\n    return\n  }\n  if (clickInGutter(cm, e)) { return }\n  var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n  window.focus();\n\n  // #3261: make sure, that we're not starting a second selection\n  if (button == 1 && cm.state.selectingText)\n    { cm.state.selectingText(e); }\n\n  if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n  if (button == 1) {\n    if (pos) { leftButtonDown(cm, pos, repeat, e); }\n    else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n  } else if (button == 2) {\n    if (pos) { extendSelection(cm.doc, pos); }\n    setTimeout(function () { return display.input.focus(); }, 20);\n  } else if (button == 3) {\n    if (captureRightClick) { onContextMenu(cm, e); }\n    else { delayBlurEvent(cm); }\n  }\n}\n\nfunction handleMappedButton(cm, button, pos, repeat, event) {\n  var name = \"Click\";\n  if (repeat == \"double\") { name = \"Double\" + name; }\n  else if (repeat == \"triple\") { name = \"Triple\" + name; }\n  name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n  return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n    if (typeof bound == \"string\") { bound = commands[bound]; }\n    if (!bound) { return false }\n    var done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      done = bound(cm, pos) != Pass;\n    } finally {\n      cm.state.suppressEdits = false;\n    }\n    return done\n  })\n}\n\nfunction configureMouse(cm, repeat, event) {\n  var option = cm.getOption(\"configureMouse\");\n  var value = option ? option(cm, repeat, event) : {};\n  if (value.unit == null) {\n    var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n    value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n  }\n  if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n  if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n  if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n  return value\n}\n\nfunction leftButtonDown(cm, pos, repeat, event) {\n  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n  else { cm.curOp.focus = activeElt(); }\n\n  var behavior = configureMouse(cm, repeat, event);\n\n  var sel = cm.doc.sel, contained;\n  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n      repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n      (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n      (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n    { leftButtonStartDrag(cm, event, pos, behavior); }\n  else\n    { leftButtonSelect(cm, event, pos, behavior); }\n}\n\n// Start a text drag. When it ends, see if any dragging actually\n// happen, and treat as a click if it didn't.\nfunction leftButtonStartDrag(cm, event, pos, behavior) {\n  var display = cm.display, moved = false;\n  var dragEnd = operation(cm, function (e) {\n    if (webkit) { display.scroller.draggable = false; }\n    cm.state.draggingText = false;\n    off(document, \"mouseup\", dragEnd);\n    off(document, \"mousemove\", mouseMove);\n    off(display.scroller, \"dragstart\", dragStart);\n    off(display.scroller, \"drop\", dragEnd);\n    if (!moved) {\n      e_preventDefault(e);\n      if (!behavior.addNew)\n        { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n      if (webkit || ie && ie_version == 9)\n        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }\n      else\n        { display.input.focus(); }\n    }\n  });\n  var mouseMove = function(e2) {\n    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n  };\n  var dragStart = function () { return moved = true; };\n  // Let the drag handler handle this.\n  if (webkit) { display.scroller.draggable = true; }\n  cm.state.draggingText = dragEnd;\n  dragEnd.copy = !behavior.moveOnDrag;\n  // IE's approach to draggable\n  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n  on(document, \"mouseup\", dragEnd);\n  on(document, \"mousemove\", mouseMove);\n  on(display.scroller, \"dragstart\", dragStart);\n  on(display.scroller, \"drop\", dragEnd);\n\n  delayBlurEvent(cm);\n  setTimeout(function () { return display.input.focus(); }, 20);\n}\n\nfunction rangeForUnit(cm, pos, unit) {\n  if (unit == \"char\") { return new Range(pos, pos) }\n  if (unit == \"word\") { return cm.findWordAt(pos) }\n  if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n  var result = unit(cm, pos);\n  return new Range(result.from, result.to)\n}\n\n// Normal selection, as opposed to text dragging.\nfunction leftButtonSelect(cm, event, start, behavior) {\n  var display = cm.display, doc = cm.doc;\n  e_preventDefault(event);\n\n  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n  if (behavior.addNew && !behavior.extend) {\n    ourIndex = doc.sel.contains(start);\n    if (ourIndex > -1)\n      { ourRange = ranges[ourIndex]; }\n    else\n      { ourRange = new Range(start, start); }\n  } else {\n    ourRange = doc.sel.primary();\n    ourIndex = doc.sel.primIndex;\n  }\n\n  if (behavior.unit == \"rectangle\") {\n    if (!behavior.addNew) { ourRange = new Range(start, start); }\n    start = posFromMouse(cm, event, true, true);\n    ourIndex = -1;\n  } else {\n    var range$$1 = rangeForUnit(cm, start, behavior.unit);\n    if (behavior.extend)\n      { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }\n    else\n      { ourRange = range$$1; }\n  }\n\n  if (!behavior.addNew) {\n    ourIndex = 0;\n    setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n    startSel = doc.sel;\n  } else if (ourIndex == -1) {\n    ourIndex = ranges.length;\n    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n                 {scroll: false, origin: \"*mouse\"});\n  } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                 {scroll: false, origin: \"*mouse\"});\n    startSel = doc.sel;\n  } else {\n    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n  }\n\n  var lastPos = start;\n  function extendTo(pos) {\n    if (cmp(lastPos, pos) == 0) { return }\n    lastPos = pos;\n\n    if (behavior.unit == \"rectangle\") {\n      var ranges = [], tabSize = cm.options.tabSize;\n      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n           line <= end; line++) {\n        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n        if (left == right)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n        else if (text.length > leftPos)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n      }\n      if (!ranges.length) { ranges.push(new Range(start, start)); }\n      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                   {origin: \"*mouse\", scroll: false});\n      cm.scrollIntoView(pos);\n    } else {\n      var oldRange = ourRange;\n      var range$$1 = rangeForUnit(cm, pos, behavior.unit);\n      var anchor = oldRange.anchor, head;\n      if (cmp(range$$1.anchor, anchor) > 0) {\n        head = range$$1.head;\n        anchor = minPos(oldRange.from(), range$$1.anchor);\n      } else {\n        head = range$$1.anchor;\n        anchor = maxPos(oldRange.to(), range$$1.head);\n      }\n      var ranges$1 = startSel.ranges.slice(0);\n      ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);\n    }\n  }\n\n  var editorSize = display.wrapper.getBoundingClientRect();\n  // Used to ensure timeout re-tries don't fire when another extend\n  // happened in the meantime (clearTimeout isn't reliable -- at\n  // least on Chrome, the timeouts still happen even when cleared,\n  // if the clear happens after their scheduled firing time).\n  var counter = 0;\n\n  function extend(e) {\n    var curCount = ++counter;\n    var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n    if (!cur) { return }\n    if (cmp(cur, lastPos) != 0) {\n      cm.curOp.focus = activeElt();\n      extendTo(cur);\n      var visible = visibleLines(display, doc);\n      if (cur.line >= visible.to || cur.line < visible.from)\n        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n    } else {\n      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n      if (outside) { setTimeout(operation(cm, function () {\n        if (counter != curCount) { return }\n        display.scroller.scrollTop += outside;\n        extend(e);\n      }), 50); }\n    }\n  }\n\n  function done(e) {\n    cm.state.selectingText = false;\n    counter = Infinity;\n    e_preventDefault(e);\n    display.input.focus();\n    off(document, \"mousemove\", move);\n    off(document, \"mouseup\", up);\n    doc.history.lastSelOrigin = null;\n  }\n\n  var move = operation(cm, function (e) {\n    if (!e_button(e)) { done(e); }\n    else { extend(e); }\n  });\n  var up = operation(cm, done);\n  cm.state.selectingText = up;\n  on(document, \"mousemove\", move);\n  on(document, \"mouseup\", up);\n}\n\n// Used when mouse-selecting to adjust the anchor to the proper side\n// of a bidi jump depending on the visual position of the head.\nfunction bidiSimplify(cm, range$$1) {\n  var anchor = range$$1.anchor;\n  var head = range$$1.head;\n  var anchorLine = getLine(cm.doc, anchor.line);\n  if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }\n  var order = getOrder(anchorLine);\n  if (!order) { return range$$1 }\n  var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n  if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }\n  var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n  if (boundary == 0 || boundary == order.length) { return range$$1 }\n\n  // Compute the relative visual position of the head compared to the\n  // anchor (<0 is to the left, >0 to the right)\n  var leftSide;\n  if (head.line != anchor.line) {\n    leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n  } else {\n    var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n    var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n    if (headIndex == boundary - 1 || headIndex == boundary)\n      { leftSide = dir < 0; }\n    else\n      { leftSide = dir > 0; }\n  }\n\n  var usePart = order[boundary + (leftSide ? -1 : 0)];\n  var from = leftSide == (usePart.level == 1);\n  var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n  return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)\n}\n\n\n// Determines whether an event happened in the gutter, and fires the\n// handlers for the corresponding event.\nfunction gutterEvent(cm, e, type, prevent) {\n  var mX, mY;\n  if (e.touches) {\n    mX = e.touches[0].clientX;\n    mY = e.touches[0].clientY;\n  } else {\n    try { mX = e.clientX; mY = e.clientY; }\n    catch(e) { return false }\n  }\n  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n  if (prevent) { e_preventDefault(e); }\n\n  var display = cm.display;\n  var lineBox = display.lineDiv.getBoundingClientRect();\n\n  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n  mY -= lineBox.top - display.viewOffset;\n\n  for (var i = 0; i < cm.options.gutters.length; ++i) {\n    var g = display.gutters.childNodes[i];\n    if (g && g.getBoundingClientRect().right >= mX) {\n      var line = lineAtHeight(cm.doc, mY);\n      var gutter = cm.options.gutters[i];\n      signal(cm, type, cm, line, gutter, e);\n      return e_defaultPrevented(e)\n    }\n  }\n}\n\nfunction clickInGutter(cm, e) {\n  return gutterEvent(cm, e, \"gutterClick\", true)\n}\n\n// CONTEXT MENU HANDLING\n\n// To make the context menu work, we need to briefly unhide the\n// textarea (making it as unobtrusive as possible) to let the\n// right-click take effect on it.\nfunction onContextMenu(cm, e) {\n  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n  if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n  cm.display.input.onContextMenu(e);\n}\n\nfunction contextMenuInGutter(cm, e) {\n  if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n  return gutterEvent(cm, e, \"gutterContextMenu\", false)\n}\n\nfunction themeChanged(cm) {\n  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n    cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n  clearCaches(cm);\n}\n\nvar Init = {toString: function(){return \"CodeMirror.Init\"}};\n\nvar defaults = {};\nvar optionHandlers = {};\n\nfunction defineOptions(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) { optionHandlers[name] =\n      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n  }\n\n  CodeMirror.defineOption = option;\n\n  // Passed to option handlers when there is no old value.\n  CodeMirror.Init = Init;\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n  option(\"mode\", null, function (cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function (cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"lineSeparator\", null, function (cm, val) {\n    cm.doc.lineSep = val;\n    if (!val) { return }\n    var newBreaks = [], lineNo = cm.doc.first;\n    cm.doc.iter(function (line) {\n      for (var pos = 0;;) {\n        var found = line.text.indexOf(val, pos);\n        if (found == -1) { break }\n        pos = found + val.length;\n        newBreaks.push(Pos(lineNo, found));\n      }\n      lineNo++;\n    });\n    for (var i = newBreaks.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n  });\n  option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function (cm, val, old) {\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    if (old != Init) { cm.refresh(); }\n  });\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n  option(\"electricChars\", true);\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n  }, true);\n  option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function (cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", function (cm, val, old) {\n    var next = getKeyMap(val);\n    var prev = old != Init && getKeyMap(old);\n    if (prev && prev.detach) { prev.detach(cm, next); }\n    if (next.attach) { next.attach(cm, prev || null); }\n  });\n  option(\"extraKeys\", null);\n  option(\"configureMouse\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function (cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n  option(\"scrollbarStyle\", \"native\", function (cm) {\n    initScrollbars(cm);\n    updateScrollbars(cm);\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n  }, true);\n  option(\"lineNumbers\", false, function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function (integer) { return integer; }, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n  option(\"lineWiseCopyCut\", true);\n  option(\"pasteLinesPerSelection\", true);\n\n  option(\"readOnly\", false, function (cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n    }\n    cm.display.input.readOnlyChanged(val);\n  });\n  option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n  option(\"dragDrop\", true, dragDropChanged);\n  option(\"allowDropFileTypes\", null);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function (cm, val) {\n    if (!val) { cm.display.input.resetPosition(); }\n  });\n\n  option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n  option(\"autofocus\", null);\n  option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n}\n\nfunction guttersChanged(cm) {\n  updateGutters(cm);\n  regChange(cm);\n  alignHorizontally(cm);\n}\n\nfunction dragDropChanged(cm, value, old) {\n  var wasOn = old && old != Init;\n  if (!value != !wasOn) {\n    var funcs = cm.display.dragFunctions;\n    var toggle = value ? on : off;\n    toggle(cm.display.scroller, \"dragstart\", funcs.start);\n    toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n    toggle(cm.display.scroller, \"dragover\", funcs.over);\n    toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n    toggle(cm.display.scroller, \"drop\", funcs.drop);\n  }\n}\n\nfunction wrappingChanged(cm) {\n  if (cm.options.lineWrapping) {\n    addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    cm.display.sizer.style.minWidth = \"\";\n    cm.display.sizerWidth = null;\n  } else {\n    rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    findMaxLine(cm);\n  }\n  estimateLineHeights(cm);\n  regChange(cm);\n  clearCaches(cm);\n  setTimeout(function () { return updateScrollbars(cm); }, 100);\n}\n\n// A CodeMirror instance represents an editor. This is the object\n// that user code is usually dealing with.\n\nfunction CodeMirror$1(place, options) {\n  var this$1 = this;\n\n  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }\n\n  this.options = options = options ? copyObj(options) : {};\n  // Determine effective options based on given values and defaults.\n  copyObj(defaults, options, false);\n  setGuttersForLineNumbers(options);\n\n  var doc = options.value;\n  if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n  this.doc = doc;\n\n  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);\n  var display = this.display = new Display(place, doc, input);\n  display.wrapper.CodeMirror = this;\n  updateGutters(this);\n  themeChanged(this);\n  if (options.lineWrapping)\n    { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n  initScrollbars(this);\n\n  this.state = {\n    keyMaps: [],  // stores maps added by addKeyMap\n    overlays: [], // highlighting overlays, as added by addOverlay\n    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n    overwrite: false,\n    delayingBlurEvent: false,\n    focused: false,\n    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n    selectingText: false,\n    draggingText: false,\n    highlight: new Delayed(), // stores highlight worker timeout\n    keySeq: null,  // Unfinished key sequence\n    specialChars: null\n  };\n\n  if (options.autofocus && !mobile) { display.input.focus(); }\n\n  // Override magic textarea content restore that IE sometimes does\n  // on our hidden textarea on reload\n  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n  registerEventHandlers(this);\n  ensureGlobalHandlers();\n\n  startOperation(this);\n  this.curOp.forceUpdate = true;\n  attachDoc(this, doc);\n\n  if ((options.autofocus && !mobile) || this.hasFocus())\n    { setTimeout(bind(onFocus, this), 20); }\n  else\n    { onBlur(this); }\n\n  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n    { optionHandlers[opt](this$1, options[opt], Init); } }\n  maybeUpdateLineNumberWidth(this);\n  if (options.finishInit) { options.finishInit(this); }\n  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }\n  endOperation(this);\n  // Suppress optimizelegibility in Webkit, since it breaks text\n  // measuring on line wrapping boundaries.\n  if (webkit && options.lineWrapping &&\n      getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n    { display.lineDiv.style.textRendering = \"auto\"; }\n}\n\n// The default configuration options.\nCodeMirror$1.defaults = defaults;\n// Functions to run when options are changed.\nCodeMirror$1.optionHandlers = optionHandlers;\n\n// Attach the necessary event handlers when initializing the editor\nfunction registerEventHandlers(cm) {\n  var d = cm.display;\n  on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n  // Older IE's will not fire a second mousedown for a double click\n  if (ie && ie_version < 11)\n    { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n      if (signalDOMEvent(cm, e)) { return }\n      var pos = posFromMouse(cm, e);\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n      e_preventDefault(e);\n      var word = cm.findWordAt(pos);\n      extendSelection(cm.doc, word.anchor, word.head);\n    })); }\n  else\n    { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n  // Some browsers fire contextmenu *after* opening the menu, at\n  // which point we can't mess with it anymore. Context menu is\n  // handled in onMouseDown for these browsers.\n  if (!captureRightClick) { on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); }); }\n\n  // Used to suppress mouse event handling when a touch happens\n  var touchFinished, prevTouch = {end: 0};\n  function finishTouch() {\n    if (d.activeTouch) {\n      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n      prevTouch = d.activeTouch;\n      prevTouch.end = +new Date;\n    }\n  }\n  function isMouseLikeTouchEvent(e) {\n    if (e.touches.length != 1) { return false }\n    var touch = e.touches[0];\n    return touch.radiusX <= 1 && touch.radiusY <= 1\n  }\n  function farAway(touch, other) {\n    if (other.left == null) { return true }\n    var dx = other.left - touch.left, dy = other.top - touch.top;\n    return dx * dx + dy * dy > 20 * 20\n  }\n  on(d.scroller, \"touchstart\", function (e) {\n    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n      d.input.ensurePolled();\n      clearTimeout(touchFinished);\n      var now = +new Date;\n      d.activeTouch = {start: now, moved: false,\n                       prev: now - prevTouch.end <= 300 ? prevTouch : null};\n      if (e.touches.length == 1) {\n        d.activeTouch.left = e.touches[0].pageX;\n        d.activeTouch.top = e.touches[0].pageY;\n      }\n    }\n  });\n  on(d.scroller, \"touchmove\", function () {\n    if (d.activeTouch) { d.activeTouch.moved = true; }\n  });\n  on(d.scroller, \"touchend\", function (e) {\n    var touch = d.activeTouch;\n    if (touch && !eventInWidget(d, e) && touch.left != null &&\n        !touch.moved && new Date - touch.start < 300) {\n      var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n      if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n        { range = new Range(pos, pos); }\n      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n        { range = cm.findWordAt(pos); }\n      else // Triple tap\n        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n      cm.setSelection(range.anchor, range.head);\n      cm.focus();\n      e_preventDefault(e);\n    }\n    finishTouch();\n  });\n  on(d.scroller, \"touchcancel\", finishTouch);\n\n  // Sync scrolling between fake scrollbars and real scrollable\n  // area, ensure viewport is updated when scrolling.\n  on(d.scroller, \"scroll\", function () {\n    if (d.scroller.clientHeight) {\n      updateScrollTop(cm, d.scroller.scrollTop);\n      setScrollLeft(cm, d.scroller.scrollLeft, true);\n      signal(cm, \"scroll\", cm);\n    }\n  });\n\n  // Listen to wheel events in order to try and update the viewport on time.\n  on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n  on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n  // Prevent wrapper from ever scrolling\n  on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n  d.dragFunctions = {\n    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n    start: function (e) { return onDragStart(cm, e); },\n    drop: operation(cm, onDrop),\n    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n  };\n\n  var inp = d.input.getField();\n  on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n  on(inp, \"keydown\", operation(cm, onKeyDown));\n  on(inp, \"keypress\", operation(cm, onKeyPress));\n  on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n  on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n}\n\nvar initHooks = [];\nCodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };\n\n// Indent the given line. The how parameter can be \"smart\",\n// \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n// (typically set to true for forced single-line indents), empty\n// lines are not indented, and places where the mode returns Pass\n// are left alone.\nfunction indentLine(cm, n, how, aggressive) {\n  var doc = cm.doc, state;\n  if (how == null) { how = \"add\"; }\n  if (how == \"smart\") {\n    // Fall back to \"prev\" when the mode doesn't have an indentation\n    // method.\n    if (!doc.mode.indent) { how = \"prev\"; }\n    else { state = getContextBefore(cm, n).state; }\n  }\n\n  var tabSize = cm.options.tabSize;\n  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n  if (line.stateAfter) { line.stateAfter = null; }\n  var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n  if (!aggressive && !/\\S/.test(line.text)) {\n    indentation = 0;\n    how = \"not\";\n  } else if (how == \"smart\") {\n    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n    if (indentation == Pass || indentation > 150) {\n      if (!aggressive) { return }\n      how = \"prev\";\n    }\n  }\n  if (how == \"prev\") {\n    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n    else { indentation = 0; }\n  } else if (how == \"add\") {\n    indentation = curSpace + cm.options.indentUnit;\n  } else if (how == \"subtract\") {\n    indentation = curSpace - cm.options.indentUnit;\n  } else if (typeof how == \"number\") {\n    indentation = curSpace + how;\n  }\n  indentation = Math.max(0, indentation);\n\n  var indentString = \"\", pos = 0;\n  if (cm.options.indentWithTabs)\n    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n  if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n  if (indentString != curSpaceString) {\n    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n    line.stateAfter = null;\n    return true\n  } else {\n    // Ensure that, if the cursor was in the whitespace at the start\n    // of the line, it is moved to the end of that space.\n    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n      var range = doc.sel.ranges[i$1];\n      if (range.head.line == n && range.head.ch < curSpaceString.length) {\n        var pos$1 = Pos(n, curSpaceString.length);\n        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n        break\n      }\n    }\n  }\n}\n\n// This will be set to a {lineWise: bool, text: [string]} object, so\n// that, when pasting, we know what kind of selections the copied\n// text was made out of.\nvar lastCopied = null;\n\nfunction setLastCopied(newLastCopied) {\n  lastCopied = newLastCopied;\n}\n\nfunction applyTextInput(cm, inserted, deleted, sel, origin) {\n  var doc = cm.doc;\n  cm.display.shift = false;\n  if (!sel) { sel = doc.sel; }\n\n  var paste = cm.state.pasteIncoming || origin == \"paste\";\n  var textLines = splitLinesAuto(inserted), multiPaste = null;\n  // When pasing N lines into N selections, insert one line per selection\n  if (paste && sel.ranges.length > 1) {\n    if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n      if (sel.ranges.length % lastCopied.text.length == 0) {\n        multiPaste = [];\n        for (var i = 0; i < lastCopied.text.length; i++)\n          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n      }\n    } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n      multiPaste = map(textLines, function (l) { return [l]; });\n    }\n  }\n\n  var updateInput;\n  // Normal behavior is to insert the new text into every selection\n  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n    var range$$1 = sel.ranges[i$1];\n    var from = range$$1.from(), to = range$$1.to();\n    if (range$$1.empty()) {\n      if (deleted && deleted > 0) // Handle deletion\n        { from = Pos(from.line, from.ch - deleted); }\n      else if (cm.state.overwrite && !paste) // Handle overwrite\n        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n        { from = to = Pos(from.line, 0); }\n    }\n    updateInput = cm.curOp.updateInput;\n    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                       origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n    makeChange(cm.doc, changeEvent);\n    signalLater(cm, \"inputRead\", cm, changeEvent);\n  }\n  if (inserted && !paste)\n    { triggerElectric(cm, inserted); }\n\n  ensureCursorVisible(cm);\n  cm.curOp.updateInput = updateInput;\n  cm.curOp.typing = true;\n  cm.state.pasteIncoming = cm.state.cutIncoming = false;\n}\n\nfunction handlePaste(e, cm) {\n  var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n  if (pasted) {\n    e.preventDefault();\n    if (!cm.isReadOnly() && !cm.options.disableInput)\n      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n    return true\n  }\n}\n\nfunction triggerElectric(cm, inserted) {\n  // When an 'electric' character is inserted, immediately trigger a reindent\n  if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n  var sel = cm.doc.sel;\n\n  for (var i = sel.ranges.length - 1; i >= 0; i--) {\n    var range$$1 = sel.ranges[i];\n    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\n    var mode = cm.getModeAt(range$$1.head);\n    var indented = false;\n    if (mode.electricChars) {\n      for (var j = 0; j < mode.electricChars.length; j++)\n        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n          indented = indentLine(cm, range$$1.head.line, \"smart\");\n          break\n        } }\n    } else if (mode.electricInput) {\n      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\n        { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\n    }\n    if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\n  }\n}\n\nfunction copyableRanges(cm) {\n  var text = [], ranges = [];\n  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n    var line = cm.doc.sel.ranges[i].head.line;\n    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n    ranges.push(lineRange);\n    text.push(cm.getRange(lineRange.anchor, lineRange.head));\n  }\n  return {text: text, ranges: ranges}\n}\n\nfunction disableBrowserMagic(field, spellcheck) {\n  field.setAttribute(\"autocorrect\", \"off\");\n  field.setAttribute(\"autocapitalize\", \"off\");\n  field.setAttribute(\"spellcheck\", !!spellcheck);\n}\n\nfunction hiddenTextarea() {\n  var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n  var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n  // The textarea is kept positioned near the cursor to prevent the\n  // fact that it'll be scrolled into view on input from scrolling\n  // our fake cursor out of view. On webkit, when wrap=off, paste is\n  // very slow. So make the area wide instead.\n  if (webkit) { te.style.width = \"1000px\"; }\n  else { te.setAttribute(\"wrap\", \"off\"); }\n  // If border: 0; -- iOS fails to open keyboard (issue #1287)\n  if (ios) { te.style.border = \"1px solid black\"; }\n  disableBrowserMagic(te);\n  return div\n}\n\n// The publicly visible API. Note that methodOp(f) means\n// 'wrap f in an operation, performed on its `this` parameter'.\n\n// This is not the complete set of editor methods. Most of the\n// methods defined on the Doc type are also injected into\n// CodeMirror.prototype, for backwards compatibility and\n// convenience.\n\nvar addEditorMethods = function(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  var helpers = CodeMirror.helpers = {};\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); this.display.input.focus();},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") { return }\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        { operation(this, optionHandlers[option])(this, value, old); }\n      signal(this, \"optionChange\", this, option);\n    },\n\n    getOption: function(option) {return this.options[option]},\n    getDoc: function() {return this.doc},\n\n    addKeyMap: function(map$$1, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\n    },\n    removeKeyMap: function(map$$1) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        { if (maps[i] == map$$1 || maps[i].name == map$$1) {\n          maps.splice(i, 1);\n          return true\n        } }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n      insertSorted(this.state.overlays,\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                    priority: (options && options.priority) || 0},\n                   function (overlay) { return overlay.priority; });\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var this$1 = this;\n\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this$1.state.modeGen++;\n          regChange(this$1);\n          return\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n        else { dir = dir ? \"add\" : \"subtract\"; }\n      }\n      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n    }),\n    indentSelection: methodOp(function(how) {\n      var this$1 = this;\n\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range$$1 = ranges[i];\n        if (!range$$1.empty()) {\n          var from = range$$1.from(), to = range$$1.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            { indentLine(this$1, j, how); }\n          var newRanges = this$1.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n        } else if (range$$1.head.line > end) {\n          indentLine(this$1, range$$1.head.line, how, true);\n          end = range$$1.head.line;\n          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      return takeToken(this, pos, precise)\n    },\n\n    getLineTokens: function(line, precise) {\n      return takeToken(this, Pos(line), precise, true)\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) { type = styles[2]; }\n      else { for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n        else { type = styles[mid * 2 + 2]; break }\n      } }\n      var cut = type ? type.indexOf(\"overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) { return mode }\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0]\n    },\n\n    getHelpers: function(pos, type) {\n      var this$1 = this;\n\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) { return found }\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) { found.push(help[mode[type]]); }\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) { found.push(val); }\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n        var cur = help._global[i$1];\n        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\n          { found.push(cur.val); }\n      }\n      return found\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getContextBefore(this, line + 1, precise).state\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range$$1 = this.doc.sel.primary();\n      if (start == null) { pos = range$$1.head; }\n      else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n      else { pos = start ? range$$1.from() : range$$1.to(); }\n      return cursorCoords(this, pos, mode || \"page\")\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top)\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset)\n    },\n    heightAtLine: function(line, mode, includeWidgets) {\n      var end = false, lineObj;\n      if (typeof line == \"number\") {\n        var last = this.doc.first + this.doc.size - 1;\n        if (line < this.doc.first) { line = this.doc.first; }\n        else if (line > last) { line = last; end = true; }\n        lineObj = getLine(this.doc, line);\n      } else {\n        lineObj = line;\n      }\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0)\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display) },\n    defaultCharWidth: function() { return charWidth(this.display) },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      node.setAttribute(\"cm-ignore-events\", \"true\");\n      this.display.input.setUneditable(node);\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          { top = pos.top - node.offsetHeight; }\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          { top = pos.bottom; }\n        if (left + node.offsetWidth > hspace)\n          { left = hspace - node.offsetWidth; }\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") { left = 0; }\n        else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n    triggerOnMouseDown: methodOp(onMouseDown),\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        { return commands[cmd].call(null, this) }\n    },\n\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n    findPosH: function(from, amount, unit, visually) {\n      var this$1 = this;\n\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        cur = findPosH(this$1.doc, cur, dir, unit, visually);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      this.extendSelectionsBy(function (range$$1) {\n        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\n          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\n        else\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        { doc.replaceSelection(\"\", null, \"+delete\"); }\n      else\n        { deleteNearSelection(this, function (range$$1) {\n          var other = findPosH(doc, range$$1.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\n        }); }\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var this$1 = this;\n\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        var coords = cursorCoords(this$1, cur, \"div\");\n        if (x == null) { x = coords.left; }\n        else { coords.left = x; }\n        cur = findPosV(this$1, coords, dir, unit);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      var doc = this.doc, goals = [];\n      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function (range$$1) {\n        if (collapse)\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n        var headPos = cursorCoords(this$1, range$$1.head, \"div\");\n        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\n        goals.push(headPos.left);\n        var pos = findPosV(this$1, headPos, dir, unit);\n        if (unit == \"page\" && range$$1 == doc.sel.primary())\n          { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n        return pos\n      }, sel_move);\n      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n        { doc.sel.ranges[i].goalColumn = goals[i]; } }\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function (ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n          : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n        while (start > 0 && check(line.charAt(start - 1))) { --start; }\n        while (end < line.length && check(line.charAt(end))) { ++end; }\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end))\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) { return }\n      if (this.state.overwrite = !this.state.overwrite)\n        { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n      else\n        { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return this.display.input.getField() == activeElt() },\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n    },\n\n    scrollIntoView: methodOp(function(range$$1, margin) {\n      if (range$$1 == null) {\n        range$$1 = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) { margin = this.options.cursorScrollMargin; }\n      } else if (typeof range$$1 == \"number\") {\n        range$$1 = {from: Pos(range$$1, 0), to: null};\n      } else if (range$$1.from == null) {\n        range$$1 = {from: range$$1, to: null};\n      }\n      if (!range$$1.to) { range$$1.to = range$$1.from; }\n      range$$1.margin = margin || 0;\n\n      if (range$$1.from.line != null) {\n        scrollToRange(this, range$$1);\n      } else {\n        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var this$1 = this;\n\n      var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n      if (width != null) { this.display.wrapper.style.width = interpret(width); }\n      if (height != null) { this.display.wrapper.style.height = interpret(height); }\n      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n      var lineNo$$1 = this.display.viewFrom;\n      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\n        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\n        ++lineNo$$1;\n      });\n      this.curOp.forceUpdate = true;\n      signal(this, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f)},\n    startOperation: function(){return startOperation(this)},\n    endOperation: function(){return endOperation(this)},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        { estimateLineHeights(this); }\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      this.display.input.reset();\n      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old\n    }),\n\n    getInputField: function(){return this.display.input.getField()},\n    getWrapperElement: function(){return this.display.wrapper},\n    getScrollerElement: function(){return this.display.scroller},\n    getGutterElement: function(){return this.display.gutters}\n  };\n  eventMixin(CodeMirror);\n\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n};\n\n// Used for horizontal relative motion. Dir is -1 or 1 (left or\n// right), unit can be \"char\", \"column\" (like char, but doesn't\n// cross line boundaries), \"word\" (across next word), or \"group\" (to\n// the start of next group of word or non-word-non-whitespace\n// chars). The visually param controls whether, in right-to-left\n// text, direction 1 means to move towards the next index in the\n// string, or towards the character to the right of the current\n// position. The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosH(doc, pos, dir, unit, visually) {\n  var oldPos = pos;\n  var origDir = dir;\n  var lineObj = getLine(doc, pos.line);\n  function findNextLine() {\n    var l = pos.line + dir;\n    if (l < doc.first || l >= doc.first + doc.size) { return false }\n    pos = new Pos(l, pos.ch, pos.sticky);\n    return lineObj = getLine(doc, l)\n  }\n  function moveOnce(boundToLine) {\n    var next;\n    if (visually) {\n      next = moveVisually(doc.cm, lineObj, pos, dir);\n    } else {\n      next = moveLogically(lineObj, pos, dir);\n    }\n    if (next == null) {\n      if (!boundToLine && findNextLine())\n        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\n      else\n        { return false }\n    } else {\n      pos = next;\n    }\n    return true\n  }\n\n  if (unit == \"char\") {\n    moveOnce();\n  } else if (unit == \"column\") {\n    moveOnce(true);\n  } else if (unit == \"word\" || unit == \"group\") {\n    var sawType = null, group = unit == \"group\";\n    var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n    for (var first = true;; first = false) {\n      if (dir < 0 && !moveOnce(!first)) { break }\n      var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n      var type = isWordChar(cur, helper) ? \"w\"\n        : group && cur == \"\\n\" ? \"n\"\n        : !group || /\\s/.test(cur) ? null\n        : \"p\";\n      if (group && !first && !type) { type = \"s\"; }\n      if (sawType && sawType != type) {\n        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n        break\n      }\n\n      if (type) { sawType = type; }\n      if (dir > 0 && !moveOnce(!first)) { break }\n    }\n  }\n  var result = skipAtomic(doc, pos, oldPos, origDir, true);\n  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n  return result\n}\n\n// For relative vertical movement. Dir may be -1 or 1. Unit can be\n// \"page\" or \"line\". The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosV(cm, pos, dir, unit) {\n  var doc = cm.doc, x = pos.left, y;\n  if (unit == \"page\") {\n    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n  } else if (unit == \"line\") {\n    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n  }\n  var target;\n  for (;;) {\n    target = coordsChar(cm, x, y);\n    if (!target.outside) { break }\n    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n    y += dir * 5;\n  }\n  return target\n}\n\n// CONTENTEDITABLE INPUT STYLE\n\nvar ContentEditableInput = function(cm) {\n  this.cm = cm;\n  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n  this.polling = new Delayed();\n  this.composing = null;\n  this.gracePeriod = false;\n  this.readDOMTimeout = null;\n};\n\nContentEditableInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = input.cm;\n  var div = input.div = display.lineDiv;\n  disableBrowserMagic(div, cm.options.spellcheck);\n\n  on(div, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n    // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n  });\n\n  on(div, \"compositionstart\", function (e) {\n    this$1.composing = {data: e.data, done: false};\n  });\n  on(div, \"compositionupdate\", function (e) {\n    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n  });\n  on(div, \"compositionend\", function (e) {\n    if (this$1.composing) {\n      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n      this$1.composing.done = true;\n    }\n  });\n\n  on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n  on(div, \"input\", function () {\n    if (!this$1.composing) { this$1.readFromDOMSoon(); }\n  });\n\n  function onCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n      if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.operation(function () {\n          cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n          cm.replaceSelection(\"\", null, \"cut\");\n        });\n      }\n    }\n    if (e.clipboardData) {\n      e.clipboardData.clearData();\n      var content = lastCopied.text.join(\"\\n\");\n      // iOS exposes the clipboard API, but seems to discard content inserted into it\n      e.clipboardData.setData(\"Text\", content);\n      if (e.clipboardData.getData(\"Text\") == content) {\n        e.preventDefault();\n        return\n      }\n    }\n    // Old-fashioned briefly-focus-a-textarea hack\n    var kludge = hiddenTextarea(), te = kludge.firstChild;\n    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n    te.value = lastCopied.text.join(\"\\n\");\n    var hadFocus = document.activeElement;\n    selectInput(te);\n    setTimeout(function () {\n      cm.display.lineSpace.removeChild(kludge);\n      hadFocus.focus();\n      if (hadFocus == div) { input.showPrimarySelection(); }\n    }, 50);\n  }\n  on(div, \"copy\", onCopyCut);\n  on(div, \"cut\", onCopyCut);\n};\n\nContentEditableInput.prototype.prepareSelection = function () {\n  var result = prepareSelection(this.cm, false);\n  result.focus = this.cm.state.focused;\n  return result\n};\n\nContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n  if (!info || !this.cm.display.view.length) { return }\n  if (info.focus || takeFocus) { this.showPrimarySelection(); }\n  this.showMultipleSelections(info);\n};\n\nContentEditableInput.prototype.showPrimarySelection = function () {\n  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n  var from = prim.from(), to = prim.to();\n\n  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n      cmp(minPos(curAnchor, curFocus), from) == 0 &&\n      cmp(maxPos(curAnchor, curFocus), to) == 0)\n    { return }\n\n  var view = cm.display.view;\n  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n      {node: view[0].measure.map[2], offset: 0};\n  var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n  if (!end) {\n    var measure = view[view.length - 1].measure;\n    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\n  }\n\n  if (!start || !end) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var old = sel.rangeCount && sel.getRangeAt(0), rng;\n  try { rng = range(start.node, start.offset, end.offset, end.node); }\n  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n  if (rng) {\n    if (!gecko && cm.state.focused) {\n      sel.collapse(start.node, start.offset);\n      if (!rng.collapsed) {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n    } else {\n      sel.removeAllRanges();\n      sel.addRange(rng);\n    }\n    if (old && sel.anchorNode == null) { sel.addRange(old); }\n    else if (gecko) { this.startGracePeriod(); }\n  }\n  this.rememberSelection();\n};\n\nContentEditableInput.prototype.startGracePeriod = function () {\n    var this$1 = this;\n\n  clearTimeout(this.gracePeriod);\n  this.gracePeriod = setTimeout(function () {\n    this$1.gracePeriod = false;\n    if (this$1.selectionChanged())\n      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n  }, 20);\n};\n\nContentEditableInput.prototype.showMultipleSelections = function (info) {\n  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n};\n\nContentEditableInput.prototype.rememberSelection = function () {\n  var sel = window.getSelection();\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n};\n\nContentEditableInput.prototype.selectionInEditor = function () {\n  var sel = window.getSelection();\n  if (!sel.rangeCount) { return false }\n  var node = sel.getRangeAt(0).commonAncestorContainer;\n  return contains(this.div, node)\n};\n\nContentEditableInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\") {\n    if (!this.selectionInEditor())\n      { this.showSelection(this.prepareSelection(), true); }\n    this.div.focus();\n  }\n};\nContentEditableInput.prototype.blur = function () { this.div.blur(); };\nContentEditableInput.prototype.getField = function () { return this.div };\n\nContentEditableInput.prototype.supportsTouch = function () { return true };\n\nContentEditableInput.prototype.receivedFocus = function () {\n  var input = this;\n  if (this.selectionInEditor())\n    { this.pollSelection(); }\n  else\n    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n  function poll() {\n    if (input.cm.state.focused) {\n      input.pollSelection();\n      input.polling.set(input.cm.options.pollInterval, poll);\n    }\n  }\n  this.polling.set(this.cm.options.pollInterval, poll);\n};\n\nContentEditableInput.prototype.selectionChanged = function () {\n  var sel = window.getSelection();\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n};\n\nContentEditableInput.prototype.pollSelection = function () {\n  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n  var sel = window.getSelection(), cm = this.cm;\n  // On Android Chrome (version 56, at least), backspacing into an\n  // uneditable block element will put the cursor in that element,\n  // and then, because it's not editable, hide the virtual keyboard.\n  // Because Android doesn't allow us to actually detect backspace\n  // presses in a sane way, this code checks for when that happens\n  // and simulates a backspace press in this case.\n  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\n    this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n    this.blur();\n    this.focus();\n    return\n  }\n  if (this.composing) { return }\n  this.rememberSelection();\n  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (anchor && head) { runInOp(cm, function () {\n    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n  }); }\n};\n\nContentEditableInput.prototype.pollContent = function () {\n  if (this.readDOMTimeout != null) {\n    clearTimeout(this.readDOMTimeout);\n    this.readDOMTimeout = null;\n  }\n\n  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n  var from = sel.from(), to = sel.to();\n  if (from.ch == 0 && from.line > cm.firstLine())\n    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n    { to = Pos(to.line + 1, 0); }\n  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n  var fromIndex, fromLine, fromNode;\n  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n    fromLine = lineNo(display.view[0].line);\n    fromNode = display.view[0].node;\n  } else {\n    fromLine = lineNo(display.view[fromIndex].line);\n    fromNode = display.view[fromIndex - 1].node.nextSibling;\n  }\n  var toIndex = findViewIndex(cm, to.line);\n  var toLine, toNode;\n  if (toIndex == display.view.length - 1) {\n    toLine = display.viewTo - 1;\n    toNode = display.lineDiv.lastChild;\n  } else {\n    toLine = lineNo(display.view[toIndex + 1].line) - 1;\n    toNode = display.view[toIndex + 1].node.previousSibling;\n  }\n\n  if (!fromNode) { return false }\n  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n  while (newText.length > 1 && oldText.length > 1) {\n    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n    else { break }\n  }\n\n  var cutFront = 0, cutEnd = 0;\n  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n    { ++cutFront; }\n  var newBot = lst(newText), oldBot = lst(oldText);\n  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                           oldBot.length - (oldText.length == 1 ? cutFront : 0));\n  while (cutEnd < maxCutEnd &&\n         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n    { ++cutEnd; }\n  // Try to move start of change to start of selection if ambiguous\n  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n    while (cutFront && cutFront > from.ch &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n      cutFront--;\n      cutEnd++;\n    }\n  }\n\n  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n  newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n  var chFrom = Pos(fromLine, cutFront);\n  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n    replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n    return true\n  }\n};\n\nContentEditableInput.prototype.ensurePolled = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.reset = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.forceCompositionEnd = function () {\n  if (!this.composing) { return }\n  clearTimeout(this.readDOMTimeout);\n  this.composing = null;\n  this.updateFromDOM();\n  this.div.blur();\n  this.div.focus();\n};\nContentEditableInput.prototype.readFromDOMSoon = function () {\n    var this$1 = this;\n\n  if (this.readDOMTimeout != null) { return }\n  this.readDOMTimeout = setTimeout(function () {\n    this$1.readDOMTimeout = null;\n    if (this$1.composing) {\n      if (this$1.composing.done) { this$1.composing = null; }\n      else { return }\n    }\n    this$1.updateFromDOM();\n  }, 80);\n};\n\nContentEditableInput.prototype.updateFromDOM = function () {\n    var this$1 = this;\n\n  if (this.cm.isReadOnly() || !this.pollContent())\n    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n};\n\nContentEditableInput.prototype.setUneditable = function (node) {\n  node.contentEditable = \"false\";\n};\n\nContentEditableInput.prototype.onKeyPress = function (e) {\n  if (e.charCode == 0) { return }\n  e.preventDefault();\n  if (!this.cm.isReadOnly())\n    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n};\n\nContentEditableInput.prototype.readOnlyChanged = function (val) {\n  this.div.contentEditable = String(val != \"nocursor\");\n};\n\nContentEditableInput.prototype.onContextMenu = function () {};\nContentEditableInput.prototype.resetPosition = function () {};\n\nContentEditableInput.prototype.needsContentAttribute = true;\n\nfunction posToDOM(cm, pos) {\n  var view = findViewForLine(cm, pos.line);\n  if (!view || view.hidden) { return null }\n  var line = getLine(cm.doc, pos.line);\n  var info = mapFromLineView(view, line, pos.line);\n\n  var order = getOrder(line, cm.doc.direction), side = \"left\";\n  if (order) {\n    var partPos = getBidiPartAt(order, pos.ch);\n    side = partPos % 2 ? \"right\" : \"left\";\n  }\n  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n  result.offset = result.collapse == \"right\" ? result.end : result.start;\n  return result\n}\n\nfunction isInGutter(node) {\n  for (var scan = node; scan; scan = scan.parentNode)\n    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n  return false\n}\n\nfunction badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\nfunction domTextBetween(cm, from, to, fromLine, toLine) {\n  var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n  function close() {\n    if (closing) {\n      text += lineSep;\n      closing = false;\n    }\n  }\n  function addText(str) {\n    if (str) {\n      close();\n      text += str;\n    }\n  }\n  function walk(node) {\n    if (node.nodeType == 1) {\n      var cmText = node.getAttribute(\"cm-text\");\n      if (cmText != null) {\n        addText(cmText || node.textContent.replace(/\\u200b/g, \"\"));\n        return\n      }\n      var markerID = node.getAttribute(\"cm-marker\"), range$$1;\n      if (markerID) {\n        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n        if (found.length && (range$$1 = found[0].find(0)))\n          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\n        return\n      }\n      if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);\n      if (isBlock) { close(); }\n      for (var i = 0; i < node.childNodes.length; i++)\n        { walk(node.childNodes[i]); }\n      if (isBlock) { closing = true; }\n    } else if (node.nodeType == 3) {\n      addText(node.nodeValue);\n    }\n  }\n  for (;;) {\n    walk(from);\n    if (from == to) { break }\n    from = from.nextSibling;\n  }\n  return text\n}\n\nfunction domToPos(cm, node, offset) {\n  var lineNode;\n  if (node == cm.display.lineDiv) {\n    lineNode = cm.display.lineDiv.childNodes[offset];\n    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n    node = null; offset = 0;\n  } else {\n    for (lineNode = node;; lineNode = lineNode.parentNode) {\n      if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n    }\n  }\n  for (var i = 0; i < cm.display.view.length; i++) {\n    var lineView = cm.display.view[i];\n    if (lineView.node == lineNode)\n      { return locateNodeInLineView(lineView, node, offset) }\n  }\n}\n\nfunction locateNodeInLineView(lineView, node, offset) {\n  var wrapper = lineView.text.firstChild, bad = false;\n  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n  if (node == wrapper) {\n    bad = true;\n    node = wrapper.childNodes[offset];\n    offset = 0;\n    if (!node) {\n      var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n      return badPos(Pos(lineNo(line), line.text.length), bad)\n    }\n  }\n\n  var textNode = node.nodeType == 3 ? node : null, topNode = node;\n  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n    textNode = node.firstChild;\n    if (offset) { offset = textNode.nodeValue.length; }\n  }\n  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n  var measure = lineView.measure, maps = measure.maps;\n\n  function find(textNode, topNode, offset) {\n    for (var i = -1; i < (maps ? maps.length : 0); i++) {\n      var map$$1 = i < 0 ? measure.map : maps[i];\n      for (var j = 0; j < map$$1.length; j += 3) {\n        var curNode = map$$1[j + 2];\n        if (curNode == textNode || curNode == topNode) {\n          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n          var ch = map$$1[j] + offset;\n          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\n          return Pos(line, ch)\n        }\n      }\n    }\n  }\n  var found = find(textNode, topNode, offset);\n  if (found) { return badPos(found, bad) }\n\n  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n    found = find(after, after.firstChild, 0);\n    if (found)\n      { return badPos(Pos(found.line, found.ch - dist), bad) }\n    else\n      { dist += after.textContent.length; }\n  }\n  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n    found = find(before, before.firstChild, -1);\n    if (found)\n      { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n    else\n      { dist$1 += before.textContent.length; }\n  }\n}\n\n// TEXTAREA INPUT STYLE\n\nvar TextareaInput = function(cm) {\n  this.cm = cm;\n  // See input.poll and input.reset\n  this.prevInput = \"\";\n\n  // Flag that indicates whether we expect input to appear real soon\n  // now (after some event like 'keypress' or 'input') and are\n  // polling intensively.\n  this.pollingFast = false;\n  // Self-resetting timeout for the poller\n  this.polling = new Delayed();\n  // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n  this.hasSelection = false;\n  this.composing = null;\n};\n\nTextareaInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = this.cm;\n\n  // Wraps and hides input textarea\n  var div = this.wrapper = hiddenTextarea();\n  // The semihidden textarea that is focused when the editor is\n  // focused, and receives input.\n  var te = this.textarea = div.firstChild;\n  display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\n  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n  if (ios) { te.style.width = \"0px\"; }\n\n  on(te, \"input\", function () {\n    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n    input.poll();\n  });\n\n  on(te, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n    cm.state.pasteIncoming = true;\n    input.fastPoll();\n  });\n\n  function prepareCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.setSelections(ranges.ranges, null, sel_dontScroll);\n      } else {\n        input.prevInput = \"\";\n        te.value = ranges.text.join(\"\\n\");\n        selectInput(te);\n      }\n    }\n    if (e.type == \"cut\") { cm.state.cutIncoming = true; }\n  }\n  on(te, \"cut\", prepareCopyCut);\n  on(te, \"copy\", prepareCopyCut);\n\n  on(display.scroller, \"paste\", function (e) {\n    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n    cm.state.pasteIncoming = true;\n    input.focus();\n  });\n\n  // Prevent normal selection in the editor (we handle our own)\n  on(display.lineSpace, \"selectstart\", function (e) {\n    if (!eventInWidget(display, e)) { e_preventDefault(e); }\n  });\n\n  on(te, \"compositionstart\", function () {\n    var start = cm.getCursor(\"from\");\n    if (input.composing) { input.composing.range.clear(); }\n    input.composing = {\n      start: start,\n      range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n    };\n  });\n  on(te, \"compositionend\", function () {\n    if (input.composing) {\n      input.poll();\n      input.composing.range.clear();\n      input.composing = null;\n    }\n  });\n};\n\nTextareaInput.prototype.prepareSelection = function () {\n  // Redraw the selection and/or cursor\n  var cm = this.cm, display = cm.display, doc = cm.doc;\n  var result = prepareSelection(cm);\n\n  // Move the hidden textarea near the cursor to prevent scrolling artifacts\n  if (cm.options.moveInputWithCursor) {\n    var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                        headPos.top + lineOff.top - wrapOff.top));\n    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                         headPos.left + lineOff.left - wrapOff.left));\n  }\n\n  return result\n};\n\nTextareaInput.prototype.showSelection = function (drawn) {\n  var cm = this.cm, display = cm.display;\n  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n  removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n  if (drawn.teTop != null) {\n    this.wrapper.style.top = drawn.teTop + \"px\";\n    this.wrapper.style.left = drawn.teLeft + \"px\";\n  }\n};\n\n// Reset the input to correspond to the selection (or to be empty,\n// when not typing and nothing is selected)\nTextareaInput.prototype.reset = function (typing) {\n  if (this.contextMenuPending || this.composing) { return }\n  var cm = this.cm;\n  if (cm.somethingSelected()) {\n    this.prevInput = \"\";\n    var content = cm.getSelection();\n    this.textarea.value = content;\n    if (cm.state.focused) { selectInput(this.textarea); }\n    if (ie && ie_version >= 9) { this.hasSelection = content; }\n  } else if (!typing) {\n    this.prevInput = this.textarea.value = \"\";\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n  }\n};\n\nTextareaInput.prototype.getField = function () { return this.textarea };\n\nTextareaInput.prototype.supportsTouch = function () { return false };\n\nTextareaInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n    try { this.textarea.focus(); }\n    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n  }\n};\n\nTextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\nTextareaInput.prototype.resetPosition = function () {\n  this.wrapper.style.top = this.wrapper.style.left = 0;\n};\n\nTextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n// Poll for input changes, using the normal rate of polling. This\n// runs as long as the editor is focused.\nTextareaInput.prototype.slowPoll = function () {\n    var this$1 = this;\n\n  if (this.pollingFast) { return }\n  this.polling.set(this.cm.options.pollInterval, function () {\n    this$1.poll();\n    if (this$1.cm.state.focused) { this$1.slowPoll(); }\n  });\n};\n\n// When an event has just come in that is likely to add or change\n// something in the input textarea, we poll faster, to ensure that\n// the change appears on the screen quickly.\nTextareaInput.prototype.fastPoll = function () {\n  var missed = false, input = this;\n  input.pollingFast = true;\n  function p() {\n    var changed = input.poll();\n    if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n    else {input.pollingFast = false; input.slowPoll();}\n  }\n  input.polling.set(20, p);\n};\n\n// Read input from the textarea, and update the document to match.\n// When something is selected, it is present in the textarea, and\n// selected (unless it is huge, in which case a placeholder is\n// used). When nothing is selected, the cursor sits after previously\n// seen text (can be empty), which is stored in prevInput (we must\n// not reset the textarea when typing, because that breaks IME).\nTextareaInput.prototype.poll = function () {\n    var this$1 = this;\n\n  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n  // Since this is called a *lot*, try to bail out as cheaply as\n  // possible when it is clear that nothing happened. hasSelection\n  // will be the case when there is a lot of text in the textarea,\n  // in which case reading its value would be expensive.\n  if (this.contextMenuPending || !cm.state.focused ||\n      (hasSelection(input) && !prevInput && !this.composing) ||\n      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n    { return false }\n\n  var text = input.value;\n  // If nothing changed, bail.\n  if (text == prevInput && !cm.somethingSelected()) { return false }\n  // Work around nonsensical selection resetting in IE9/10, and\n  // inexplicable appearance of private area unicode characters on\n  // some key combos in Mac (#2689).\n  if (ie && ie_version >= 9 && this.hasSelection === text ||\n      mac && /[\\uf700-\\uf7ff]/.test(text)) {\n    cm.display.input.reset();\n    return false\n  }\n\n  if (cm.doc.sel == cm.display.selForContextMenu) {\n    var first = text.charCodeAt(0);\n    if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n    if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n  }\n  // Find the part of the input that is actually new\n  var same = 0, l = Math.min(prevInput.length, text.length);\n  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n  runInOp(cm, function () {\n    applyTextInput(cm, text.slice(same), prevInput.length - same,\n                   null, this$1.composing ? \"*compose\" : null);\n\n    // Don't leave long text in the textarea, since it makes further polling slow\n    if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n    else { this$1.prevInput = text; }\n\n    if (this$1.composing) {\n      this$1.composing.range.clear();\n      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                         {className: \"CodeMirror-composing\"});\n    }\n  });\n  return true\n};\n\nTextareaInput.prototype.ensurePolled = function () {\n  if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n};\n\nTextareaInput.prototype.onKeyPress = function () {\n  if (ie && ie_version >= 9) { this.hasSelection = null; }\n  this.fastPoll();\n};\n\nTextareaInput.prototype.onContextMenu = function (e) {\n  var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n  if (!pos || presto) { return } // Opera is difficult.\n\n  // Reset the current text selection only if the click is done outside of the selection\n  // and 'resetSelectionOnContextMenu' option is true.\n  var reset = cm.options.resetSelectionOnContextMenu;\n  if (reset && cm.doc.sel.contains(pos) == -1)\n    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n  input.wrapper.style.cssText = \"position: absolute\";\n  var wrapperBox = input.wrapper.getBoundingClientRect();\n  te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n  var oldScrollY;\n  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n  display.input.focus();\n  if (webkit) { window.scrollTo(null, oldScrollY); }\n  display.input.reset();\n  // Adds \"Select all\" to context menu in FF\n  if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n  input.contextMenuPending = true;\n  display.selForContextMenu = cm.doc.sel;\n  clearTimeout(display.detectingSelectAll);\n\n  // Select-all will be greyed out if there's nothing to select, so\n  // this adds a zero-width space so that we can later check whether\n  // it got selected.\n  function prepareSelectAllHack() {\n    if (te.selectionStart != null) {\n      var selected = cm.somethingSelected();\n      var extval = \"\\u200b\" + (selected ? te.value : \"\");\n      te.value = \"\\u21da\"; // Used to catch context-menu undo\n      te.value = extval;\n      input.prevInput = selected ? \"\" : \"\\u200b\";\n      te.selectionStart = 1; te.selectionEnd = extval.length;\n      // Re-set this, in case some other handler touched the\n      // selection in the meantime.\n      display.selForContextMenu = cm.doc.sel;\n    }\n  }\n  function rehide() {\n    input.contextMenuPending = false;\n    input.wrapper.style.cssText = oldWrapperCSS;\n    te.style.cssText = oldCSS;\n    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n    // Try to detect the user choosing select-all\n    if (te.selectionStart != null) {\n      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n      var i = 0, poll = function () {\n        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n            te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n          operation(cm, selectAll)(cm);\n        } else if (i++ < 10) {\n          display.detectingSelectAll = setTimeout(poll, 500);\n        } else {\n          display.selForContextMenu = null;\n          display.input.reset();\n        }\n      };\n      display.detectingSelectAll = setTimeout(poll, 200);\n    }\n  }\n\n  if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n  if (captureRightClick) {\n    e_stop(e);\n    var mouseup = function () {\n      off(window, \"mouseup\", mouseup);\n      setTimeout(rehide, 20);\n    };\n    on(window, \"mouseup\", mouseup);\n  } else {\n    setTimeout(rehide, 50);\n  }\n};\n\nTextareaInput.prototype.readOnlyChanged = function (val) {\n  if (!val) { this.reset(); }\n  this.textarea.disabled = val == \"nocursor\";\n};\n\nTextareaInput.prototype.setUneditable = function () {};\n\nTextareaInput.prototype.needsContentAttribute = false;\n\nfunction fromTextArea(textarea, options) {\n  options = options ? copyObj(options) : {};\n  options.value = textarea.value;\n  if (!options.tabindex && textarea.tabIndex)\n    { options.tabindex = textarea.tabIndex; }\n  if (!options.placeholder && textarea.placeholder)\n    { options.placeholder = textarea.placeholder; }\n  // Set autofocus to true if this textarea is focused, or if it has\n  // autofocus and no other element is focused.\n  if (options.autofocus == null) {\n    var hasFocus = activeElt();\n    options.autofocus = hasFocus == textarea ||\n      textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n  }\n\n  function save() {textarea.value = cm.getValue();}\n\n  var realSubmit;\n  if (textarea.form) {\n    on(textarea.form, \"submit\", save);\n    // Deplorable hack to make the submit method do the right thing.\n    if (!options.leaveSubmitMethodAlone) {\n      var form = textarea.form;\n      realSubmit = form.submit;\n      try {\n        var wrappedSubmit = form.submit = function () {\n          save();\n          form.submit = realSubmit;\n          form.submit();\n          form.submit = wrappedSubmit;\n        };\n      } catch(e) {}\n    }\n  }\n\n  options.finishInit = function (cm) {\n    cm.save = save;\n    cm.getTextArea = function () { return textarea; };\n    cm.toTextArea = function () {\n      cm.toTextArea = isNaN; // Prevent this from being ran twice\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        off(textarea.form, \"submit\", save);\n        if (typeof textarea.form.submit == \"function\")\n          { textarea.form.submit = realSubmit; }\n      }\n    };\n  };\n\n  textarea.style.display = \"none\";\n  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n    options);\n  return cm\n}\n\nfunction addLegacyProps(CodeMirror) {\n  CodeMirror.off = off;\n  CodeMirror.on = on;\n  CodeMirror.wheelEventPixels = wheelEventPixels;\n  CodeMirror.Doc = Doc;\n  CodeMirror.splitLines = splitLinesAuto;\n  CodeMirror.countColumn = countColumn;\n  CodeMirror.findColumn = findColumn;\n  CodeMirror.isWordChar = isWordCharBasic;\n  CodeMirror.Pass = Pass;\n  CodeMirror.signal = signal;\n  CodeMirror.Line = Line;\n  CodeMirror.changeEnd = changeEnd;\n  CodeMirror.scrollbarModel = scrollbarModel;\n  CodeMirror.Pos = Pos;\n  CodeMirror.cmpPos = cmp;\n  CodeMirror.modes = modes;\n  CodeMirror.mimeModes = mimeModes;\n  CodeMirror.resolveMode = resolveMode;\n  CodeMirror.getMode = getMode;\n  CodeMirror.modeExtensions = modeExtensions;\n  CodeMirror.extendMode = extendMode;\n  CodeMirror.copyState = copyState;\n  CodeMirror.startState = startState;\n  CodeMirror.innerMode = innerMode;\n  CodeMirror.commands = commands;\n  CodeMirror.keyMap = keyMap;\n  CodeMirror.keyName = keyName;\n  CodeMirror.isModifierKey = isModifierKey;\n  CodeMirror.lookupKey = lookupKey;\n  CodeMirror.normalizeKeyMap = normalizeKeyMap;\n  CodeMirror.StringStream = StringStream;\n  CodeMirror.SharedTextMarker = SharedTextMarker;\n  CodeMirror.TextMarker = TextMarker;\n  CodeMirror.LineWidget = LineWidget;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.addClass = addClass;\n  CodeMirror.contains = contains;\n  CodeMirror.rmClass = rmClass;\n  CodeMirror.keyNames = keyNames;\n}\n\n// EDITOR CONSTRUCTOR\n\ndefineOptions(CodeMirror$1);\n\naddEditorMethods(CodeMirror$1);\n\n// Set up methods on CodeMirror's prototype to redirect to the editor's document.\nvar dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\nfor (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n  { CodeMirror$1.prototype[prop] = (function(method) {\n    return function() {return method.apply(this.doc, arguments)}\n  })(Doc.prototype[prop]); } }\n\neventMixin(Doc);\n\n// INPUT HANDLING\n\nCodeMirror$1.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n// MODE DEFINITION AND QUERYING\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nCodeMirror$1.defineMode = function(name/*, mode, */) {\n  if (!CodeMirror$1.defaults.mode && name != \"null\") { CodeMirror$1.defaults.mode = name; }\n  defineMode.apply(this, arguments);\n};\n\nCodeMirror$1.defineMIME = defineMIME;\n\n// Minimal default mode.\nCodeMirror$1.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\nCodeMirror$1.defineMIME(\"text/plain\", \"null\");\n\n// EXTENSIONS\n\nCodeMirror$1.defineExtension = function (name, func) {\n  CodeMirror$1.prototype[name] = func;\n};\nCodeMirror$1.defineDocExtension = function (name, func) {\n  Doc.prototype[name] = func;\n};\n\nCodeMirror$1.fromTextArea = fromTextArea;\n\naddLegacyProps(CodeMirror$1);\n\nCodeMirror$1.version = \"5.31.0\";\n\nreturn CodeMirror$1;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/codemirror/lib/codemirror.js\n// module id = 8U58\n// module chunks = 0","exports = module.exports = require(\"../../css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".cm-s-eclipse span.cm-meta{color:#ff1717}.cm-s-eclipse span.cm-keyword{line-height:1em;font-weight:700;color:#7f0055}.cm-s-eclipse span.cm-atom{color:#219}.cm-s-eclipse span.cm-number{color:#164}.cm-s-eclipse span.cm-def{color:#00f}.cm-s-eclipse span.cm-variable{color:#000}.cm-s-eclipse span.cm-type,.cm-s-eclipse span.cm-variable-2,.cm-s-eclipse span.cm-variable-3{color:#0000c0}.cm-s-eclipse span.cm-operator,.cm-s-eclipse span.cm-property{color:#000}.cm-s-eclipse span.cm-comment{color:#3f7f5f}.cm-s-eclipse span.cm-string{color:#2a00ff}.cm-s-eclipse span.cm-string-2{color:#f50}.cm-s-eclipse span.cm-qualifier{color:#555}.cm-s-eclipse span.cm-builtin{color:#30a}.cm-s-eclipse span.cm-bracket{color:#cc7}.cm-s-eclipse span.cm-tag{color:#170}.cm-s-eclipse span.cm-attribute{color:#00c}.cm-s-eclipse span.cm-link{color:#219}.cm-s-eclipse span.cm-error{color:red}.cm-s-eclipse .CodeMirror-activeline-background{background:#e8f2ff}.cm-s-eclipse .CodeMirror-matchingbracket{outline:1px solid grey;color:#000!important}\", \"\", {\"version\":3,\"sources\":[\"/home/travis/build/voorhoede/manifiesta/node_modules/codemirror/theme/eclipse.css\"],\"names\":[],\"mappings\":\"AAAA,2BAA6B,aAAe,CAAE,AAC9C,8BAAgC,gBAAiB,AAAC,gBAAkB,AAAC,aAAe,CAAE,AACtF,2BAA6B,UAAY,CAAE,AAC3C,6BAA+B,UAAY,CAAE,AAC7C,0BAA4B,UAAY,CAAE,AAC1C,+BAAiC,UAAa,CAAE,AAEhD,6FAA+D,aAAe,CAAE,AAEhF,8DAAiC,UAAa,CAAE,AAChD,8BAAgC,aAAe,CAAE,AACjD,6BAA+B,aAAe,CAAE,AAChD,+BAAiC,UAAY,CAAE,AAC/C,gCAAkC,UAAY,CAAE,AAChD,8BAAgC,UAAY,CAAE,AAC9C,8BAAgC,UAAY,CAAE,AAC9C,0BAA4B,UAAY,CAAE,AAC1C,gCAAkC,UAAY,CAAE,AAChD,2BAA6B,UAAY,CAAE,AAC3C,4BAA8B,SAAY,CAAE,AAE5C,gDAAkD,kBAAoB,CAAE,AACxE,0CAA4C,uBAAuB,AAAC,oBAAuB,CAAE\",\"file\":\"eclipse.css\",\"sourcesContent\":[\".cm-s-eclipse span.cm-meta { color: #FF1717; }\\n.cm-s-eclipse span.cm-keyword { line-height: 1em; font-weight: bold; color: #7F0055; }\\n.cm-s-eclipse span.cm-atom { color: #219; }\\n.cm-s-eclipse span.cm-number { color: #164; }\\n.cm-s-eclipse span.cm-def { color: #00f; }\\n.cm-s-eclipse span.cm-variable { color: black; }\\n.cm-s-eclipse span.cm-variable-2 { color: #0000C0; }\\n.cm-s-eclipse span.cm-variable-3, .cm-s-eclipse span.cm-type { color: #0000C0; }\\n.cm-s-eclipse span.cm-property { color: black; }\\n.cm-s-eclipse span.cm-operator { color: black; }\\n.cm-s-eclipse span.cm-comment { color: #3F7F5F; }\\n.cm-s-eclipse span.cm-string { color: #2A00FF; }\\n.cm-s-eclipse span.cm-string-2 { color: #f50; }\\n.cm-s-eclipse span.cm-qualifier { color: #555; }\\n.cm-s-eclipse span.cm-builtin { color: #30a; }\\n.cm-s-eclipse span.cm-bracket { color: #cc7; }\\n.cm-s-eclipse span.cm-tag { color: #170; }\\n.cm-s-eclipse span.cm-attribute { color: #00c; }\\n.cm-s-eclipse span.cm-link { color: #219; }\\n.cm-s-eclipse span.cm-error { color: #f00; }\\n\\n.cm-s-eclipse .CodeMirror-activeline-background { background: #e8f2ff; }\\n.cm-s-eclipse .CodeMirror-matchingbracket { outline:1px solid grey; color:black !important; }\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader?{\"minimize\":true,\"sourceMap\":true}!./node_modules/codemirror/theme/eclipse.css\n// module id = CjAo\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-66e75edd\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../../node_modules/sass-loader/lib/loader.js?{\\\"sourceMap\\\":true}!./manifest-editor.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"6d73906a\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/extract-text-webpack-plugin/dist/loader.js?{\"omit\":1,\"remove\":true}!./node_modules/vue-style-loader!./node_modules/css-loader?{\"minimize\":true,\"sourceMap\":true}!./node_modules/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-66e75edd\",\"scoped\":false,\"hasInlineConfig\":false}!./node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/components/manifest-editor/manifest-editor.scss\n// module id = GypT\n// module chunks = 0","exports = module.exports = require(\"../../css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-fat-cursor-mark{background-color:rgba(20,255,20,.5)}.cm-animate-fat-cursor,.cm-fat-cursor-mark{-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite}.cm-animate-fat-cursor{width:auto;border:0;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:blue}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-invalidchar,.cm-s-default .cm-error{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:none;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:none!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:none}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}.CodeMirror-focused div.CodeMirror-cursors,div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:\\\"\\\"}span.CodeMirror-selectedtext{background:none}\", \"\", {\"version\":3,\"sources\":[\"/home/travis/build/voorhoede/manifiesta/node_modules/codemirror/lib/codemirror.css\"],\"names\":[],\"mappings\":\"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\",\"file\":\"codemirror.css\",\"sourcesContent\":[\"/* BASICS */\\n\\n.CodeMirror {\\n  /* Set height, width, borders, and global font properties here */\\n  font-family: monospace;\\n  height: 300px;\\n  color: black;\\n  direction: ltr;\\n}\\n\\n/* PADDING */\\n\\n.CodeMirror-lines {\\n  padding: 4px 0; /* Vertical padding around content */\\n}\\n.CodeMirror pre {\\n  padding: 0 4px; /* Horizontal padding of content */\\n}\\n\\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\\n  background-color: white; /* The little square between H and V scrollbars */\\n}\\n\\n/* GUTTER */\\n\\n.CodeMirror-gutters {\\n  border-right: 1px solid #ddd;\\n  background-color: #f7f7f7;\\n  white-space: nowrap;\\n}\\n.CodeMirror-linenumbers {}\\n.CodeMirror-linenumber {\\n  padding: 0 3px 0 5px;\\n  min-width: 20px;\\n  text-align: right;\\n  color: #999;\\n  white-space: nowrap;\\n}\\n\\n.CodeMirror-guttermarker { color: black; }\\n.CodeMirror-guttermarker-subtle { color: #999; }\\n\\n/* CURSOR */\\n\\n.CodeMirror-cursor {\\n  border-left: 1px solid black;\\n  border-right: none;\\n  width: 0;\\n}\\n/* Shown when moving in bi-directional text */\\n.CodeMirror div.CodeMirror-secondarycursor {\\n  border-left: 1px solid silver;\\n}\\n.cm-fat-cursor .CodeMirror-cursor {\\n  width: auto;\\n  border: 0 !important;\\n  background: #7e7;\\n}\\n.cm-fat-cursor div.CodeMirror-cursors {\\n  z-index: 1;\\n}\\n.cm-fat-cursor-mark {\\n  background-color: rgba(20, 255, 20, 0.5);\\n  -webkit-animation: blink 1.06s steps(1) infinite;\\n  -moz-animation: blink 1.06s steps(1) infinite;\\n  animation: blink 1.06s steps(1) infinite;\\n}\\n.cm-animate-fat-cursor {\\n  width: auto;\\n  border: 0;\\n  -webkit-animation: blink 1.06s steps(1) infinite;\\n  -moz-animation: blink 1.06s steps(1) infinite;\\n  animation: blink 1.06s steps(1) infinite;\\n  background-color: #7e7;\\n}\\n@-moz-keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n@-webkit-keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n@keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n\\n/* Can style cursor different in overwrite (non-insert) mode */\\n.CodeMirror-overwrite .CodeMirror-cursor {}\\n\\n.cm-tab { display: inline-block; text-decoration: inherit; }\\n\\n.CodeMirror-rulers {\\n  position: absolute;\\n  left: 0; right: 0; top: -50px; bottom: -20px;\\n  overflow: hidden;\\n}\\n.CodeMirror-ruler {\\n  border-left: 1px solid #ccc;\\n  top: 0; bottom: 0;\\n  position: absolute;\\n}\\n\\n/* DEFAULT THEME */\\n\\n.cm-s-default .cm-header {color: blue;}\\n.cm-s-default .cm-quote {color: #090;}\\n.cm-negative {color: #d44;}\\n.cm-positive {color: #292;}\\n.cm-header, .cm-strong {font-weight: bold;}\\n.cm-em {font-style: italic;}\\n.cm-link {text-decoration: underline;}\\n.cm-strikethrough {text-decoration: line-through;}\\n\\n.cm-s-default .cm-keyword {color: #708;}\\n.cm-s-default .cm-atom {color: #219;}\\n.cm-s-default .cm-number {color: #164;}\\n.cm-s-default .cm-def {color: #00f;}\\n.cm-s-default .cm-variable,\\n.cm-s-default .cm-punctuation,\\n.cm-s-default .cm-property,\\n.cm-s-default .cm-operator {}\\n.cm-s-default .cm-variable-2 {color: #05a;}\\n.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}\\n.cm-s-default .cm-comment {color: #a50;}\\n.cm-s-default .cm-string {color: #a11;}\\n.cm-s-default .cm-string-2 {color: #f50;}\\n.cm-s-default .cm-meta {color: #555;}\\n.cm-s-default .cm-qualifier {color: #555;}\\n.cm-s-default .cm-builtin {color: #30a;}\\n.cm-s-default .cm-bracket {color: #997;}\\n.cm-s-default .cm-tag {color: #170;}\\n.cm-s-default .cm-attribute {color: #00c;}\\n.cm-s-default .cm-hr {color: #999;}\\n.cm-s-default .cm-link {color: #00c;}\\n\\n.cm-s-default .cm-error {color: #f00;}\\n.cm-invalidchar {color: #f00;}\\n\\n.CodeMirror-composing { border-bottom: 2px solid; }\\n\\n/* Default styles for common addons */\\n\\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;}\\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;}\\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }\\n.CodeMirror-activeline-background {background: #e8f2ff;}\\n\\n/* STOP */\\n\\n/* The rest of this file contains styles related to the mechanics of\\n   the editor. You probably shouldn't touch them. */\\n\\n.CodeMirror {\\n  position: relative;\\n  overflow: hidden;\\n  background: white;\\n}\\n\\n.CodeMirror-scroll {\\n  overflow: scroll !important; /* Things will break if this is overridden */\\n  /* 30px is the magic margin used to hide the element's real scrollbars */\\n  /* See overflow: hidden in .CodeMirror */\\n  margin-bottom: -30px; margin-right: -30px;\\n  padding-bottom: 30px;\\n  height: 100%;\\n  outline: none; /* Prevent dragging from highlighting the element */\\n  position: relative;\\n}\\n.CodeMirror-sizer {\\n  position: relative;\\n  border-right: 30px solid transparent;\\n}\\n\\n/* The fake, visible scrollbars. Used to force redraw during scrolling\\n   before actual scrolling happens, thus preventing shaking and\\n   flickering artifacts. */\\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\\n  position: absolute;\\n  z-index: 6;\\n  display: none;\\n}\\n.CodeMirror-vscrollbar {\\n  right: 0; top: 0;\\n  overflow-x: hidden;\\n  overflow-y: scroll;\\n}\\n.CodeMirror-hscrollbar {\\n  bottom: 0; left: 0;\\n  overflow-y: hidden;\\n  overflow-x: scroll;\\n}\\n.CodeMirror-scrollbar-filler {\\n  right: 0; bottom: 0;\\n}\\n.CodeMirror-gutter-filler {\\n  left: 0; bottom: 0;\\n}\\n\\n.CodeMirror-gutters {\\n  position: absolute; left: 0; top: 0;\\n  min-height: 100%;\\n  z-index: 3;\\n}\\n.CodeMirror-gutter {\\n  white-space: normal;\\n  height: 100%;\\n  display: inline-block;\\n  vertical-align: top;\\n  margin-bottom: -30px;\\n}\\n.CodeMirror-gutter-wrapper {\\n  position: absolute;\\n  z-index: 4;\\n  background: none !important;\\n  border: none !important;\\n}\\n.CodeMirror-gutter-background {\\n  position: absolute;\\n  top: 0; bottom: 0;\\n  z-index: 4;\\n}\\n.CodeMirror-gutter-elt {\\n  position: absolute;\\n  cursor: default;\\n  z-index: 4;\\n}\\n.CodeMirror-gutter-wrapper ::selection { background-color: transparent }\\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }\\n\\n.CodeMirror-lines {\\n  cursor: text;\\n  min-height: 1px; /* prevents collapsing before first draw */\\n}\\n.CodeMirror pre {\\n  /* Reset some styles that the rest of the page might have set */\\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\\n  border-width: 0;\\n  background: transparent;\\n  font-family: inherit;\\n  font-size: inherit;\\n  margin: 0;\\n  white-space: pre;\\n  word-wrap: normal;\\n  line-height: inherit;\\n  color: inherit;\\n  z-index: 2;\\n  position: relative;\\n  overflow: visible;\\n  -webkit-tap-highlight-color: transparent;\\n  -webkit-font-variant-ligatures: contextual;\\n  font-variant-ligatures: contextual;\\n}\\n.CodeMirror-wrap pre {\\n  word-wrap: break-word;\\n  white-space: pre-wrap;\\n  word-break: normal;\\n}\\n\\n.CodeMirror-linebackground {\\n  position: absolute;\\n  left: 0; right: 0; top: 0; bottom: 0;\\n  z-index: 0;\\n}\\n\\n.CodeMirror-linewidget {\\n  position: relative;\\n  z-index: 2;\\n  overflow: auto;\\n}\\n\\n.CodeMirror-widget {}\\n\\n.CodeMirror-rtl pre { direction: rtl; }\\n\\n.CodeMirror-code {\\n  outline: none;\\n}\\n\\n/* Force content-box sizing for the elements where we expect it */\\n.CodeMirror-scroll,\\n.CodeMirror-sizer,\\n.CodeMirror-gutter,\\n.CodeMirror-gutters,\\n.CodeMirror-linenumber {\\n  -moz-box-sizing: content-box;\\n  box-sizing: content-box;\\n}\\n\\n.CodeMirror-measure {\\n  position: absolute;\\n  width: 100%;\\n  height: 0;\\n  overflow: hidden;\\n  visibility: hidden;\\n}\\n\\n.CodeMirror-cursor {\\n  position: absolute;\\n  pointer-events: none;\\n}\\n.CodeMirror-measure pre { position: static; }\\n\\ndiv.CodeMirror-cursors {\\n  visibility: hidden;\\n  position: relative;\\n  z-index: 3;\\n}\\ndiv.CodeMirror-dragcursors {\\n  visibility: visible;\\n}\\n\\n.CodeMirror-focused div.CodeMirror-cursors {\\n  visibility: visible;\\n}\\n\\n.CodeMirror-selected { background: #d9d9d9; }\\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\\n.CodeMirror-crosshair { cursor: crosshair; }\\n.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }\\n.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }\\n\\n.cm-searching {\\n  background-color: #ffa;\\n  background-color: rgba(255, 255, 0, .4);\\n}\\n\\n/* Used to force a border model for a node */\\n.cm-force-border { padding-right: .1px; }\\n\\n@media print {\\n  /* Hide the cursor when printing */\\n  .CodeMirror div.CodeMirror-cursors {\\n    visibility: hidden;\\n  }\\n}\\n\\n/* See issue #2901 */\\n.cm-tab-wrap-hack:after { content: ''; }\\n\\n/* Help users use markselection to safely style text background */\\nspan.CodeMirror-selectedtext { background: none; }\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader?{\"minimize\":true,\"sourceMap\":true}!./node_modules/codemirror/lib/codemirror.css\n// module id = IXFo\n// module chunks = 0","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\nexports.i(require(\"-!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/codemirror/lib/codemirror.css\"), \"\");\nexports.i(require(\"-!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/codemirror/addon/lint/lint.css\"), \"\");\nexports.i(require(\"-!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/codemirror/theme/eclipse.css\"), \"\");\n\n// module\nexports.push([module.id, \"a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:\\\"\\\";content:none}table{border-collapse:collapse;border-spacing:0}*{-webkit-box-sizing:border-box;box-sizing:border-box}:after,:before{-webkit-box-sizing:inherit;box-sizing:inherit}body{font-family:Roboto,sans-serif;color:#212121}.a11y-only{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;padding:0;position:absolute;width:1px}.manifest-editor{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;position:relative}.CodeMirror{position:absolute;width:100%;height:100%;border-top:1px solid #e0e0e0;border-bottom:1px solid #e0e0e0}.CodeMirror pre{font-size:1em;font-family:monospace;line-height:1.6}\", \"\", {\"version\":3,\"sources\":[\"/home/travis/build/voorhoede/manifiesta/src/components/manifest-editor/manifest-editor.scss\"],\"names\":[],\"mappings\":\"AAOA,2ZAaE,SAAU,AACV,UAAW,AACX,SAAU,AACV,eAAgB,AAChB,aAAc,AACd,uBAAyB,CAC1B,AAGD,8EAEE,aAAe,CAChB,AACD,KACE,aAAe,CAChB,AACD,MACE,eAAiB,CAClB,AACD,aACE,WAAa,CACd,AACD,oDAEE,WAAY,AACZ,YAAc,CACf,AACD,MACE,yBAA0B,AAC1B,gBAAkB,CACnB,AACD,EACE,8BAA+B,AACvB,qBAAuB,CAChC,AACD,eACE,2BAA4B,AACpB,kBAAoB,CAC7B,AACD,KACE,8BAAkC,AAClC,aAAe,CAChB,AACD,WACE,SAAU,AACV,mBAAoB,AACpB,WAAY,AACZ,YAAa,AACb,UAAW,AACX,kBAAmB,AACnB,SAAW,CACZ,AACD,iBACE,mBAAoB,AAChB,oBAAqB,AACjB,YAAa,AACrB,iBAAmB,CACpB,AACD,YACE,kBAAmB,AACnB,WAAY,AACZ,YAAa,AACb,6BAA8B,AAC9B,+BAAiC,CAClC,AACD,gBACE,cAAe,AACf,sBAAuB,AACvB,eAAiB,CAClB\",\"file\":\"manifest-editor.scss\",\"sourcesContent\":[\"/* http://meyerweb.com/eric/tools/css/reset/\\n   v2.0 | 20110126\\n   License: none (public domain)\\n*/\\n@import url(../../../node_modules/codemirror/lib/codemirror.css);\\n@import url(../../../node_modules/codemirror/addon/lint/lint.css);\\n@import url(../../../node_modules/codemirror/theme/eclipse.css);\\nhtml, body, div, span, applet, object, iframe,\\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\\na, abbr, acronym, address, big, cite, code,\\ndel, dfn, em, img, ins, kbd, q, s, samp,\\nsmall, strike, strong, sub, sup, tt, var,\\nb, u, i, center,\\ndl, dt, dd, ol, ul, li,\\nfieldset, form, label, legend,\\ntable, caption, tbody, tfoot, thead, tr, th, td,\\narticle, aside, canvas, details, embed,\\nfigure, figcaption, footer, header, hgroup,\\nmenu, nav, output, ruby, section, summary,\\ntime, mark, audio, video {\\n  margin: 0;\\n  padding: 0;\\n  border: 0;\\n  font-size: 100%;\\n  font: inherit;\\n  vertical-align: baseline;\\n}\\n\\n/* HTML5 display-role reset for older browsers */\\narticle, aside, details, figcaption, figure,\\nfooter, header, hgroup, menu, nav, section {\\n  display: block;\\n}\\nbody {\\n  line-height: 1;\\n}\\nol, ul {\\n  list-style: none;\\n}\\nblockquote, q {\\n  quotes: none;\\n}\\nblockquote:before, blockquote:after,\\nq:before, q:after {\\n  content: '';\\n  content: none;\\n}\\ntable {\\n  border-collapse: collapse;\\n  border-spacing: 0;\\n}\\n* {\\n  -webkit-box-sizing: border-box;\\n          box-sizing: border-box;\\n}\\n*:before, *:after {\\n  -webkit-box-sizing: inherit;\\n          box-sizing: inherit;\\n}\\nbody {\\n  font-family: 'Roboto', sans-serif;\\n  color: #212121;\\n}\\n.a11y-only {\\n  border: 0;\\n  clip: rect(0 0 0 0);\\n  height: 1px;\\n  margin: -1px;\\n  padding: 0;\\n  position: absolute;\\n  width: 1px;\\n}\\n.manifest-editor {\\n  -webkit-box-flex: 1;\\n      -ms-flex-positive: 1;\\n          flex-grow: 1;\\n  position: relative;\\n}\\n.CodeMirror {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  border-top: 1px solid #E0E0E0;\\n  border-bottom: 1px solid #E0E0E0;\\n}\\n.CodeMirror pre {\\n  font-size: 1em;\\n  font-family: monospace;\\n  line-height: 1.6;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader?{\"minimize\":true,\"sourceMap\":true}!./node_modules/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-66e75edd\",\"scoped\":false,\"hasInlineConfig\":false}!./node_modules/sass-loader/lib/loader.js?{\"sourceMap\":true}!./src/components/manifest-editor/manifest-editor.scss\n// module id = IrVb\n// module chunks = 0","function injectStyle (ssrContext) {\n  require(\"!!../extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-5c584404\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../vue-loader/lib/selector?type=styles&index=0!./codemirror.vue\")\n}\nvar normalizeComponent = require(\"!../vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../vue-loader/lib/selector?type=script&index=0!./codemirror.vue\"\n/* template */\nimport __vue_template__ from \"!!../vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-5c584404\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../vue-loader/lib/selector?type=template&index=0!./codemirror.vue\"\n/* template functional */\n  var __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-codemirror-lite/codemirror.vue\n// module id = Lgoy\n// module chunks = 0","/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/punycode/punycode.js\n// module id = MsCo\n// module chunks = 0","export default {\n  'af': 'Afrikaans',\n  'af-ZA': 'Afrikaans (South Africa)',\n  'ar': 'Arabic',\n  'ar-AE': 'Arabic (U.A.E.)',\n  'ar-BH': 'Arabic (Bahrain)',\n  'ar-DZ': 'Arabic (Algeria)',\n  'ar-EG': 'Arabic (Egypt)',\n  'ar-IQ': 'Arabic (Iraq)',\n  'ar-JO': 'Arabic (Jordan)',\n  'ar-KW': 'Arabic (Kuwait)',\n  'ar-LB': 'Arabic (Lebanon)',\n  'ar-LY': 'Arabic (Libya)',\n  'ar-MA': 'Arabic (Morocco)',\n  'ar-OM': 'Arabic (Oman)',\n  'ar-QA': 'Arabic (Qatar)',\n  'ar-SA': 'Arabic (Saudi Arabia)',\n  'ar-SY': 'Arabic (Syria)',\n  'ar-TN': 'Arabic (Tunisia)',\n  'ar-YE': 'Arabic (Yemen)',\n  'az': 'Azeri (Latin)',\n  'az-AZ': 'Azeri (Latin) (Azerbaijan)',\n  'az-Cyrl-AZ': 'Azeri (Cyrillic) (Azerbaijan)',\n  'be': 'Belarusian',\n  'be-BY': 'Belarusian (Belarus)',\n  'bg': 'Bulgarian',\n  'bg-BG': 'Bulgarian (Bulgaria)',\n  'bs-BA': 'Bosnian (Bosnia and Herzegovina)',\n  'ca': 'Catalan',\n  'ca-ES': 'Catalan (Spain)',\n  'cs': 'Czech',\n  'cs-CZ': 'Czech (Czech Republic)',\n  'cy': 'Welsh',\n  'cy-GB': 'Welsh (United Kingdom)',\n  'da': 'Danish',\n  'da-DK': 'Danish (Denmark)',\n  'de': 'German',\n  'de-AT': 'German (Austria)',\n  'de-CH': 'German (Switzerland)',\n  'de-DE': 'German (Germany)',\n  'de-LI': 'German (Liechtenstein)',\n  'de-LU': 'German (Luxembourg)',\n  'dv': 'Divehi',\n  'dv-MV': 'Divehi (Maldives)',\n  'el': 'Greek',\n  'el-GR': 'Greek (Greece)',\n  'en': 'English',\n  'en-AU': 'English (Australia)',\n  'en-BZ': 'English (Belize)',\n  'en-CA': 'English (Canada)',\n  'en-CB': 'English (Caribbean)',\n  'en-GB': 'English (United Kingdom)',\n  'en-IE': 'English (Ireland)',\n  'en-JM': 'English (Jamaica)',\n  'en-NZ': 'English (New Zealand)',\n  'en-PH': 'English (Republic of the Philippines)',\n  'en-TT': 'English (Trinidad and Tobago)',\n  'en-US': 'English (United States)',\n  'en-ZA': 'English (South Africa)',\n  'en-ZW': 'English (Zimbabwe)',\n  'eo': 'Esperanto',\n  'es': 'Spanish',\n  'es-AR': 'Spanish (Argentina)',\n  'es-BO': 'Spanish (Bolivia)',\n  'es-CL': 'Spanish (Chile)',\n  'es-CO': 'Spanish (Colombia)',\n  'es-CR': 'Spanish (Costa Rica)',\n  'es-DO': 'Spanish (Dominican Republic)',\n  'es-EC': 'Spanish (Ecuador)',\n  'es-ES': 'Spanish (Spain)',\n  'es-GT': 'Spanish (Guatemala)',\n  'es-HN': 'Spanish (Honduras)',\n  'es-MX': 'Spanish (Mexico)',\n  'es-NI': 'Spanish (Nicaragua)',\n  'es-PA': 'Spanish (Panama)',\n  'es-PE': 'Spanish (Peru)',\n  'es-PR': 'Spanish (Puerto Rico)',\n  'es-PY': 'Spanish (Paraguay)',\n  'es-SV': 'Spanish (El Salvador)',\n  'es-UY': 'Spanish (Uruguay)',\n  'es-VE': 'Spanish (Venezuela)',\n  'et': 'Estonian',\n  'et-EE': 'Estonian (Estonia)',\n  'eu': 'Basque',\n  'eu-ES': 'Basque (Spain)',\n  'fa': 'Farsi',\n  'fa-IR': 'Farsi (Iran)',\n  'fi': 'Finnish',\n  'fi-FI': 'Finnish (Finland)',\n  'fo': 'Faroese',\n  'fo-FO': 'Faroese (Faroe Islands)',\n  'fr': 'French',\n  'fr-BE': 'French (Belgium)',\n  'fr-CA': 'French (Canada)',\n  'fr-CH': 'French (Switzerland)',\n  'fr-FR': 'French (France)',\n  'fr-LU': 'French (Luxembourg)',\n  'fr-MC': 'French (Principality of Monaco)',\n  'gl': 'Galician',\n  'gl-ES': 'Galician (Spain)',\n  'gu': 'Gujarati',\n  'gu-IN': 'Gujarati (India)',\n  'he': 'Hebrew',\n  'he-IL': 'Hebrew (Israel)',\n  'hi': 'Hindi',\n  'hi-IN': 'Hindi (India)',\n  'hr': 'Croatian',\n  'hr-BA': 'Croatian (Bosnia and Herzegovina)',\n  'hr-HR': 'Croatian (Croatia)',\n  'hu': 'Hungarian',\n  'hu-HU': 'Hungarian (Hungary)',\n  'hy': 'Armenian',\n  'hy-AM': 'Armenian (Armenia)',\n  'id': 'Indonesian',\n  'id-ID': 'Indonesian (Indonesia)',\n  'is': 'Icelandic',\n  'is-IS': 'Icelandic (Iceland)',\n  'it': 'Italian',\n  'it-CH': 'Italian (Switzerland)',\n  'it-IT': 'Italian (Italy)',\n  'ja': 'Japanese',\n  'ja-JP': 'Japanese (Japan)',\n  'ka': 'Georgian',\n  'ka-GE': 'Georgian (Georgia)',\n  'kk': 'Kazakh',\n  'kk-KZ': 'Kazakh (Kazakhstan)',\n  'kn': 'Kannada',\n  'kn-IN': 'Kannada (India)',\n  'ko': 'Korean',\n  'ko-KR': 'Korean (Korea)',\n  'kok': 'Konkani',\n  'kok-IN': 'Konkani (India)',\n  'ky': 'Kyrgyz',\n  'ky-KG': 'Kyrgyz (Kyrgyzstan)',\n  'lt': 'Lithuanian',\n  'lt-LT': 'Lithuanian (Lithuania)',\n  'lv': 'Latvian',\n  'lv-LV': 'Latvian (Latvia)',\n  'mi': 'Maori',\n  'mi-NZ': 'Maori (New Zealand)',\n  'mk': 'FYRO Macedonian',\n  'mk-MK': 'FYRO Macedonian (Former Yugoslav Republic of Macedonia)',\n  'mn': 'Mongolian',\n  'mn-MN': 'Mongolian (Mongolia)',\n  'mr': 'Marathi',\n  'mr-IN': 'Marathi (India)',\n  'ms': 'Malay',\n  'ms-BN': 'Malay (Brunei Darussalam)',\n  'ms-MY': 'Malay (Malaysia)',\n  'mt': 'Maltese',\n  'mt-MT': 'Maltese (Malta)',\n  'nb': 'Norwegian (Bokm?l)',\n  'nb-NO': 'Norwegian (Bokm?l) (Norway)',\n  'nl': 'Dutch',\n  'nl-BE': 'Dutch (Belgium)',\n  'nl-NL': 'Dutch (Netherlands)',\n  'nn-NO': 'Norwegian (Nynorsk) (Norway)',\n  'ns': 'Northern Sotho',\n  'ns-ZA': 'Northern Sotho (South Africa)',\n  'pa': 'Punjabi',\n  'pa-IN': 'Punjabi (India)',\n  'pl': 'Polish',\n  'pl-PL': 'Polish (Poland)',\n  'ps': 'Pashto',\n  'ps-AR': 'Pashto (Afghanistan)',\n  'pt': 'Portuguese',\n  'pt-BR': 'Portuguese (Brazil)',\n  'pt-PT': 'Portuguese (Portugal)',\n  'qu': 'Quechua',\n  'qu-BO': 'Quechua (Bolivia)',\n  'qu-EC': 'Quechua (Ecuador)',\n  'qu-PE': 'Quechua (Peru)',\n  'ro': 'Romanian',\n  'ro-RO': 'Romanian (Romania)',\n  'ru': 'Russian',\n  'ru-RU': 'Russian (Russia)',\n  'sa': 'Sanskrit',\n  'sa-IN': 'Sanskrit (India)',\n  'se': 'Sami',\n  'se-FI': 'Sami (Finland)',\n  'se-NO': 'Sami (Norway)',\n  'se-SE': 'Sami (Sweden)',\n  'sk': 'Slovak',\n  'sk-SK': 'Slovak (Slovakia)',\n  'sl': 'Slovenian',\n  'sl-SI': 'Slovenian (Slovenia)',\n  'sq': 'Albanian',\n  'sq-AL': 'Albanian (Albania)',\n  'sr-BA': 'Serbian (Latin) (Bosnia and Herzegovina)',\n  'sr-Cyrl-BA': 'Serbian (Cyrillic) (Bosnia and Herzegovina)',\n  'sr-SP': 'Serbian (Latin) (Serbia and Montenegro)',\n  'sr-Cyrl-SP': 'Serbian (Cyrillic) (Serbia and Montenegro)',\n  'sv': 'Swedish',\n  'sv-FI': 'Swedish (Finland)',\n  'sv-SE': 'Swedish (Sweden)',\n  'sw': 'Swahili',\n  'sw-KE': 'Swahili (Kenya)',\n  'syr': 'Syriac',\n  'syr-SY': 'Syriac (Syria)',\n  'ta': 'Tamil',\n  'ta-IN': 'Tamil (India)',\n  'te': 'Telugu',\n  'te-IN': 'Telugu (India)',\n  'th': 'Thai',\n  'th-TH': 'Thai (Thailand)',\n  'tl': 'Tagalog',\n  'tl-PH': 'Tagalog (Philippines)',\n  'tn': 'Tswana',\n  'tn-ZA': 'Tswana (South Africa)',\n  'tr': 'Turkish',\n  'tr-TR': 'Turkish (Turkey)',\n  'tt': 'Tatar',\n  'tt-RU': 'Tatar (Russia)',\n  'ts': 'Tsonga',\n  'uk': 'Ukrainian',\n  'uk-UA': 'Ukrainian (Ukraine)',\n  'ur': 'Urdu',\n  'ur-PK': 'Urdu (Islamic Republic of Pakistan)',\n  'uz': 'Uzbek (Latin)',\n  'uz-UZ': 'Uzbek (Latin) (Uzbekistan)',\n  'uz-Cyrl-UZ': 'Uzbek (Cyrillic) (Uzbekistan)',\n  'vi': 'Vietnamese',\n  'vi-VN': 'Vietnamese (Viet Nam)',\n  'xh': 'Xhosa',\n  'xh-ZA': 'Xhosa (South Africa)',\n  'zh': 'Chinese',\n  'zh-CN': 'Chinese (S)',\n  'zh-HK': 'Chinese (Hong Kong)',\n  'zh-MO': 'Chinese (Macau)',\n  'zh-SG': 'Chinese (Singapore)',\n  'zh-TW': 'Chinese (T)',\n  'zu': 'Zulu',\n  'zu-ZA': 'Zulu (South Africa)'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/language-tags.js","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"manifest-editor\"},[_c('codemirror',{attrs:{\"options\":_vm.options},model:{value:(_vm.code),callback:function ($$v) {_vm.code=$$v},expression:\"code\"}})],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-66e75edd\",\"hasScoped\":false,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/manifest-editor/manifest-editor.vue\n// module id = Qudd\n// module chunks = 0","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('textarea')}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-5c584404\",\"hasScoped\":false,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./node_modules/vue-codemirror-lite/codemirror.vue\n// module id = R2wf\n// module chunks = 0","export default function debounce (func, wait, immediate) {\n  let timeout\n  return function (...args) {\n    clearTimeout(timeout)\n    timeout = setTimeout(() => {\n      timeout = null\n      if (!immediate) func.apply(this, args)\n    }, wait)\n    if (immediate && !timeout) func.apply(this, [...args])\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/debounce.js","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/url/url.js\n// module id = UZ5h\n// module chunks = 0","exports = module.exports = require(\"../css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".CodeMirror-code{font-family:Menlo,Monaco,Consolas,Courier New,monospace}\", \"\", {\"version\":3,\"sources\":[\"/home/travis/build/voorhoede/manifiesta/node_modules/vue-codemirror-lite/codemirror.vue\"],\"names\":[],\"mappings\":\"AACA,iBACE,uDAA+D,CAChE\",\"file\":\"codemirror.vue\",\"sourcesContent\":[\"\\n.CodeMirror-code {\\n  font-family: Menlo, Monaco, Consolas, \\\"Courier New\\\", monospace;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader?{\"minimize\":true,\"sourceMap\":true}!./node_modules/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-5c584404\",\"scoped\":false,\"hasInlineConfig\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./node_modules/vue-codemirror-lite/codemirror.vue\n// module id = V5hE\n// module chunks = 0","import { CodeMirror } from 'vue-codemirror-lite'\nimport { Validator } from 'jsonschema'\nimport schema from './manifest-schema'\nimport jsonLint from 'json-lint'\nrequire('../../node_modules/codemirror/mode/javascript/javascript')\nrequire('../../node_modules/codemirror/addon/lint/lint')\n\nconst validator = new Validator()\nconst tabSize = 2\nconst prefix = 'instance.'\n\nCodeMirror.registerHelper('lint', 'json', text => {\n  const lint = jsonLint(text, {})\n  if (lint.error) {\n    return [{\n      from: CodeMirror.Pos(lint.line - 1, lint.character - 1),\n      to: CodeMirror.Pos(lint.line - 1, lint.character),\n      message: lint.error\n    }]\n  } else {\n    const { errors } = validator.validate(JSON.parse(text), schema)\n    const messages = []\n    if (errors) {\n      errors.forEach(error => {\n        messages.push(generateErrorMessage(error, text))\n      })\n\n      return messages\n    }\n  }\n\n  return []\n})\n\nfunction generateErrorMessage (error, text) {\n  if (error.name === 'required') {\n    return {\n      from: CodeMirror.Pos(0, 1),\n      to: CodeMirror.Pos(0, 1),\n      message: removePrefix(error.stack)\n    }\n  } else {\n    const position = getLinePosition(error, text)\n    return {\n      from: CodeMirror.Pos(position.from.line, position.from.char),\n      to: CodeMirror.Pos(position.to.line, position.to.char),\n      message: removePrefix(error.stack)\n    }\n  }\n}\n\nfunction getLinePosition (error, text) {\n  const propertyName = error.property.substr('instance.'.length)\n  const pattern = new RegExp('(\\\\s*\"' + propertyName + '\"\\\\s*:\\\\s*)(.*)\\\\s*,\\\\s*$')\n  const lines = text.split('\\n')\n  const lineIndex = lines.findIndex(line => line.includes(propertyName))\n  const line = lines[lineIndex].replace('\\t', ' '.repeat(tabSize))\n  const matches = line.match(pattern)\n  const fromChar = matches[1].length - 1\n  const toChar = fromChar + matches[2].length\n\n  return {\n    from: {\n      line: lineIndex,\n      char: fromChar\n    },\n    to: {\n      line: lineIndex,\n      char: toChar\n    }\n  }\n}\n\nfunction removePrefix (str) {\n  return str.replace(prefix, '')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/codemirror-lint-manifest.js","'use strict';\n\nvar helpers = require('./helpers');\n\n/** @type ValidatorResult */\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\nvar SchemaError = helpers.SchemaError;\n\nvar attribute = {};\n\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'exclusiveMinimum': true,\n  'exclusiveMaximum': true,\n  'additionalItems': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true\n};\n\n/**\n * @name validators\n */\nvar validators = attribute.validators = {};\n\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.type = function validateType (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      return v.id && ('<' + v.id + '>') || (v+'');\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list,\n    });\n  }\n  return result;\n};\n\nfunction testSchema(instance, options, ctx, callback, schema){\n  var res = this.validateSchema(instance, schema, options, ctx);\n  if (! res.valid && callback instanceof Function) {\n    callback(res);\n  }\n  return res.valid;\n}\n\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.anyOf = function validateAnyOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(schema.anyOf)){\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n  if (!schema.anyOf.some(\n    testSchema.bind(\n      this, instance, options, ctx, function(res){inner.importErrors(res);}\n      ))) {\n    var list = schema.anyOf.map(function (v, i) {\n      return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n    });\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.allOf = function validateAllOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.allOf)){\n    throw new SchemaError(\"allOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function(v, i){\n    var valid = self.validateSchema(instance, v, options, ctx);\n    if(!valid.valid){\n      var msg = (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n      result.addError({\n        name: 'allOf',\n        argument: { id: msg, length: valid.errors.length, valid: valid },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.oneOf = function validateOneOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.oneOf)){\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(\n    testSchema.bind(\n      this, instance, options, ctx, function(res) {inner.importErrors(res);}\n      ) ).length;\n  var list = schema.oneOf.map(function (v, i) {\n    return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n  });\n  if (count!==1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.properties = function validateProperties (instance, schema, options, ctx) {\n  if(instance === undefined || !(instance instanceof Object)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n  for (var property in properties) {\n    var prop = (instance || undefined) && instance[property];\n    var res = this.validateSchema(prop, properties[property], options, ctx.makeChild(properties[property], property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n  return result;\n};\n\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existance tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\nfunction testAdditionalProperty (instance, schema, options, ctx, property, result) {\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"additionalProperty \" + JSON.stringify(property) + \" exists in instance when not allowed\",\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {\n  if(instance === undefined) return;\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n    for (var pattern in patternProperties) {\n      var expr = new RegExp(pattern);\n      if (!expr.test(property)) {\n        continue;\n      }\n      test = false;\n      var res = this.validateSchema(instance[property], patternProperties[pattern], options, ctx.makeChild(patternProperties[pattern], property));\n      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {\n  if(instance === undefined) return;\n  if(!this.types.object(instance)) return;\n  // if patternProperties is defined then we'll test when that one is called instead\n  if (schema.patternProperties) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minProperties = function validateMinProperties (instance, schema, options, ctx) {\n  if (!instance || typeof instance !== 'object') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties,\n    })\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {\n  if (!instance || typeof instance !== 'object') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.items = function validateItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var self = this;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined || !schema.items) {\n    return result;\n  }\n  instance.every(function (value, i) {\n    var items = Array.isArray(schema.items) ? (schema.items[i] || schema.additionalItems) : schema.items;\n    if (items === undefined) {\n      return true;\n    }\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\",\n      });\n      return false;\n    }\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minimum = function validateMinimum (instance, schema, options, ctx) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = true;\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    valid = instance > schema.minimum;\n  } else {\n    valid = instance >= schema.minimum;\n  }\n  if (!valid) {\n    result.addError({\n      name: 'minimum',\n      argument: schema.minimum,\n      message: \"must have a minimum value of \" + schema.minimum,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maximum = function validateMaximum (instance, schema, options, ctx) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid;\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    valid = instance < schema.maximum;\n  } else {\n    valid = instance <= schema.maximum;\n  }\n  if (!valid) {\n    result.addError({\n      name: 'maximum',\n      argument: schema.maximum,\n      message: \"must have a maximum value of \" + schema.maximum,\n    });\n  }\n  return result;\n};\n\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy (instance, schema, options, ctx, validationType, errorMessage) {\n  if (typeof instance !== 'number') {\n    return null;\n  }\n\n  var validationArgument = schema[validationType];\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n\n  var maxDecimals = Math.max(instanceDecimals , divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument:  validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument)\n    });\n  }\n\n  return result;\n};\n\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {\n return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.required = function validateRequired (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatability with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\"\n    });\n  } else if (instance && typeof instance==='object' && Array.isArray(schema.required)) {\n    schema.required.forEach(function(n){\n      if(instance[n]===undefined){\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n),\n        });\n      }\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.pattern = function validatePattern (instance, schema, options, ctx) {\n  if (typeof instance !== 'string') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.match(schema.pattern)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\nvalidators.format = function validateFormat (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minLength = function validateMinLength (instance, schema, options, ctx) {\n  if (!(typeof instance === 'string')) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxLength = function validateMaxLength (instance, schema, options, ctx) {\n  if (!(typeof instance === 'string')) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minItems = function validateMinItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxItems = function validateMaxItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates that every item in an instance array is unique, when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(instance)) {\n    return result;\n  }\n  function testArrays (v, i, a) {\n    for (var j = i + 1; j < a.length; j++) if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n    return true;\n  }\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\nfunction testArrays (v, i, a) {\n  var j, len = a.length;\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  if (!Array.isArray(instance)) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.dependencies = function validateDependencies (instance, schema, options, ctx) {\n  if (!instance || typeof instance != 'object') {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath,\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if(result.instance !== res.instance) result.instance = res.instance;\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath,\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['enum'] = function validateEnum (instance, schema, options, ctx) {\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['const'] = function validateEnum (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const'],\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {\n  var self = this;\n  if(instance===undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if(!notTypes) return null;\n  if(!Array.isArray(notTypes)) notTypes=[notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var schemaId = type && type.id && ('<' + type.id + '>') || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId,\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsonschema/lib/attribute.js\n// module id = YeLu\n// module chunks = 0","(function( glob, undefined ) {\n\nvar rnumber = /[0-9]/,\n\trnewline = /(\\r\\n|\\r|\\n)/,\n\trevidence = /\\r\\n|\\r|\\n/,\n\trwhitespace = /(\\s|\\t)/,\n\trvalidsolidus = /\\\\(\"|\\\\|\\/|b|f|n|r|t|u[0-9]{4})/,\n\trE = /^(\\-|\\+)?[0-9]/;\n\n\n// Leeeeeeerrrrroooyy Jennkkkiiinnnss\nfunction JSONLint( json, options ) {\n\tvar self = this;\n\n\tif ( ! ( self instanceof JSONLint ) ) {\n\t\treturn new JSONLint( json, options );\n\t}\n\n\t// Argument handling\n\tself.json = json || '';\n\tself.options = options || {};\n\tself.lower = self.json.toLowerCase();\n\n\t// Allow comments by default\n\tif ( ! self.options.hasOwnProperty( 'comments' ) ) {\n\t\tself.options.comments = true;\n\t}\n\n\t// Internals\n\tself.c = '';\n\tself.i = -1;\n\tself.length = self.json.length;\n\tself.line = 1;\n\tself.character = 0;\n\tself._evidence = self.json.split( revidence );\n\tself.endblock = '';\n\tself.commabreak = false;\n\n\ttry {\n\t\tself.render();\n\t} catch ( e ) {\n\t\tif ( typeof e != 'string' ) {\n\t\t\tthrow e;\n\t\t}\n\t\tself.error = e;\n\t\tself.setEvidence();\n\t}\n}\n\n\n// Meta (Please change contact info for republishing with changes)\nJSONLint.contact = \"Corey Hart (corey@codenothing.com)\";\nJSONLint.version = '[VERSION]';\nJSONLint.date = '[DATE]';\n\n\n// Methods\nJSONLint.prototype = {\n\n\t// Rendering Start\n\trender: function(){\n\t\tvar self = this, peek = '', content = false;\n\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( self.options.comments && self.c == '/' ) {\n\t\t\t\tpeek = self.json[ self.i + 1 ];\n\t\t\t\tif ( peek == '*' ) {\n\t\t\t\t\tself.multicomment();\n\t\t\t\t}\n\t\t\t\telse if ( peek == '/' ) {\n\t\t\t\t\tself.comment();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow \"Unknown character '/', maybe a comment?\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t}\n\t\t\telse if ( rwhitespace.exec( self.c ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if ( content ) {\n\t\t\t\tthrow \"Unknown character '\" + self.c + \"', expecting end of file.\";\n\t\t\t}\n\t\t\telse if ( self.c == '[' ) {\n\t\t\t\tcontent = true;\n\t\t\t\tself.array();\n\t\t\t}\n\t\t\telse if ( self.c == '{' ) {\n\t\t\t\tcontent = true;\n\t\t\t\tself.object();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow \"Unknown character '\" + self.c + \"', expecting opening block '{' or '[', or maybe a comment\";\n\t\t\t}\n\t\t}\n\n\t\t// Check for pure whitespace\n\t\tif ( ! content ) {\n\t\t\tthrow \"Invalid JSON, no content.\";\n\t\t}\n\t},\n\n\t// Multi line comment\n\tmulticomment: function(){\n\t\tvar self = this;\n\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( self.c == \"*\" && self.json[ self.i + 1 ] == \"/\" ) {\n\t\t\t\tself.i++;\n\t\t\t\tself.character++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t}\n\t\t}\n\t},\n\n\t// Single line comment\n\tcomment: function(){\n\t\tvar self = this;\n\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t},\n\n\t// Array Block\n\tarray: function(){\n\t\t// Keep reference of current endblock\n\t\tvar self = this,\n\t\t\t_endblock = self.endblock,\n\t\t\t_commabreak = self.commabreak,\n\t\t\tended = false;\n\n\t\tself.endblock = ']';\n\t\tself.commabreak = false;\n\t\twhile ( ( ended = self.value() ) !== true && self.i < self.length ) {\n\t\t\t// Do nothing, just wait for array values to finish\n\t\t}\n\n\t\tif ( ! ended ) {\n\t\t\tthrow \"EOF Error. Expecting closing ']'\";\n\t\t}\n\n\t\t// Reset previous endblock\n\t\tself.endblock = _endblock;\n\t\tself.commabreak = _commabreak;\n\t},\n\n\t// Object Block\n\tobject: function(){\n\t\t// Keep reference of current endblock\n\t\tvar self = this,\n\t\t\t_endblock = self.endblock,\n\t\t\t_commabreak = self.commabreak,\n\t\t\tfound = false, peek = '', empty = true;\n\n\t\tself.endblock = '}';\n\t\tself.commabreak = false;\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( self.options.comments && self.c == '/' ) {\n\t\t\t\tpeek = self.json[ self.i + 1 ];\n\t\t\t\tif ( peek == '*' ) {\n\t\t\t\t\tself.multicomment();\n\t\t\t\t}\n\t\t\t\telse if ( peek == '/' ) {\n\t\t\t\t\tself.comment();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow \"Unknown character '/', maybe a comment?\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t}\n\t\t\telse if ( rwhitespace.exec( self.c ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if ( self.c == '\"' ) {\n\t\t\t\tempty = false;\n\t\t\t\tif ( self.key() === true ) {\n\t\t\t\t\t// Reset old endblock\n\t\t\t\t\tself.endblock = _endblock;\n\t\t\t\t\tself.commabreak = _commabreak;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( empty && self.c == '}' ) {\n\t\t\t\tself.endblock = _endblock;\n\t\t\t\tself.commabreak = _commabreak;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow \"Unknown Character '\" + self.c + \"', expecting a string for key statement.\";\n\t\t\t}\n\t\t}\n\n\t\tif ( ! found ) {\n\t\t\tthrow \"EOF Error, expecting closing '}'.\";\n\t\t}\n\t},\n\n\t// Key Statement\n\tkey: function(){\n\t\tvar self = this;\n\t\tself.string();\n\n\t\tfor ( var peek = ''; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( self.options.comments && self.c == '/' ) {\n\t\t\t\tpeek = self.json[ self.i + 1 ];\n\t\t\t\tif ( peek == '*' ) {\n\t\t\t\t\tself.multicomment();\n\t\t\t\t}\n\t\t\t\telse if ( peek == '/' ) {\n\t\t\t\t\tself.comment();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow \"Unknown character '/', maybe a comment?\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t}\n\t\t\telse if ( rwhitespace.exec( self.c ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if ( self.c == \":\" ) {\n\t\t\t\treturn self.value();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow \"Unknown Character '\" + self.c + \"', expecting a semicolon.\";\n\t\t\t}\n\t\t}\n\t},\n\n\t// Value statement\n\tvalue: function(){\n\t\tvar self = this, peek = '';\n\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( self.options.comments && self.c == '/' ) {\n\t\t\t\tpeek = self.json[ self.i + 1 ];\n\t\t\t\tif ( peek == '*' ) {\n\t\t\t\t\tself.multicomment();\n\t\t\t\t}\n\t\t\t\telse if ( peek == '/' ) {\n\t\t\t\t\tself.comment();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow \"Unknown character '/', maybe a comment?\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t}\n\t\t\telse if ( rwhitespace.exec( self.c ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if ( self.c == '{' ) {\n\t\t\t\tself.object();\n\t\t\t\treturn self.endval();\n\t\t\t}\n\t\t\telse if ( self.c == '[' ) {\n\t\t\t\tself.array();\n\t\t\t\treturn self.endval();\n\t\t\t}\n\t\t\telse if ( self.c == '\"' ) {\n\t\t\t\tself.string();\n\t\t\t\treturn self.endval();\n\t\t\t}\n\t\t\telse if ( self.json.indexOf( 'true', self.i ) === self.i ) {\n\t\t\t\tself.i += 3;\n\t\t\t\tself.character += 3;\n\t\t\t\treturn self.endval();\n\t\t\t}\n\t\t\telse if ( self.json.indexOf( 'false', self.i ) === self.i ) {\n\t\t\t\tself.i += 4;\n\t\t\t\tself.character += 4;\n\t\t\t\treturn self.endval();\n\t\t\t}\n\t\t\telse if ( self.json.indexOf( 'null', self.i ) === self.i ) {\n\t\t\t\tself.i += 3;\n\t\t\t\tself.character += 3;\n\t\t\t\treturn self.endval();\n\t\t\t}\n\t\t\telse if ( self.c == '-' || rnumber.exec( self.c ) ) {\n\t\t\t\treturn self.numeric();\n\t\t\t}\n\t\t\telse if ( self.c == ']' && self.endblock == ']' ) {\n\t\t\t\tif ( self.commabreak ) {\n\t\t\t\t\tthrow \"Unexpected End Of Array Error. Expecting a value statement.\";\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow \"Unknown Character '\" + self.c + \"', expecting a value.\";\n\t\t\t}\n\t\t}\n\t},\n\n\t// String statement\n\tstring: function(){\n\t\tvar self = this, found = false, m;\n\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( self.c == \"\\\\\" ) {\n\t\t\t\tif ( ( m = rvalidsolidus.exec( self.json.substr( self.i ) ) ) && m.index === 0 ) {\n\t\t\t\t\tself.i += m[ 1 ].length;\n\t\t\t\t\tself.character += m[ 1 ].length;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow \"Invalid Reverse Solidus '\\\\' declaration.\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t}\n\t\t\telse if ( self.c == '\"' ) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Make sure close string is found\n\t\tif ( ! found ) {\n\t\t\tthrow \"EOF: No close string '\\\"' found.\";\n\t\t}\n\t},\n\n\t// Numeric Value\n\tnumeric: function(){\n\t\tvar self = this,\n\t\t\tnegative = true,\n\t\t\tdecimal = null,\n\t\t\te = null,\n\t\t\tpeek = '';\n\n\t\t// We need to jump back a character to catch the whole number\n\t\tself.i--;\n\t\tself.character--;\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\t// Handle initial negative sign\n\t\t\tif ( negative ) {\n\t\t\t\tnegative = false;\n\t\t\t\tif ( self.c == '-' ) {\n\t\t\t\t\tif ( ! rnumber.exec( self.json[ self.i + 1 ] ) ) {\n\t\t\t\t\t\tthrow \"Unknown Character '\" + self.c + \"' following a negative, expecting a numeric value.\";\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Only a single decimal is allowed in a numeric value\n\t\t\tif ( decimal && self.c == '.' ) {\n\t\t\t\tdecimal = false;\n\t\t\t\te = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Only a single e notation is allowed in a numeric value\n\t\t\telse if ( e && self.c.toLowerCase() == 'e' ) {\n\t\t\t\te = false;\n\t\t\t\tnegative = true;\n\t\t\t\tif ( rE.exec( self.json.substr( self.i + 1, 2 ) ) ) {\n\t\t\t\t\tself.character++;\n\t\t\t\t\tself.i++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tself.character++;\n\t\t\t\t\tthrow \"Unknown Character '\" + self.json[ self.i + 1 ] + \"' following e notation, expecting a numeric value.\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Normal Digit\n\t\t\telse if ( rnumber.exec( self.c ) ) {\n\t\t\t\tif ( decimal === null ) {\n\t\t\t\t\tdecimal = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Assume end of number, and allow endval to handle it\n\t\t\telse {\n\t\t\t\t// Jump back a character to include the current one\n\t\t\t\tself.i--;\n\t\t\t\tself.character--;\n\t\t\t\treturn self.endval();\n\t\t\t}\n\t\t}\n\t},\n\n\t// Ending a value statement\n\tendval: function(){\n\t\tvar self = this, peek = '';\n\t\tself.commabreak = false;\n\n\t\tfor ( ; ++self.i < self.length; ) {\n\t\t\tself.c = self.json[ self.i ];\n\t\t\tself.character++;\n\n\t\t\tif ( self.options.comments && self.c == '/' ) {\n\t\t\t\tpeek = self.json[ self.i + 1 ];\n\t\t\t\tif ( peek == '*' ) {\n\t\t\t\t\tself.multicomment();\n\t\t\t\t}\n\t\t\t\telse if ( peek == '/' ) {\n\t\t\t\t\tself.comment();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow \"Unknown character '/', maybe a comment?\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( rnewline.exec( self.c ) ) {\n\t\t\t\tself.line++;\n\t\t\t\tself.character = 0;\n\t\t\t}\n\t\t\telse if ( rwhitespace.exec( self.c ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if ( self.c == ',' ) {\n\t\t\t\tself.commabreak = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ( self.c == self.endblock ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow \"Unknown Character '\" + self.c + \"', expecting a comma or a closing '\" + self.endblock + \"'\";\n\t\t\t}\n\t\t}\n\t},\n\n\t// Expose line of the error\n\tsetEvidence: function(){\n\t\tvar self = this, start = self.line - 5, end = start + 8, evidence = '';\n\n\t\t// Min start\n\t\tif ( start < 0 ) {\n\t\t\tstart = 0;\n\t\t\tend = 8;\n\t\t}\n\n\t\t// Max end\n\t\tif ( end >= self._evidence.length ) {\n\t\t\tend = self._evidence.length;\n\t\t}\n\n\t\t// Evidence display\n\t\tfor ( ; start < end; start++ ) {\n\t\t\tevidence += ( start === ( self.line - 1 ) ? \"-> \" : \"   \" ) +\n\t\t\t\t( start + 1 ) + '| ' +\n\t\t\t\tself._evidence[ start ] + \"\\n\";\n\t\t}\n\n\t\t// Set the evidence display\n\t\tself.evidence = evidence;\n\t}\n};\n\n\n// Check for nodejs module system\nif ( typeof exports == 'object' && typeof module == 'object' ) {\n\tmodule.exports = JSONLint;\n}\n// In a browser\nelse {\n\tglob.JSONLint = JSONLint;\n}\n\n})( this );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/json-lint/jsonlint.js\n// module id = ZbcI\n// module chunks = 0","exports = module.exports = require(\"../../../css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".CodeMirror-lint-markers{width:16px}.CodeMirror-lint-tooltip{background-color:#ffd;border:1px solid #000;border-radius:4px 4px 4px 4px;color:#000;font-family:monospace;font-size:10pt;overflow:hidden;padding:2px 5px;position:fixed;white-space:pre;white-space:pre-wrap;z-index:100;max-width:600px;opacity:0;transition:opacity .4s;-moz-transition:opacity .4s;-webkit-transition:opacity .4s;-o-transition:opacity .4s;-ms-transition:opacity .4s}.CodeMirror-lint-mark-error,.CodeMirror-lint-mark-warning{background-position:0 100%;background-repeat:repeat-x}.CodeMirror-lint-mark-error{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==\\\")}.CodeMirror-lint-mark-warning{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=\\\")}.CodeMirror-lint-marker-error,.CodeMirror-lint-marker-warning{background-position:50%;background-repeat:no-repeat;cursor:pointer;display:inline-block;height:16px;width:16px;vertical-align:middle;position:relative}.CodeMirror-lint-message-error,.CodeMirror-lint-message-warning{padding-left:18px;background-position:0 0;background-repeat:no-repeat}.CodeMirror-lint-marker-error,.CodeMirror-lint-message-error{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=\\\")}.CodeMirror-lint-marker-warning,.CodeMirror-lint-message-warning{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=\\\")}.CodeMirror-lint-marker-multiple{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC\\\");background-repeat:no-repeat;background-position:100% 100%;width:100%;height:100%}\", \"\", {\"version\":3,\"sources\":[\"/home/travis/build/voorhoede/manifiesta/node_modules/codemirror/addon/lint/lint.css\"],\"names\":[],\"mappings\":\"AACA,yBACE,UAAY,CACb,AAED,yBACE,sBAAuB,AACvB,sBAAwB,AACxB,8BAA+B,AAC/B,WAAa,AACb,sBAAuB,AACvB,eAAgB,AAChB,gBAAiB,AACjB,gBAAiB,AACjB,eAAgB,AAChB,gBAAiB,AACjB,qBAAsB,AACtB,YAAa,AACb,gBAAiB,AACjB,UAAW,AACX,uBAAwB,AACxB,4BAA6B,AAC7B,+BAAgC,AAChC,0BAA2B,AAC3B,0BAA4B,CAC7B,AAED,0DACE,2BAAiC,AACjC,0BAA4B,CAC7B,AAED,4BACE,kTAEC,CACF,AAED,8BACE,8UAAgV,CACjV,AAED,8DACE,wBAAmC,AACnC,4BAA6B,AAC7B,eAAgB,AAChB,qBAAsB,AACtB,YAAa,AACb,WAAY,AACZ,sBAAuB,AACvB,iBAAmB,CACpB,AAED,gEACE,kBAAmB,AACnB,wBAA8B,AAC9B,2BAA6B,CAC9B,AAED,6DACE,kTAAoT,CACrT,AAED,iEACE,sWAAwW,CACzW,AAED,iCACE,uNAAwN,AACxN,4BAA6B,AAC7B,8BAAkC,AAClC,WAAY,AAAC,WAAa,CAC3B\",\"file\":\"lint.css\",\"sourcesContent\":[\"/* The lint marker gutter */\\n.CodeMirror-lint-markers {\\n  width: 16px;\\n}\\n\\n.CodeMirror-lint-tooltip {\\n  background-color: #ffd;\\n  border: 1px solid black;\\n  border-radius: 4px 4px 4px 4px;\\n  color: black;\\n  font-family: monospace;\\n  font-size: 10pt;\\n  overflow: hidden;\\n  padding: 2px 5px;\\n  position: fixed;\\n  white-space: pre;\\n  white-space: pre-wrap;\\n  z-index: 100;\\n  max-width: 600px;\\n  opacity: 0;\\n  transition: opacity .4s;\\n  -moz-transition: opacity .4s;\\n  -webkit-transition: opacity .4s;\\n  -o-transition: opacity .4s;\\n  -ms-transition: opacity .4s;\\n}\\n\\n.CodeMirror-lint-mark-error, .CodeMirror-lint-mark-warning {\\n  background-position: left bottom;\\n  background-repeat: repeat-x;\\n}\\n\\n.CodeMirror-lint-mark-error {\\n  background-image:\\n  url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==\\\")\\n  ;\\n}\\n\\n.CodeMirror-lint-mark-warning {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=\\\");\\n}\\n\\n.CodeMirror-lint-marker-error, .CodeMirror-lint-marker-warning {\\n  background-position: center center;\\n  background-repeat: no-repeat;\\n  cursor: pointer;\\n  display: inline-block;\\n  height: 16px;\\n  width: 16px;\\n  vertical-align: middle;\\n  position: relative;\\n}\\n\\n.CodeMirror-lint-message-error, .CodeMirror-lint-message-warning {\\n  padding-left: 18px;\\n  background-position: top left;\\n  background-repeat: no-repeat;\\n}\\n\\n.CodeMirror-lint-marker-error, .CodeMirror-lint-message-error {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=\\\");\\n}\\n\\n.CodeMirror-lint-marker-warning, .CodeMirror-lint-message-warning {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=\\\");\\n}\\n\\n.CodeMirror-lint-marker-multiple {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC\\\");\\n  background-repeat: no-repeat;\\n  background-position: right bottom;\\n  width: 100%; height: 100%;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader?{\"minimize\":true,\"sourceMap\":true}!./node_modules/codemirror/addon/lint/lint.css\n// module id = aSS6\n// module chunks = 0","import languageTags from './language-tags'\n\nexport default {\n  type: 'object',\n  properties: {\n    // https://www.w3.org/TR/appmanifest/#name-member\n    name: {\n      required: true,\n      type: 'string'\n    },\n    // https://www.w3.org/TR/appmanifest/#short_name-member\n    short_name: {\n      required: true,\n      type: 'string'\n    },\n    // https://www.w3.org/TR/appmanifest/#start_url-member\n    start_url: {\n      required: true,\n      type: 'string'\n    },\n    // https://www.w3.org/TR/appmanifest/#icons-member\n    icons: {\n      required: true,\n      type: 'array'\n    },\n    // https://www.w3.org/TR/appmanifest/#dir-member\n    dir: {\n      type: 'string',\n      enum: ['auto', 'ltr', 'rtl']\n    },\n    // https://www.w3.org/TR/appmanifest/#lang-member\n    lang: {\n      type: 'string',\n      enum: Object.keys(languageTags)\n    },\n    // https://www.w3.org/TR/appmanifest/#description-member\n    description: {\n      type: 'string'\n    },\n    // https://www.w3.org/TR/appmanifest/#scope-member\n    scope: {\n      type: 'string'\n    },\n    // https://www.w3.org/TR/appmanifest/#display-member\n    display: {\n      type: 'string',\n      enum: ['fullscreen', 'standalone', 'minimal-ui', 'browser']\n    },\n    // https://www.w3.org/TR/appmanifest/#orientation-member\n    orientation: {\n      type: 'string',\n      enum: ['any', 'natural', 'landscape', 'landscape-primary', 'landscape-secondary', 'portrait', 'portrait-primary', 'portrait-secondary']\n    },\n    // https://www.w3.org/TR/appmanifest/#serviceworker-member\n    serviceworker: {\n      type: 'object'\n    },\n    // https://www.w3.org/TR/appmanifest/#theme_color-member\n    theme_color: {\n      type: 'string'\n    },\n    // https://www.w3.org/TR/appmanifest/#related_applications-member\n    related_applications: {\n      type: 'array'\n    },\n    // https://www.w3.org/TR/appmanifest/#prefer_related_applications-member\n    prefer_related_applications: {\n      type: 'boolean'\n    },\n    // https://www.w3.org/TR/appmanifest/#background_color-member\n    background_color: {\n      type: 'string'\n    },\n    // https://www.w3.org/TR/appmanifest/#categories-member\n    categories: {\n      type: 'array'\n    },\n    // https://www.w3.org/TR/appmanifest/#screenshots-member\n    screenshots: {\n      type: 'array'\n    },\n    // https://www.w3.org/TR/appmanifest/#iarc_rating_id-member\n    iarc_rating_id: {\n      type: 'object'\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/manifest-schema.js","<template>\n  <textarea></textarea>\n</template>\n\n<script>\n  var CodeMirror = require('codemirror/lib/codemirror.js')\n  require('codemirror/lib/codemirror.css')\n  export default {\n    props: {\n      value: {\n        type: String,\n        default: ''\n      },\n      options: {\n        type: Object,\n        default: function () {\n          return {\n            mode: 'text/javascript',\n            lineNumbers: true,\n            lineWrapping: true\n          }\n        }\n      },\n    },\n    data: function () {\n      return {\n        skipNextChangeEvent: false\n      }\n    },\n    ready: function () {\n      var _this = this\n      this.editor = CodeMirror.fromTextArea(this.$el, this.options)\n      this.editor.setValue(this.value)\n      this.editor.on('change', function(cm) {\n        if (_this.skipNextChangeEvent) {\n          _this.skipNextChangeEvent = false\n          return\n        }\n        _this.value = cm.getValue()\n        if (!!_this.$emit) {\n          _this.$emit('change', cm.getValue())\n        }\n      })\n    },\n    mounted: function () {\n      var _this = this\n      this.editor = CodeMirror.fromTextArea(this.$el, this.options)\n      this.editor.setValue(this.value)\n      this.editor.on('change', function(cm) {\n        if (_this.skipNextChangeEvent) {\n          _this.skipNextChangeEvent = false\n          return\n        }\n        if (!!_this.$emit) {\n          _this.$emit('change', cm.getValue())\n          _this.$emit('input', cm.getValue())\n        }\n      })\n    },\n    watch: {\n      'value': function (newVal, oldVal) {\n        var editorValue = this.editor.getValue()\n        if (newVal !== editorValue) {\n          this.skipNextChangeEvent = true\n          var scrollInfo = this.editor.getScrollInfo()\n          this.editor.setValue(newVal)\n          this.editor.scrollTo(scrollInfo.left, scrollInfo.top)\n        }\n      },\n      'options': function (newOptions, oldVal) {\n        if (typeof newOptions === 'object') {\n          for (var optionName in newOptions) {\n            if (newOptions.hasOwnProperty(optionName)) {\n              this.editor.setOption(optionName, newOptions[optionName])\n            }\n          }\n        }\n      }\n    },\n    beforeDestroy: function () {\n      if (this.editor) {\n        this.editor.toTextArea()\n      }\n    }\n  }\n</script>\n\n<style>\n  .CodeMirror-code {\n    font-family: Menlo, Monaco, Consolas, \"Courier New\", monospace;\n  }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// node_modules/vue-codemirror-lite/codemirror.vue","var CodeMirror = require('codemirror/lib/codemirror.js')\nvar CmComponent = require('./codemirror.vue')\n\nconsole.log(CmComponent)\nCmComponent = CmComponent.default || CmComponent\n\nmodule.exports = {\n CodeMirror: CodeMirror,\n codemirror: CmComponent,\n install: function (Vue) {\n   Vue.component('codemirror', CmComponent)\n }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-codemirror-lite/index.js\n// module id = gZhU\n// module chunks = 0","'use strict';\n\nvar uri = require('url');\n\nvar ValidationError = exports.ValidationError = function ValidationError (message, instance, schema, propertyPath, name, argument) {\n  if (propertyPath) {\n    this.property = propertyPath;\n  }\n  if (message) {\n    this.message = message;\n  }\n  if (schema) {\n    if (schema.id) {\n      this.schema = schema.id;\n    } else {\n      this.schema = schema;\n    }\n  }\n  if (instance) {\n    this.instance = instance;\n  }\n  this.name = name;\n  this.argument = argument;\n  this.stack = this.toString();\n};\n\nValidationError.prototype.toString = function toString() {\n  return this.property + ' ' + this.message;\n};\n\nvar ValidatorResult = exports.ValidatorResult = function ValidatorResult(instance, schema, options, ctx) {\n  this.instance = instance;\n  this.schema = schema;\n  this.propertyPath = ctx.propertyPath;\n  this.errors = [];\n  this.throwError = options && options.throwError;\n  this.disableFormat = options && options.disableFormat === true;\n};\n\nValidatorResult.prototype.addError = function addError(detail) {\n  var err;\n  if (typeof detail == 'string') {\n    err = new ValidationError(detail, this.instance, this.schema, this.propertyPath);\n  } else {\n    if (!detail) throw new Error('Missing error detail');\n    if (!detail.message) throw new Error('Missing error message');\n    if (!detail.name) throw new Error('Missing validator type');\n    err = new ValidationError(detail.message, this.instance, this.schema, this.propertyPath, detail.name, detail.argument);\n  }\n\n  if (this.throwError) {\n    throw err;\n  }\n  this.errors.push(err);\n  return err;\n};\n\nValidatorResult.prototype.importErrors = function importErrors(res) {\n  if (typeof res == 'string' || (res && res.validatorType)) {\n    this.addError(res);\n  } else if (res && res.errors) {\n    Array.prototype.push.apply(this.errors, res.errors);\n  }\n};\n\nfunction stringizer (v,i){\n  return i+': '+v.toString()+'\\n';\n}\nValidatorResult.prototype.toString = function toString(res) {\n  return this.errors.map(stringizer).join('');\n};\n\nObject.defineProperty(ValidatorResult.prototype, \"valid\", { get: function() {\n  return !this.errors.length;\n} });\n\n/**\n * Describes a problem with a Schema which prevents validation of an instance\n * @name SchemaError\n * @constructor\n */\nvar SchemaError = exports.SchemaError = function SchemaError (msg, schema) {\n  this.message = msg;\n  this.schema = schema;\n  Error.call(this, msg);\n  Error.captureStackTrace(this, SchemaError);\n};\nSchemaError.prototype = Object.create(Error.prototype,\n  { constructor: {value: SchemaError, enumerable: false}\n  , name: {value: 'SchemaError', enumerable: false}\n  });\n\nvar SchemaContext = exports.SchemaContext = function SchemaContext (schema, options, propertyPath, base, schemas) {\n  this.schema = schema;\n  this.options = options;\n  this.propertyPath = propertyPath;\n  this.base = base;\n  this.schemas = schemas;\n};\n\nSchemaContext.prototype.resolve = function resolve (target) {\n  return uri.resolve(this.base, target);\n};\n\nSchemaContext.prototype.makeChild = function makeChild(schema, propertyName){\n  var propertyPath = (propertyName===undefined) ? this.propertyPath : this.propertyPath+makeSuffix(propertyName);\n  var base = uri.resolve(this.base, schema.id||'');\n  var ctx = new SchemaContext(schema, this.options, propertyPath, base, Object.create(this.schemas));\n  if(schema.id && !ctx.schemas[base]){\n    ctx.schemas[base] = schema;\n  }\n  return ctx;\n}\n\nvar FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {\n  'date-time': /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\\.\\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,\n  'date': /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,\n  'time': /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,\n\n  'email': /^(?:[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+\\.)*[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!\\.)){0,61}[a-zA-Z0-9]?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\\[(?:(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\]))$/,\n  'ip-address': /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,\n  'ipv6': /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/,\n  'uri': /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\\s]*$/,\n\n  'color': /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/,\n\n  // hostname regex from: http://stackoverflow.com/a/1420225/5628\n  'hostname': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n  'host-name': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n\n  'alpha': /^[a-zA-Z]+$/,\n  'alphanumeric': /^[a-zA-Z0-9]+$/,\n  'utc-millisec': function (input) {\n    return (typeof input === 'string') && parseFloat(input) === parseInt(input, 10) && !isNaN(input);\n  },\n  'regex': function (input) {\n    var result = true;\n    try {\n      new RegExp(input);\n    } catch (e) {\n      result = false;\n    }\n    return result;\n  },\n  'style': /\\s*(.+?):\\s*([^;]+);?/g,\n  'phone': /^\\+(?:[0-9] ?){6,14}[0-9]$/\n};\n\nFORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;\nFORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;\nFORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS['ip-address'];\n\nexports.isFormat = function isFormat (input, format, validator) {\n  if (typeof input === 'string' && FORMAT_REGEXPS[format] !== undefined) {\n    if (FORMAT_REGEXPS[format] instanceof RegExp) {\n      return FORMAT_REGEXPS[format].test(input);\n    }\n    if (typeof FORMAT_REGEXPS[format] === 'function') {\n      return FORMAT_REGEXPS[format](input);\n    }\n  } else if (validator && validator.customFormats &&\n      typeof validator.customFormats[format] === 'function') {\n    return validator.customFormats[format](input);\n  }\n  return true;\n};\n\nvar makeSuffix = exports.makeSuffix = function makeSuffix (key) {\n  key = key.toString();\n  // This function could be capable of outputting valid a ECMAScript string, but the\n  // resulting code for testing which form to use would be tens of thousands of characters long\n  // That means this will use the name form for some illegal forms\n  if (!key.match(/[.\\s\\[\\]]/) && !key.match(/^[\\d]/)) {\n    return '.' + key;\n  }\n  if (key.match(/^\\d+$/)) {\n    return '[' + key + ']';\n  }\n  return '[' + JSON.stringify(key) + ']';\n};\n\nexports.deepCompareStrict = function deepCompareStrict (a, b) {\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a instanceof Array) {\n    if (!(b instanceof Array)) {\n      return false;\n    }\n    if (a.length !== b.length) {\n      return false;\n    }\n    return a.every(function (v, i) {\n      return deepCompareStrict(a[i], b[i]);\n    });\n  }\n  if (typeof a === 'object') {\n    if (!a || !b) {\n      return a === b;\n    }\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n    return aKeys.every(function (v) {\n      return deepCompareStrict(a[v], b[v]);\n    });\n  }\n  return a === b;\n};\n\nfunction deepMerger (target, dst, e, i) {\n  if (typeof e === 'object') {\n    dst[i] = deepMerge(target[i], e)\n  } else {\n    if (target.indexOf(e) === -1) {\n      dst.push(e)\n    }\n  }\n}\n\nfunction copyist (src, dst, key) {\n  dst[key] = src[key];\n}\n\nfunction copyistWithDeepMerge (target, src, dst, key) {\n  if (typeof src[key] !== 'object' || !src[key]) {\n    dst[key] = src[key];\n  }\n  else {\n    if (!target[key]) {\n      dst[key] = src[key];\n    } else {\n      dst[key] = deepMerge(target[key], src[key])\n    }\n  }\n}\n\nfunction deepMerge (target, src) {\n  var array = Array.isArray(src);\n  var dst = array && [] || {};\n\n  if (array) {\n    target = target || [];\n    dst = dst.concat(target);\n    src.forEach(deepMerger.bind(null, target, dst));\n  } else {\n    if (target && typeof target === 'object') {\n      Object.keys(target).forEach(copyist.bind(null, target, dst));\n    }\n    Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));\n  }\n\n  return dst;\n};\n\nmodule.exports.deepMerge = deepMerge;\n\n/**\n * Validates instance against the provided schema\n * Implements URI+JSON Pointer encoding, e.g. \"%7e\"=\"~0\"=>\"~\", \"~1\"=\"%2f\"=>\"/\"\n * @param o\n * @param s The path to walk o along\n * @return any\n */\nexports.objectGetPath = function objectGetPath(o, s) {\n  var parts = s.split('/').slice(1);\n  var k;\n  while (typeof (k=parts.shift()) == 'string') {\n    var n = decodeURIComponent(k.replace(/~0/,'~').replace(/~1/g,'/'));\n    if (!(n in o)) return;\n    o = o[n];\n  }\n  return o;\n};\n\nfunction pathEncoder (v) {\n  return '/'+encodeURIComponent(v).replace(/~/g,'%7E');\n}\n/**\n * Accept an Array of property names and return a JSON Pointer URI fragment\n * @param Array a\n * @return {String}\n */\nexports.encodePath = function encodePointer(a){\n\t// ~ must be encoded explicitly because hacks\n\t// the slash is encoded by encodeURIComponent\n\treturn a.map(pathEncoder).join('');\n};\n\n\n/**\n * Calculate the number of decimal places a number uses\n * We need this to get correct results out of multipleOf and divisibleBy\n * when either figure is has decimal places, due to IEEE-754 float issues.\n * @param number\n * @returns {number}\n */\nexports.getDecimalPlaces = function getDecimalPlaces(number) {\n\n  var decimalPlaces = 0;\n  if (isNaN(number)) return decimalPlaces;\n\n  if (typeof number !== 'number') {\n    number = Number(number);\n  }\n\n  var parts = number.toString().split('e');\n  if (parts.length === 2) {\n    if (parts[1][0] !== '-') {\n      return decimalPlaces;\n    } else {\n      decimalPlaces = Number(parts[1].slice(1));\n    }\n  }\n\n  var decimalParts = parts[0].split('.');\n  if (decimalParts.length === 2) {\n    decimalPlaces += decimalParts[1].length;\n  }\n\n  return decimalPlaces;\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsonschema/lib/helpers.js\n// module id = k8+T\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/querystring-es3/decode.js\n// module id = kMPS\n// module chunks = 0","module.exports = { \"default\": require(\"core-js/library/fn/json/stringify\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/core-js/json/stringify.js\n// module id = mvHQ\n// module chunks = 0","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/url/util.js\n// module id = qOJP\n// module chunks = 0","var core = require('../../modules/_core');\nvar $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });\nmodule.exports = function stringify(it) { // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/fn/json/stringify.js\n// module id = qkKv\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var GUTTER_ID = \"CodeMirror-lint-markers\";\n\n  function showTooltip(e, content) {\n    var tt = document.createElement(\"div\");\n    tt.className = \"CodeMirror-lint-tooltip\";\n    tt.appendChild(content.cloneNode(true));\n    document.body.appendChild(tt);\n\n    function position(e) {\n      if (!tt.parentNode) return CodeMirror.off(document, \"mousemove\", position);\n      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + \"px\";\n      tt.style.left = (e.clientX + 5) + \"px\";\n    }\n    CodeMirror.on(document, \"mousemove\", position);\n    position(e);\n    if (tt.style.opacity != null) tt.style.opacity = 1;\n    return tt;\n  }\n  function rm(elt) {\n    if (elt.parentNode) elt.parentNode.removeChild(elt);\n  }\n  function hideTooltip(tt) {\n    if (!tt.parentNode) return;\n    if (tt.style.opacity == null) rm(tt);\n    tt.style.opacity = 0;\n    setTimeout(function() { rm(tt); }, 600);\n  }\n\n  function showTooltipFor(e, content, node) {\n    var tooltip = showTooltip(e, content);\n    function hide() {\n      CodeMirror.off(node, \"mouseout\", hide);\n      if (tooltip) { hideTooltip(tooltip); tooltip = null; }\n    }\n    var poll = setInterval(function() {\n      if (tooltip) for (var n = node;; n = n.parentNode) {\n        if (n && n.nodeType == 11) n = n.host;\n        if (n == document.body) return;\n        if (!n) { hide(); break; }\n      }\n      if (!tooltip) return clearInterval(poll);\n    }, 400);\n    CodeMirror.on(node, \"mouseout\", hide);\n  }\n\n  function LintState(cm, options, hasGutter) {\n    this.marked = [];\n    this.options = options;\n    this.timeout = null;\n    this.hasGutter = hasGutter;\n    this.onMouseOver = function(e) { onMouseOver(cm, e); };\n    this.waitingFor = 0\n  }\n\n  function parseOptions(_cm, options) {\n    if (options instanceof Function) return {getAnnotations: options};\n    if (!options || options === true) options = {};\n    return options;\n  }\n\n  function clearMarks(cm) {\n    var state = cm.state.lint;\n    if (state.hasGutter) cm.clearGutter(GUTTER_ID);\n    for (var i = 0; i < state.marked.length; ++i)\n      state.marked[i].clear();\n    state.marked.length = 0;\n  }\n\n  function makeMarker(labels, severity, multiple, tooltips) {\n    var marker = document.createElement(\"div\"), inner = marker;\n    marker.className = \"CodeMirror-lint-marker-\" + severity;\n    if (multiple) {\n      inner = marker.appendChild(document.createElement(\"div\"));\n      inner.className = \"CodeMirror-lint-marker-multiple\";\n    }\n\n    if (tooltips != false) CodeMirror.on(inner, \"mouseover\", function(e) {\n      showTooltipFor(e, labels, inner);\n    });\n\n    return marker;\n  }\n\n  function getMaxSeverity(a, b) {\n    if (a == \"error\") return a;\n    else return b;\n  }\n\n  function groupByLine(annotations) {\n    var lines = [];\n    for (var i = 0; i < annotations.length; ++i) {\n      var ann = annotations[i], line = ann.from.line;\n      (lines[line] || (lines[line] = [])).push(ann);\n    }\n    return lines;\n  }\n\n  function annotationTooltip(ann) {\n    var severity = ann.severity;\n    if (!severity) severity = \"error\";\n    var tip = document.createElement(\"div\");\n    tip.className = \"CodeMirror-lint-message-\" + severity;\n    if (typeof ann.messageHTML != 'undefined') {\n        tip.innerHTML = ann.messageHTML;\n    } else {\n        tip.appendChild(document.createTextNode(ann.message));\n    }\n    return tip;\n  }\n\n  function lintAsync(cm, getAnnotations, passOptions) {\n    var state = cm.state.lint\n    var id = ++state.waitingFor\n    function abort() {\n      id = -1\n      cm.off(\"change\", abort)\n    }\n    cm.on(\"change\", abort)\n    getAnnotations(cm.getValue(), function(annotations, arg2) {\n      cm.off(\"change\", abort)\n      if (state.waitingFor != id) return\n      if (arg2 && annotations instanceof CodeMirror) annotations = arg2\n      updateLinting(cm, annotations)\n    }, passOptions, cm);\n  }\n\n  function startLinting(cm) {\n    var state = cm.state.lint, options = state.options;\n    /*\n     * Passing rules in `options` property prevents JSHint (and other linters) from complaining\n     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.\n     */\n    var passOptions = options.options || options;\n    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\n    if (!getAnnotations) return;\n    if (options.async || getAnnotations.async) {\n      lintAsync(cm, getAnnotations, passOptions)\n    } else {\n      var annotations = getAnnotations(cm.getValue(), passOptions, cm);\n      if (!annotations) return;\n      if (annotations.then) annotations.then(function(issues) {\n        updateLinting(cm, issues);\n      });\n      else updateLinting(cm, annotations);\n    }\n  }\n\n  function updateLinting(cm, annotationsNotSorted) {\n    clearMarks(cm);\n    var state = cm.state.lint, options = state.options;\n\n    var annotations = groupByLine(annotationsNotSorted);\n\n    for (var line = 0; line < annotations.length; ++line) {\n      var anns = annotations[line];\n      if (!anns) continue;\n\n      var maxSeverity = null;\n      var tipLabel = state.hasGutter && document.createDocumentFragment();\n\n      for (var i = 0; i < anns.length; ++i) {\n        var ann = anns[i];\n        var severity = ann.severity;\n        if (!severity) severity = \"error\";\n        maxSeverity = getMaxSeverity(maxSeverity, severity);\n\n        if (options.formatAnnotation) ann = options.formatAnnotation(ann);\n        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));\n\n        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {\n          className: \"CodeMirror-lint-mark-\" + severity,\n          __annotation: ann\n        }));\n      }\n\n      if (state.hasGutter)\n        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,\n                                                       state.options.tooltips));\n    }\n    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.lint;\n    if (!state) return;\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);\n  }\n\n  function popupTooltips(annotations, e) {\n    var target = e.target || e.srcElement;\n    var tooltip = document.createDocumentFragment();\n    for (var i = 0; i < annotations.length; i++) {\n      var ann = annotations[i];\n      tooltip.appendChild(annotationTooltip(ann));\n    }\n    showTooltipFor(e, tooltip, target);\n  }\n\n  function onMouseOver(cm, e) {\n    var target = e.target || e.srcElement;\n    if (!/\\bCodeMirror-lint-mark-/.test(target.className)) return;\n    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;\n    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, \"client\"));\n\n    var annotations = [];\n    for (var i = 0; i < spans.length; ++i) {\n      var ann = spans[i].__annotation;\n      if (ann) annotations.push(ann);\n    }\n    if (annotations.length) popupTooltips(annotations, e);\n  }\n\n  CodeMirror.defineOption(\"lint\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      clearMarks(cm);\n      if (cm.state.lint.options.lintOnChange !== false)\n        cm.off(\"change\", onChange);\n      CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\n      clearTimeout(cm.state.lint.timeout);\n      delete cm.state.lint;\n    }\n\n    if (val) {\n      var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\n      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;\n      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);\n      if (state.options.lintOnChange !== false)\n        cm.on(\"change\", onChange);\n      if (state.options.tooltips != false && state.options.tooltips != \"gutter\")\n        CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n\n      startLinting(cm);\n    }\n  });\n\n  CodeMirror.defineExtension(\"performLint\", function() {\n    if (this.state.lint) startLinting(this);\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/codemirror/addon/lint/lint.js\n// module id = ryyk\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/querystring-es3/encode.js\n// module id = xaZU\n// module chunks = 0"],"sourceRoot":""}